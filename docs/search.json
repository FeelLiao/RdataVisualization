[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R语言数据可视化学习笔记",
    "section": "",
    "text": "欢迎\n欢迎来到R语言数据可视化的学习笔记，本项目主要记录了我在学习使用R语言ggplot2包进行数据可视化时的一些思考和代码。\nggplot2 是 R 语言中一个用于创建高质量图形和图表的强大包。它是基于“图形语法”（Grammar of Graphics）理论构建的，提供了一种灵活且一致的方式来描述和构建各种复杂的图形。ggplot2 的核心思想是将图形分解为多个组成部分，包括数据 (data)、映射（aes）、几何对象（geom）、统计变换（stat）、刻度（scale）和主题（theme）等。通过组合这些组件，用户可以轻松地创建从简单的散点图和柱状图到复杂的分层图形和地图等多种类型的图表。目前，ggplot2已经形成强大的拓展生态系统，可以利用ggplot2的扩展，轻松创建更加复杂和个性化的图形。\n笔记不会不含基础ggplot2绘图的相关知识，如果是初学者，建议先学习ggplot2: Elegant Graphics for Data Analysis (3e)。在这里，主要主要包含ggplot2的一些高级用法，包括ggplot2内部如何工作，编写ggplot2扩展的原理和利用ggplot2进行高级绘图。\n本项目旨在记录自己学习R语言数据可视化的过程，如有错误，欢迎在issue中提出。",
    "crumbs": [
      "欢迎"
    ]
  },
  {
    "objectID": "ChangeLog.html",
    "href": "ChangeLog.html",
    "title": "更新日志",
    "section": "",
    "text": "Top 50 ggplot2 Visualizations: 简单介绍了一些常用的绘图原则，以及如何组合ggplot2本身自带的函数来绘制一些高级图形，部分图形会用到ggplot2的拓展包。\n\n目前是英文版 2024-10-31 5  Top 50 ggplot2 Visualizations\n中文版已更新 2024-11-12 6  Top 50 ggplot2 可视化\n\n基础统计绘图更新\n\n曼哈顿图 2024-11-05\n分裂小提琴图 2024-11-07\n阴影条带哑铃图 2024-11-07\n\n网络相关绘图更新\n\n相关性网络图 2024-11-07",
    "crumbs": [
      "更新日志"
    ]
  },
  {
    "objectID": "ggplot2intro.html",
    "href": "ggplot2intro.html",
    "title": "1  ggplot2简介",
    "section": "",
    "text": "图层 Layers: 数据 data, 映射 mapping (美学 aesthetic), 几何对象 geom, 统计变换 stat, 位置调整 position adjustment\n标度 Scales\n坐标系 coordinate system\n分面 Faceting\n主题 Themes",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2简介</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html",
    "href": "ggplot2internal.html",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "2.1 The plot method\n当从用户转到开发人员时，遇到挫折是很常见的，因为在 ggplot2 中，用户的交互方式与其底层工作原理截然不同。随着 ggplot2 的扩展变得越来越常见，在理解如何将拓展的功能整合在一起上也会遇到挫折。本章将介绍 ggplot2 如何在 “幕后”工作。我们将重点放在系统的设计上，而不是其实现的技术细节，目的是让读者从概念上理解各部分是如何组合在一起的。首先，我们将概述绘制 ggplot 对象时的过程，然后深入细节，描述数据如何在整个过程中流动，并最终成为绘图中的可视化元素。\n在了解 ggplot2 的底层机制时，重要的是要认识到与绘图相关的几乎所有内容都是在打印 ggplot 对象时发生的，而不是在构建对象时发生的。例如，下面的代码中，对象 p 是绘图数据的抽象表示，如图层等。它并没有构造图像本身：\np &lt;- ggplot(mpg, aes(displ, hwy, color = drv)) + \n  geom_point(position = \"jitter\") +\n  geom_smooth(method = \"lm\", formula = y ~ x) + \n  facet_wrap(vars(year)) + \n  ggtitle(\"A plot for expository purposes\")\nggplot2 被设计成允许用户向图中添加新元素，而无需重新计算任何内容。这种设计的一个含义是，如果你想了解 ggplot2 的机制，你必须跟踪你的绘图是如何进入 plot()1的。你可以通过在控制台中输入 ggplot2:::plot.ggplot 来检查 ggplot 对象的打印方法，但本章我们将使用一个简化的版本。剥离到最基本的形式，ggplot2 的绘图方法与以下 ggprint() 函数的结构相同：\nggprint &lt;- function(x) {\n  data &lt;- ggplot_build(x)\n  gtable &lt;- ggplot_gtable(data)\n  grid::grid.newpage()\n  grid::grid.draw(gtable)\n  return(invisible(x))\n}\n这个函数并不处理所有可能的情况，但它足以绘制上面指定的图表：\nggprint(p)\n在我们简化的打印方法的代码中，显示了四个不同的步骤：\n这个过程揭示了 ggplot2 本身并不进行底层绘图：当创建了 gtable 对象后，它的责任就结束了。 gtable 包（实现了 gtable 类）也不进行任何绘制。 所有绘图工作都由 grid 软件包和激活的图形设备共同完成。 这是非常重要的一点，因为这意味着 ggplot2 或 ggplot2 的任何扩展都不会关心可视化输出的细枝末节。 相反，它的工作是将用户数据转换为一个或多个图形基元，如多边形、线、点等，然后将责任移交给 grid 包。\n尽管严格来说并不正确，但我们将称这个过程为渲染过程。接下来的两个部分数据将沿着渲染过程向下推进，通过 build step（Section 2.2）和 gtable step（Section 2.3），最终在图形基元的集合中到达 grid 。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-plot-method",
    "href": "ggplot2internal.html#sec-plot-method",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "首先，调用 ggplot_build()，这一步会准备每个图层的数据并整理成适合绘图的标准格式。\n其次，将准备好的数据传递给 ggplot_gtable()，并将其转化为存储在 gtable 中的图形元素（我们稍后再讨论 gtable 是什么）。\n第三，在 grid 软件包的帮助下，将 gtable 对象转换为图像。\n第四，将原始 ggplot 对象隐形返回给用户。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-ggplotbuild",
    "href": "ggplot2internal.html#sec-ggplotbuild",
    "title": "2  ggplot2工作原理",
    "section": "\n2.2 The build step",
    "text": "2.2 The build step\n正如上面讨论的，ggplot_build() 接受使用公共 API 构建的声明性表示，并通过准备数据以将其转换为图形基元来增强它。\n\n2.2.1 数据准备\n处理的第一部分是获取与每个图层相关的数据，并将其转换成可预测的格式。 图层可以通过以下三种方式之一提供数据：提供自己的数据（geom 的 data 参数是一个data frame），继承提供给 ggplot() 的全局数据，或者是一个函数，在应用到全局时返回一个data frame。 在所有三种情况下，结果都是一个data frame，它将传递给绘图布局，后者将协调坐标系和分面。 在这种情况下，数据首先被传递到绘图坐标系，坐标系可能会改变数据（但通常不会），然后被传递到分面，分面会检查数据以确定绘图应该有多少个面板以及如何组织这些面板。 在这个过程中，与每个图层相关的数据都会增加名叫 “PANEL” 一列数据。 这一列数据将（必须）在整个渲染过程中保留，用于将数据的每一行链接到最终绘图中的特定面板。\n数据准备的最后一部分是将图层数据转换为计算出的美学（aesthetic）值。 这包括在图层数据上评估来自 aes() 的所有美学表达式。 此外，如果没有明确给出，group美学值会从所有非连续美学值的交互中计算出来。 group美学和PANEL一样，是必须在整个处理过程中保留的特殊列。 例如，前面创建的p图只包含geom_point()指定的一个图层，在数据准备过程结束时，与该图层相关的前 10 行数据是这样的：\n\n2.2.2 数据转换\n提取图层数据并将其转换为可预测的格式后，需要进行一系列转换，直到转换为图层的几何图形所需的格式。 第一步是对数据中的列进行标度（scale）转换。 正是在这一阶段，标度中的任何 trans 参数都会产生影响，所有后续的渲染都将在这一转换后的空间中进行。 这就是在标度中设置位置变换与在坐标系中设置位置变换效果不同的原因。 如果在标度中指定变换，则变换会在任何其他计算之前应用，但如果在坐标系中指定变换，则变换会在这些计算之后应用。 例如，我们最初绘制的p图不涉及标度变换，因此图层数据在此阶段保持不变。 前三行如下所示：\n\n\n    x  y colour PANEL group\n1 1.8 29      f     1     2\n2 1.8 29      f     1     2\n3 2.0 31      f     2     2\n\n\n相反，如果我们的绘图对象是 p + scale_x_log10()，并在处理过程中检查此时的图层数据，我们就会看到 x 变量已进行了适当的转换：\n\n\n          x  y colour PANEL group\n1 0.2552725 29      f     1     2\n2 0.2552725 29      f     1     2\n3 0.3010300 31      f     2     2\n\n\n该过程的第二步是使用位置标度映射位置美学，根据所涉及的标度类型，映射过程会有不同的发生方式。 对于连续位置标度（例如我们示例中使用的标度），此时会应用 oob 参数中指定的出界函数，并删除图层数据中的 NA 值。 这对 p 没有什么影响，但如果我们绘制的是 p + xlim(2, 8)，则 oob 函数 – 本例中的 scales::censor() – 会用 NA 替换 2 以下的 x 值，如下图所示：\n\n\nWarning: Removed 22 rows containing non-finite values (stat_smooth).\n\n\n   x  y colour PANEL group\n1 NA 29      f     1     2\n2 NA 29      f     1     2\n3  2 31      f     2     2\n\n\n对于离散位置，变化则更为剧烈，因为数值会与用户提供的 “limits”值或 “breaks”规范相匹配，然后转换为整数值位置。 最后，对于 binned 位置标度，首先使用 breaks 参数将连续数据切成 bins，然后将每个 bin 的位置设置为其范围的中点。 在这一阶段进行映射的原因是保持一致性：无论使用哪种位置标度，在 stat 和 geom 计算中看起来都是连续的。 这一点非常重要，否则离散标度的闪避和抖动等计算都会失败。\n在转换的第三阶段，数据被移交给统计变换（stat），由统计变换进行统计转换。程序如下：首先，统计变换可以检查数据并修改其参数，然后对数据进行一次性处理。接下来，按 “PANEL”和 “group”对图层数据进行拆分，并在数据重新组合之前计算统计数据。[^ggplot2-internal-2] 一旦数据以新的形式重新组合，就会经过另一个美学映射过程。在这个过程中，使用 stat()（或旧的 ...var...符号）延迟计算的任何美学数据都会被添加到数据中。请注意，这就是为什么stat()表达式（包括用于在示例图p的geom_smooth()层中指定回归模型的公式）不能引用原始数据。此时，原始数据根本不存在。\n举例来说，我们可以看一下图中的第二图层，它可以产生线性回归结果。在进行统计计算之前，该图层的数据只包含坐标以及所需的 “PANEL”和 “group”列。\n\n\n    x  y colour PANEL group\n1 1.8 29      f     1     2\n2 1.8 29      f     1     2\n3 2.0 31      f     2     2\n\n\n在统计计算结束后，图层数据也会相应的改变：\n\n\n         x        y     ymin     ymax        se flipped_aes colour PANEL group\n1 1.800000 24.33592 23.07845 25.59339 0.6250675       FALSE      4     1     1\n2 1.859494 24.17860 22.94830 25.40890 0.6115600       FALSE      4     1     1\n3 1.918987 24.02127 22.81795 25.22460 0.5981528       FALSE      4     1     1\n\n\n此时，geom 接管了 stat 的工作（几乎）。它要做的第一件事就是检查数据、更新参数，并可能对数据进行第一次修改（与 stat 的设置相同）。这可能会对某些列进行重新参数化，例如将 x+width 改为 xmin+xmax。之后，位置调整将被应用，例如，重叠的条形图将被堆叠等。对于我们的示例图 p 来说，这一步是在图的第一层应用抖动，并对 x 和 y 坐标进行扰动：\n\n\n         x        y colour PANEL group\n1 1.775735 29.08448      f     1     2\n2 1.782166 28.72732      f     1     2\n3 1.992427 31.09196      f     2     2\n\n\n接下来–也许令人惊讶的是–位置标度将全部重置、重新训练并应用于图层数据。仔细想想，这绝对是必要的，因为，例如，堆叠会极大地改变其中一个坐标轴的范围。在某些情况下（例如在上面的直方图示例中），其中一个位置美学可能甚至要到统计计算之后才能获得，如果不对刻度进行重新训练，它就永远不会得到训练。\n数据转换的最后一部分是训练和映射所有非位置美学，即把映射的离散或连续输入转换成图形参数，如颜色、线型、大小等。此外，还将添加地形图中的任何默认美学，以便数据现在处于地形图的可预测状态。在最后一步，在构建步骤完成之前，stat 和 facet 都有最后一次机会使用它们的 “finish_data()”方法修改数据的最终映射形式。对于绘图对象 p 来说，图层数据最终状态的前几行是这样的：\n\n\n   colour        x        y PANEL group shape size fill alpha stroke\n1 #00BA38 1.796652 29.03605     1     2    19  1.5   NA    NA    0.5\n2 #00BA38 1.806750 29.34470     1     2    19  1.5   NA    NA    0.5\n3 #00BA38 1.964462 30.98018     2     2    19  1.5   NA    NA    0.5\n\n\n\n2.2.3 输出\nggplot_build()的返回值是一个包含ggplot_built类的列表结构。它包含计算数据以及一个Layout` 对象，该对象包含有关训练过的坐标系和切面的信息。此外，它还包含一个原始绘图对象的副本，使用经过训练的标度。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-ggplotgtable",
    "href": "ggplot2internal.html#sec-ggplotgtable",
    "title": "2  ggplot2工作原理",
    "section": "\n2.3 The gtable step",
    "text": "2.3 The gtable step\nggplot_gtable()的目的是获取 build step 的输出，并在 gtable 软件包的帮助下将其转化为可以使用grid绘制的对象。此时，负责进一步计算的主要元素是地形、坐标系、切面和主题。统计和位置调整已经不再发挥了它们的作用。\n\n2.3.1 渲染面板\n首先是将数据转换成图形表示。这分两步进行。首先，将每个图层转换为图形对象列表（“grobs”）。与统计一样，转换是通过分割数据进行的，首先是按 “PANEL”分割，然后是按 “group”分割，出于性能考虑，geom 可能会拦截这种分割。虽然很多数据准备工作已经完成，但在这一步中，geom 还会对数据进行一些额外的转换，这种情况并不少见。其中最关键的部分是位置数据的转换和归一化。这是由坐标系完成的，虽然这通常只是意味着根据坐标系的限制对数据进行归一化，但也可能包括激进的转换，如将位置转换为极坐标。这样做的结果是为每个图层生成一个gList对象列表，该列表与切面布局中的每个面板相对应。之后，切面接手并组装面板。它首先从图层中收集每个面板的凹槽，以及基于主题的渲染条、背景、网格线和坐标轴，并将所有这些合并到每个面板的单个 gList 中。然后，它会根据计算出的面板布局将所有这些面板排列到一个 gtable 中。对于大多数绘图来说，这很简单，因为只有一个面板，但对于使用了 “facet_wrap()”的绘图来说，这可能会相当复杂。输出结果是最终 gtable 对象的基础。在处理过程的这一阶段，我们的示例图 p 看起来是这样的：\n\n\n\n\n\n\n\n\n\n2.3.2 添加导图\nggplot2 中有两种类型的导图：坐标轴和图例。正如我们的图 p 所示，此时坐标轴已经渲染完成，并与面板组装在一起，但图例仍然缺失。渲染图例是一个复杂的过程，首先要为每个比例尺训练一个向导。然后，如果映射允许，可能会合并多个导引器，然后再要求为图例作出贡献的图层为图例中的每个键提供键槽。然后，这些键槽会在各图层之间进行组合，并合并成最终的图例，这个过程让人想起图层是如何合并成面板的 gtable 的。最后输出的是一个 gtable，其中包含根据主题和指南规格排列和样式的每个图例框。创建完成后，会根据 legend.position主题设置将引导 gtable 添加到主 gtable 中。至此，我们的示例绘图在大多数方面都已完成：唯一缺少的就是标题。\n\n\n\n\n\n\n\n\n\n2.3.3 添加修饰\n剩下的工作就是添加标题、副标题、标题和标签，以及添加背景和页边距，这样最终的表格就完成了。\n\n2.3.4 Output\n至此，ggplot2 已准备好移交给 grid。我们的渲染过程大致相当于下面的代码，最终结果如上所述，是一个 gtable：\n\np_built &lt;- ggplot_build(p)\np_gtable &lt;- ggplot_gtable(p_built)\n\nclass(p_gtable)\n\n[1] \"gtable\" \"gTree\"  \"grob\"   \"gDesc\" \n\n\n不那么明显的是，对象的尺寸是不可预测的，将取决于切面、图例位置和绘制的标题。因此，如果要进一步修改 gtable，建议不要在代码中依赖行和列的位置。不过，gtable 中的所有元素都已命名，因此仍可以通过一些工作可靠地检索到，例如左上角 y 轴的槽。下面的代码显示了我们的绘图 p 的 gtable：\n\np_gtable\n\nTableGrob (13 x 15) \"layout\": 22 grobs\n    z         cells        name                                          grob\n1   0 ( 1-13, 1-15)  background               rect[plot.background..rect.741]\n2   1 ( 8- 8, 5- 5)   panel-1-1                      gTree[panel-1.gTree.612]\n3   1 ( 8- 8, 9- 9)   panel-2-1                      gTree[panel-2.gTree.627]\n4   3 ( 6- 6, 5- 5)  axis-t-1-1                                zeroGrob[NULL]\n5   3 ( 6- 6, 9- 9)  axis-t-2-1                                zeroGrob[NULL]\n6   3 ( 9- 9, 5- 5)  axis-b-1-1           absoluteGrob[GRID.absoluteGrob.631]\n7   3 ( 9- 9, 9- 9)  axis-b-2-1           absoluteGrob[GRID.absoluteGrob.631]\n8   3 ( 8- 8, 8- 8)  axis-l-1-2                                zeroGrob[NULL]\n9   3 ( 8- 8, 4- 4)  axis-l-1-1           absoluteGrob[GRID.absoluteGrob.639]\n10  3 ( 8- 8,10-10)  axis-r-1-2                                zeroGrob[NULL]\n11  3 ( 8- 8, 6- 6)  axis-r-1-1                                zeroGrob[NULL]\n12  2 ( 7- 7, 5- 5) strip-t-1-1                                 gtable[strip]\n13  2 ( 7- 7, 9- 9) strip-t-2-1                                 gtable[strip]\n14  4 ( 5- 5, 5- 9)      xlab-t                                zeroGrob[NULL]\n15  5 (10-10, 5- 9)      xlab-b titleGrob[axis.title.x.bottom..titleGrob.694]\n16  6 ( 8- 8, 3- 3)      ylab-l   titleGrob[axis.title.y.left..titleGrob.697]\n17  7 ( 8- 8,11-11)      ylab-r                                zeroGrob[NULL]\n18  8 ( 8- 8,13-13)   guide-box                             gtable[guide-box]\n19  9 ( 4- 4, 5- 9)    subtitle         zeroGrob[plot.subtitle..zeroGrob.737]\n20 10 ( 3- 3, 5- 9)       title          titleGrob[plot.title..titleGrob.736]\n21 11 (11-11, 5- 9)     caption          zeroGrob[plot.caption..zeroGrob.739]\n22 12 ( 2- 2, 2- 2)         tag              zeroGrob[plot.tag..zeroGrob.738]\n\n\n正如人们所希望的那样，最终的情节看起来与原作完全相同：\n\ngrid::grid.newpage()\ngrid::grid.draw(p_gtable)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-ggproto",
    "href": "ggplot2internal.html#sec-ggproto",
    "title": "2  ggplot2工作原理",
    "section": "\n2.4 ggproto 简介",
    "text": "2.4 ggproto 简介\nSection 2.1 到 Section 2.3 的重点是构建 ggplot 所涉及的事件顺序，但对于执行这项工作的编程对象类型却有意含糊其辞。\n所有的ggplot2对象都是使用面向对象编程的ggproto系统构建的。这是一个历史性的意外：ggplot2 最初使用 proto 进行面向对象编程，但由于 proto 系统的局限性，需要一个正式的扩展机制，这就成了一个问题。试图将 ggplot2 转换到其他系统（如 R6）的尝试被证明是困难的，而创建一个专门针对 ggplot2 需求的面向对象系统被证明是最不坏的解决方案。\n如果你想编写 ggplot2 扩展程序，了解 ggproto 面向对象编程系统是非常重要的。我们将在@sec-ggplot2extend和@sec-spring1 中遇到 ggplot2 使用的 ggproto 对象。与更著名的 R6 系统一样，ggproto 使用引用语义，允许继承和访问父类的方法。虽然 ggproto 并不强制执行这些设计原则，但它们对于理解如何在 ggplot2 中使用该系统至关重要。为了说明这些概念，本节将以简化的形式介绍 ggproto 的核心机制。\n\n2.4.1 ggproto 对象\n创建一个新的ggproto对象需要使用ggproto()函数，该函数的第一个参数是新类的名称，第二个参数是新类继承的另一个ggproto对象。例如，我们可以用下面的命令创建一个ggproto对象–尽管它没有任何有用的功能：\n\nNewObject &lt;- ggproto(\n  `_class` = NULL, \n  `_inherits` = NULL\n)\n\n按照惯例，ggproto 对象使用 “UpperCamelCase”（大写字母）命名，每个单词都以大写字母开头。省略`_class`和`_inherits`参数的名称也是惯例，因此该命令的常规形式如下：\n\nNewObject &lt;- ggproto(NULL, NULL)\n\n如果我们打印这个对象，就会发现它确实是一个 ggproto 对象，但没有显示其他信息。\n\nNewObject \n\n&lt;ggproto object: Class gg&gt;\n\n\n\n2.4.2 创建新类\n要创建一个新的 ggproto 类，唯一严格需要做的就是提供一个类名作为 ggproto() 的第一个参数。定义一个新类的最简单命令可能是这样的\n\nNewClass &lt;- ggproto(\"NewClass\", NULL)\n\nNewClass变量仍然指向一个 ggproto 对象，但我们可以通过打印它来验证它是否具有所需的类名：\n\nNewClass\n\n&lt;ggproto object: Class NewClass, gg&gt;\n\n\n然而，到目前为止，我们所做的唯一一件事就是创建一个指定类的对象。NewClass对象什么也不做。要创建一个有用的 ggproto 类，我们需要在定义类时提供一个字段和方法列表。在这里，“字段”用于存储与对象相关的数据，而 “方法”则是可以使用对象中存储的数据的函数。字段和方法的构造是一样的，从用户的角度来看，它们不会被区别对待。\n为了说明这一点，我们将创建一个名为 Person 的新类，用来存储和操作一个人的信息。我们可以通过向 ggproto() 函数提供名称/值对来实现这一点：\n\nPerson &lt;- ggproto(\"Person\", NULL,\n  \n  # fields                  \n  given_name = NA,\n  family_name = NA,\n  birth_date = NA,\n  \n  # methods\n  full_name = function(self, family_last = TRUE) {\n    if(family_last == TRUE) {\n      return(paste(self$given_name, self$family_name))\n    }\n    return(paste(self$family_name, self$given_name))\n  },\n  age = function(self) {\n    days_old &lt;- Sys.Date() - self$birth_date\n    floor(as.integer(days_old) / 365.25)\n  },\n  description = function(self) {\n    paste(self$full_name(), \"is\", self$age(), \"years old\")\n  }\n)\n\n现在，Person类有三个字段，分别对应人的 given_name, family_name和birth_date。它还拥有三个方法：full_name()方法是一个构造人的全名的函数，使用的惯例是将给名放在前面，姓氏放在后面；age()方法以年为单位计算人的年龄；description()方法打印出人的简短描述。\n打印对象会显示与其相关的字段和方法：\n\nPerson\n\n&lt;ggproto object: Class Person, gg&gt;\n    age: function\n    birth_date: NA\n    description: function\n    family_name: NA\n    full_name: function\n    given_name: NA\n\n\nPerson这个 ggproto 对象本质上是类的模板，我们可以用它来创建单个人的特定记录（在@sec-ggproto-instances 中讨论）。如果你熟悉其他面向对象编程系统，你可能会期待一些不同的东西：通常新类的定义有一个专门的构造函数。ggproto的一个怪癖是ggproto()不会这样做：相反，类的构造函数本身就是一个对象。\n定义方法时需要注意的另一点是使用 self 作为第一个参数。这是一个特殊参数，用于让方法访问与 ggproto 对象相关的字段和方法（示例参见@sec-ggproto-subclass）。这个参数的特殊地位在打印 ggproto 方法时显而易见：\n\nPerson$full_name\n\n&lt;ggproto method&gt;\n  &lt;Wrapper function&gt;\n    function (...) \nf(..., self = self)\n\n  &lt;Inner function (f)&gt;\n    function(self, family_last = TRUE) {\n    if(family_last == TRUE) {\n      return(paste(self$given_name, self$family_name))\n    }\n    return(paste(self$family_name, self$given_name))\n  }\n\n\n这个输出结果似乎有点出人意料：当我们之前定义 full_name() 时，我们只提供了作为 “内部函数”列出的代码。现在的情况是，ggproto() 自动将我的函数封装在一个封装函数中，该封装函数调用我的代码作为内部函数，同时确保使用了适当的 self 定义。当打印该方法时，控制台会同时显示封装函数（通常没什么意义）和内部函数。这种格式的输出出现在@sec-extensions和@sec-spring1 中。\n\n2.4.3 创建新的实例\n既然已经定义了 Person 类，我们就可以创建该类的实例了。方法是将一个 ggproto 对象作为第二个参数传递给 ggproto()，而不在第一个参数中指定一个新的类名。例如，我们可以如下创建新对象 Thomas 和 Danielle ，它们都是 Person 类的实例：\n\nThomas &lt;- ggproto(NULL, Person,\n  given_name = \"Thomas Lin\",\n  family_name = \"Pedersen\",\n  birth_date = as.Date(\"1985/10/12\")\n)\n\nDanielle &lt;- ggproto(NULL, Person,\n  given_name = \"Danielle Jasmine\",\n  family_name = \"Navarro\",\n  birth_date = as.Date(\"1977/09/12\")\n)\n\n将 NULL 指定为第一个参数，将指示 ggproto() 不定义一个新类，而是创建第二个参数中指定的类的新实例。由于 Thomas 和 Danielle 都是 Person 类的实例，它们自动继承了 age(), full_name() 和 description() 方法：\n\nThomas$description()\n\n[1] \"Thomas Lin Pedersen is 39 years old\"\n\nDanielle$description()\n\n[1] \"Danielle Jasmine Navarro is 47 years old\"\n\n\n\n2.4.4 创建子类\n在前面的示例中，我们创建了一个全新的类 Person。在实践中，你几乎永远不需要这样做：相反，你可能会使用现有的 ggproto 对象创建一个子类。为此，您可以在调用 ggproto() 时指定子类的名称及其继承对象：\n\n# define the subclass\nNewSubClass &lt;- ggproto(\"NewSubClass\", Person)\n\n# verify that this works\nNewSubClass\n\n&lt;ggproto object: Class NewSubClass, Person, gg&gt;\n    age: function\n    birth_date: NA\n    description: function\n    family_name: NA\n    full_name: function\n    given_name: NA\n    super:  &lt;ggproto object: Class Person, gg&gt;\n\n\n上面的输出显示，NewSubClass现在提供了自己的类，它继承了我们之前创建的 Person对象的所有字段和方法。但是，这个新的子类并没有添加任何新功能。\n在创建子类时，我们经常要添加新的字段或方法，并覆盖一些已有的字段或方法。例如，假设我们要将 Royalty定义为Person的子类，并添加与相关皇室成员的 rank及其统治的territory相对应的字段。由于皇室成员通常以头衔和领地而不是姓氏和名字来称呼，因此我们还需要更改 full_name() 方法的定义方式：\n\nRoyalty &lt;- ggproto(\"Royalty\", Person,\n  rank = NA,\n  territory = NA,\n  full_name = function(self) {\n    paste(self$rank, self$given_name, \"of\", self$territory)\n  }\n)\n\nThe Royalty object now defines a subclass of person that inherits some fields (given_name, family_name, birth_date) from the Person class, and supplies other fields (rank, territory). It inherits the age() and description() methods from Person, but it overwrites the full_name() method.\nRoyalty 对象现在定义了一个 Person 类的子类，它从 Person 类继承了一些字段（given_name、family_name、birth_date），并提供其他字段（rank、territory）。它从 Person 类继承了 age() 和 description() 方法，但它重写了 full_name() 方法。\n我们可以使用 ggproto() 创建 Royalty 类的实例，如下所示：\n\nVictoria &lt;- ggproto(NULL, Royalty,\n  given_name = \"Victoria\",\n  family_name = \"Hanover\",\n  rank = \"Queen\",\n  territory = \"the United Kingdom\",\n  birth_date = as.Date(\"1819/05/24\")\n)\n\n因此，当我们调用 Victoria 的 full_name() 方法时，输出结果会使用 Royalty 类中指定的方法，而不是 Person 类中定义的方法：\n\nVictoria$full_name()\n\n[1] \"Queen Victoria of the United Kingdom\"\n\n\n值得注意的是，当我们调用 description() 方法时会发生什么。该方法继承自 Person，但该方法的定义调用了 self$full_name()。尽管 description() 是在 Person 中定义的，但在此上下文中，self 仍然指的是 Victoria，她仍然是 Royalty。这意味着继承的 description() 方法的输出将使用为子类定义的 full_name() 方法：\n\nVictoria$description()\n\n[1] \"Queen Victoria of the United Kingdom is 205 years old\"\n\n\n创建子类有时需要访问父类及其方法，我们可以借助 ggproto_parent() 函数来实现。例如，我们可以定义一个 Police子类，该子类与 Royalty子类一样包含一个 rank字段，但只将该rank用作 description()方法的一部分：\n\nPolice &lt;- ggproto(\"Police\", Person,\n  rank = NA, \n  description = function(self) {\n    paste(\n      self$rank,\n      ggproto_parent(Person, self)$description()\n    )\n  }\n)\n\n在这个例子中，Police 子类的 description() 方法被定义成明确引用 Person 父类的 description() 方法。通过使用 ggproto_parent(Person, self) 的这种方式，我们能够引用父类内的方法，同时仍然保留 self 的适当本地定义。和之前一样，我们将创建一个特定的实例并验证这如预期般工作：\n\nJohn &lt;- ggproto(NULL, Police,\n  given_name = \"John\",\n  family_name = \"McClane\",\n  rank = \"Detective\",\n  birth_date = as.Date(\"1955/03/19\")\n)\n\nJohn$full_name() \n\n[1] \"John McClane\"\n\nJohn$description()\n\n[1] \"Detective John McClane is 69 years old\"\n\n\n由于我们将在下文讨论的原因，ggprot_parent() 的使用在 ggplot2 源代码中并不普遍。\n\n2.4.5 ggproto 代码风格\n由于 ggproto 是一个最小化的类系统，专门为 ggplot2 设计，不涉及其他任何内容，因此重要的是要认识到 ggproto 在 ggplot2 中的使用方式是非常特定的。它存在的目的是支持 ggplot2 的扩展系统，您不太可能在编写 ggplot2 扩展以外的任何环境中遇到 ggproto。考虑到这一点，了解 ggplot2 如何使用 ggproto 是有用的：\n\nggproto 类被有选择地使用。在 ggplot2 中使用 ggproto 并不是全面的。只有选择性的功能是基于 ggproto 的，并且既不期望也不建议在您的扩展中创建完全新的 ggproto 类。作为扩展开发者，您永远不会创建完全的 ggproto 对象，而是需要继承 ggplot2 提供的某个主要的 ggproto 类。Chapter 4 和 Chapter 4 将详细介绍如何做到这一点。\nggproto 类是无状态的。除了用于编排渲染的少数内部类之外，ggplot2 中的 ggproto 类被认为是“无状态的”。这意味着 ggplot2 预期在它们被构建之后，它们不会改变。这打破了对于基于引用的类（其中的方法通常可以安全地改变对象的状态）的常见期望，但在 ggplot2 中这样做是不安全的。如果您的代码违反了这个原则，并在渲染过程中改变了 Stat 或 Geom 的状态，那么绘制已保存的 ggplot 对象将会影响 所有 该 Stat 或 Geom 的实例（即使那些在其他图表中使用的实例），因为它们都指向同一个 ggproto 父对象。考虑到这一点，您应该只在两种情况下指定 ggplot2 中 ggproto 对象的状态。首先，您可以在创建对象时指定状态：这是可以接受的，因为此状态应该在任何实例之间共享。其次，您可以通过在别处管理的 params 对象来指定状态。正如您将在后面看到的（参见 Section 4.2 和 Section 4.3），大多数 ggproto 类都有一个 setup_params() 方法，在那里可以检查数据并计算和存储特定的属性。\nggproto 类有简单的继承。由于 ggproto 类实例是无状态的，调用定义在其他类内部的方法，而不是显式地从该类继承，是相对安全的。这就是为什么在 ggplot2 源代码中很少调用 ggproto_parent() 函数的原因。例如，GeomErrorbar 中的 setup_params() 方法被定义为：\n\n\n    #| eval: false\n    GeomErrorbar &lt;- ggproto(\n      # ...\n      setup_params = function(data, params) {\n        GeomLinerange$setup_params(data, params)\n      }\n      # ...\n    )\n\n这种模式通常比使用 ggproto_parent() 更容易读取，而且因为 ggproto 对象是无状态的，所以也同样安全。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#footnotes",
    "href": "ggplot2internal.html#footnotes",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "你通常不会直接调用这个 plot() 方法，因为它是由打印方法调用的，因此每当打印 ggplot 对象时都会调用它。↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html",
    "href": "ggplot2extend.html",
    "title": "3  编写ggplot2拓展",
    "section": "",
    "text": "4 扩展 ggplot2\nggplot2 包的设计使其能够相对容易的通过通用语法组件来构建新的绘图类型，以扩展其功能。ggplot2 允许拓展开发者将其拓展作为包进行分发，拓展的易制作性也使编写一次性拓展来解决特定的绘图问题成为可能。本章讨论了编写 ggplot2 拓展的不同方式，并强调了需要注意的特定问题。我们将在整章中提供小示例，但要从头到尾查看一个完整的示例，请参见 Chapter 4。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2拓展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新主题-new-themes",
    "href": "ggplot2extend.html#新主题-new-themes",
    "title": "3  编写ggplot2拓展",
    "section": "\n4.1 新主题 New themes",
    "text": "4.1 新主题 New themes\n\n4.1.1 修改主题\n主题可能是最简单的拓展形式，它们只需要使用在 ggplot2 创建图表时会使用的代码。虽然可以从零开始构建新主题，但通常修改现有主题更简单且不易出错。ggplot2 源代码中通常采用这种方法。例如，这是 theme_minimal() 的源代码：\n\ntheme_minimal &lt;- function(base_size = 11, \n                          base_family = \"\", \n                          base_line_size = base_size/22, \n                          base_rect_size = base_size/22) {\n    theme_bw(\n      base_size = base_size, \n      base_family = base_family, \n      base_line_size = base_line_size, \n      base_rect_size = base_rect_size\n    ) %+replace% \n    theme(\n      axis.ticks = element_blank(), \n      legend.background = element_blank(), \n      legend.key = element_blank(), \n      panel.background = element_blank(), \n      panel.border = element_blank(), \n      strip.background = element_blank(), \n      plot.background = element_blank(), \n      complete = TRUE\n    )\n}\n\n如你所见，代码与在为图表添加样式时写的代码没有太大不同。theme_minimal() 函数使用 theme_bw() 作为基础主题，然后使用 %+replace% 运算符替换了其中某些参数的值。在创建新主题时，为用户提供一些参数来自定义主题是比较好的做法，比如文本、线条的粗细和主题辅助颜色等。例如，我们可以创建一个 theme_minimal() 的变体，允许用户指定图表的背景颜色：\ntheme_background &lt;- function(background = \"white\", ...) {\n  theme_minimal(...) %+replace%\n    theme(\n      plot.background = element_rect(\n        fill = background,\n        colour = background\n      ),\n      complete = TRUE\n    )\n}\n\nbase &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()\nbase + theme_minimal(base_size = 14)\nbase + theme_background(base_size = 14)\nbase + theme_background(base_size = 14, background = \"grey70\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.1.2 完整的主题\n需要注意的是， theme_minimal() 和 theme_background() 的代码中 complete = TRUE 的使用。在创建自己的 ggplot2 主题时，complete = TRUE将确保你的主题的行为与默认主题相同，因此不太可能让用户很惊讶。为了理解为什么这是必要的，比较这两个主题：\n\n# good \ntheme_predictable &lt;- function(...) {\n  theme_classic(...) %+replace% \n    theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\"),\n      complete = TRUE\n    )\n}\n\n# bad\ntheme_surprising &lt;- function(...) {\n  theme_classic(...) %+replace% \n    theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\")\n    )\n}\n\n两个主题都打算做同一件事：更改默认的 theme_classic()主题，以便 x 轴用蓝色线条绘制，y 轴用橙色线条绘制。乍一看，两个版本似乎都符合用户期望：\nbase + theme_classic()\nbase + theme_predictable()\nbase + theme_surprising()\n\n\n\n\n\n\n\n\n\n\n\n\n\n然而，假设你的主题用户想要移除轴线条：\nbase + theme_classic() + theme(axis.line = element_blank())\nbase + theme_predictable() + theme(axis.line = element_blank())\nbase + theme_surprising() + theme(axis.line = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\ntheme_predictable() 的行为与 theme_classic() 相同，轴线条被移除，但对于 theme_surprising() 则不是这样。原因是 ggplot2 将完整主题视为一系列“后备”值：当用户向完整主题添加 theme(axis.line = element_blank()) 时，不需要依赖 axis.line.x 或 axis.line.y 的后备值，因为这些是从用户命令中的 axis.line 继承的。这是对用户的善意，因为它允许他们使用像 theme_predictable() + theme(axis.line = ...) 这样的命令覆盖所有从 axis.line 继承的内容。相比之下，theme_surprising() 没有指定一个完整主题。当用户调用 theme_surprising() 时，后备值来自 theme_classic()，但更重要的是，ggplot2 将设置 axis.line.x 和 axis.line.y 的 theme() 命令完全视为用户输入的命令。因此，图表规范等效于此：\n\nbase + \n  theme_classic() +\n  theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\"),\n      axis.line = element_blank()\n  )\n\n\n\n\n\n\n\n在这段代码中，特定优先继承规则适用，因此设置 axis.line 不会覆盖更具体的 axis.line.x。\n\n4.1.3 定义主题元素\n在 ?sec-polishing 中我们看到，ggplot2 主题的结构由元素树定义。元素树指定了每个主题元素的类型以及它从哪里继承其值（你可以使用 get_element_tree() 函数将此树作为列表返回）。ggplot2 的扩展系统允许你通过使用 register_theme_elements() 函数将新主题元素注册为元素树的一部分来定义新主题元素。假设你正在编写一个名为 “ggxyz” 的新包，它包括作为坐标系统一部分的面板注释，你希望这个面板注释成为一个主题元素：\n\nregister_theme_elements(\n  ggxyz.panel.annotation = element_text(\n    color = \"blue\", \n    hjust = 0.95, \n    vjust = 0.05\n  ),\n  element_tree = list(\n    ggxyz.panel.annotation = el_def(\n      class = \"element_text\", \n      inherit = \"text\"\n    )\n  )\n)\n\n在包中定义新主题元素时要注意两点：\n\n重要的是要从包的 .onLoad() 函数中调用 register_theme_elements()，以便新主题元素对使用包中函数的任何人都可用，无论包是否已附加。\n始终是个好主意在任何新主题元素前包含你的包的名称作为前缀。这样，如果有人写了另一个面板注释包 ggabc，就不会有主题元素 ggxyz.panel.annotation 和 ggabc.panel.annotation 之间的潜在冲突。\n\n元素树更新后，包可以定义一个使用新主题元素的新坐标系统。一个简单的方法是定义一个创建新的 CoordCartesian ggproto 对象的函数。我们将在 Section 4.4 中更多地讨论这一点，但现在只需注意这段代码将有效：\n\ncoord_annotate &lt;- function(label = \"panel annotation\") {\n  ggproto(NULL, CoordCartesian,\n          limits = list(x = NULL, y = NULL),\n          expand = TRUE,\n          default = FALSE,\n          clip = \"on\",\n          render_fg = function(panel_params, theme) {\n            element_render(\n              theme = theme, \n              element = \"ggxyz.panel.annotation\", \n              label = label\n            )\n          }\n  )\n}\n\n所以现在这将有效：\nbase + coord_annotate(\"annotation in blue\")\nbase + coord_annotate(\"annotation in blue\") + theme_dark()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n修改了元素树后，值得一提的是 reset_theme_settings() 函数会恢复默认元素树，丢弃所有新元素定义，并（除非关闭）将当前激活的主题重置为默认。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2拓展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-stats",
    "href": "ggplot2extend.html#sec-new-stats",
    "title": "3  编写ggplot2拓展",
    "section": "\n4.2 新统计",
    "text": "4.2 新统计\n可能令人惊讶的是，创建新统计是扩展 ggplot2 功能最有用的方式之一。当用户向图表添加新图层时，他们通常使用 geom 函数，因此作为开发人员，你可能会认为你的 ggplot2 扩展应该封装为一个新的 geom。在一定程度上这是正确的，因为你的用户可能会想要使用 geom 函数，但实际上不同 geoms 之间的多样性主要是由于不同的统计。使用统计的好处之一是它们纯粹是关于数据转换的。大多数 R 用户和开发人员对数据转换非常熟悉，这使得定义新统计变得更容易。只要所需的行为可以封装在一个统计中，就无需对任何 grid 调用进行调整。\n\n4.2.1 创建统计\n如在 ?sec-internals 中讨论的，统计的核心行为由对 compute_layer()、compute_panel() 和 compute_group() 的分层调用序列捕获，所有这些都是与定义统计的 ggproto 对象相关联的方法。默认情况下，前两个函数不执行太多操作，它们只是将数据集按 PANEL 列拆分，调用 compute_panel()，然后重新组装结果。\n\n\ncompute_layer() 按 PANEL 列拆分数据集，调用 compute_panel()，并重新组装结果。\n\ncompute_panel() 将面板数据按 group 列拆分，调用 compute_group()，并重新组装结果。\n\n因此，作为开发人员，你通常只需要指定 compute_group() 函数，其工作是获取单个组的数据并适当转换它。这将足以创建一个工作统计，尽管可能不会产生最佳性能。因此，开发人员有时会发现将一些工作转移到 compute_panel() 是有价值的：这样做可以允许你矢量化计算并避免昂贵的拆分-组合步骤（我们将在 Section 5.2 中看到这样一个例子）。然而，通常最好首先仅修改 compute_group()，然后看看性能是否足够。\n为了说明这一点，我们首先创建一个计算一组点的凸包的统计，使用 grDevices 中包含的 chull() 函数。正如你可能预期的，大部分工作是由我们将要创建的新 ggproto 对象完成的：\n\nStatChull &lt;- ggproto(\"StatChull\", Stat,\n  compute_group = function(data, scales) {\n    data[chull(data$x, data$y), , drop = FALSE]\n  },\n  required_aes = c(\"x\", \"y\")\n)\n\n如在 Section 2.4 中所述，ggproto() 的前两个参数用于指示此对象定义了一个新的类（方便地命名为 \"StatChull\"），它从 Stat 对象继承字段和方法。然后我们指定只需要从 Stat 提供的默认值中更改的字段和方法，即 compute_group() 和 required_aes。我们的 compute_group() 函数接受两个输入，data 和 scales—因为这是 ggplot2 所期望的—但实际计算仅依赖于 data。请注意，由于计算必须同时存在两个位置美学，我们还指定了 required_aes 字段，以确保 ggplot2 知道这些美学是必需的。\n通过创建这个 ggproto 对象，我们有一个工作统计，但还没有给用户提供访问它的方式。为了解决这个问题，我们编写一个图层函数 stat_chull()。所有图层函数都有相同的形式：你在函数参数中指定默认值，然后调用 layer()，将 ... 传递到 params 参数中。... 中的参数将是 geom 的参数（如果你正在制作一个统计包装器），统计的参数（如果你正在制作一个 geom 包装器），或者要设置的美学。\n\nstat_chull &lt;- function(mapping = NULL, data = NULL, \n                       geom = \"polygon\", position = \"identity\", \n                       na.rm = FALSE, show.legend = NA, \n                       inherit.aes = TRUE, ...) {\n  layer(\n    stat = StatChull, \n    data = data, \n    mapping = mapping, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n现在我们的统计可以在图表中使用：\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  stat_chull(fill = NA, colour = \"black\")\n\nggplot(mpg, aes(displ, hwy, colour = drv)) + \n  geom_point() + \n  stat_chull(fill = NA)\n\n\n\n\n\n\n\n\n\n\n创建新统计时，通常是个好主意提供相应的 geom_*() 构造函数以及 stat_*() 构造函数，因为大多数用户习惯于使用 geoms 而不是统计来添加图表图层。我们将在 Section 4.3 中展示一个 geom_chull() 函数可能是什么样子。\n请注意，并不总是能够以有意义的方式定义 geom_*() 构造函数。当没有明显的默认 geom 用于新统计，或者统计旨在为现有的 geom/stat 对提供轻微修改时，这种情况就会发生。在这种情况下，可能明智的做法是只提供 stat_*() 函数。\n\n4.2.2 修改参数和数据\n在定义新统计时，通常需要指定 setup_params() 和/或 setup_data() 函数。这些函数在 compute_*() 函数之前被调用，它们允许统计响应并修改自身以响应参数和数据（特别是数据，在统计构造时不可用）：\n\nsetup_params() 函数首先被调用。它接受两个参数，分别对应于图层 data 和在构造期间指定的参数列表（params），并返回将在后续计算中使用的修改后的参数列表。由于参数由 compute_*() 函数使用，列表的元素应对应于 compute_*() 函数中的参数名称以便可用。\nsetup_data() 函数接下来被调用。它也接受 data 和 params 作为输入—尽管它接收的参数是 setup_params() 返回的修改后的参数—并返回修改后的图层数据。重要的是，无论在 setup_data() 中发生什么修改，PANEL 和 group 列都必须保持不变。\n\n以下示例展示了如何使用 setup_params() 方法定义新统计。修改 setup_data() 方法的示例稍后包含在 Section 4.3.2 中。假设我们想要创建 StatDensityCommon，一个统计，它在将数据分组后计算变量的密度估计，并估计应用于所有组的默认带宽。这可以通过许多不同的方式完成，但为了简单起见，我们假设我们有一个 common_bandwidth() 函数，它使用 bw.nrd0() 函数为每个组分别估计带宽，然后返回平均值：\n\ncommon_bandwidth &lt;- function(data) {\n  split_data &lt;- split(data$x, data$group)\n  bandwidth &lt;- mean(vapply(split_data, bw.nrd0, numeric(1)))\n  return(bandwidth)\n}\n\n我们希望 StatDensityCommon 使用 common_bandwith() 函数在数据被分组并传递给 compute_group() 函数之前设置一个共同的带宽。这是 setup_params() 方法的用途：\n\nStatDensityCommon &lt;- ggproto(\"StatDensityCommon\", Stat,\n  required_aes = \"x\",\n  \n  setup_params = function(data, params) {\n    if(is.null(params$bandwith)) {\n      params$bandwidth &lt;- common_bandwidth(data)\n      message(\"Picking bandwidth of \", signif(params$bandwidth, 3))\n    }\n    return(params)\n  },\n    \n  compute_group = function(data, scales, bandwidth = 1) {\n    d &lt;- density(data$x, bw = bandwidth)\n    return(data.frame(x = d$x, y = d$y))\n  }  \n)\n\n然后我们以通常的方式定义 stat_*() 函数：\n\nstat_density_common &lt;- function(mapping = NULL, data = NULL, \n                                geom = \"line\", position = \"identity\", \n                                na.rm = FALSE, show.legend = NA, \n                                inherit.aes = TRUE, bandwidth = NULL, ...) {\n  layer(\n    stat = StatDensityCommon, \n    data = data, \n    mapping = mapping, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      bandwidth = bandwidth, \n      na.rm = na.rm,\n      ...\n    )\n  )\n}\n\n现在我们可以应用我们的新统计：\n\nggplot(mpg, aes(displ, colour = drv)) + \n  stat_density_common()\n#&gt; Picking bandwidth of 0.345",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2拓展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-geoms",
    "href": "ggplot2extend.html#sec-new-geoms",
    "title": "3  编写ggplot2拓展",
    "section": "\n4.3 新 geoms",
    "text": "4.3 新 geoms\n虽然通过创建新统计可以实现许多事情，但在某些情况下创建新的 geom 是必要的。这些情况包括：\n\n从统计返回的数据以任何当前 geoms 可以理解的形式返回是没有意义的。\n图层需要组合多个 geoms 的输出。\ngeom 需要返回当前现有 geoms 不可用的 grobs。\n\n创建新的 geoms 可能比创建新的统计看起来稍微有些令人生畏，因为最终结果是一个 grobs 集合而不是一个修改后的数据框，这对许多开发人员来说是一个不熟悉的领域。尽管如此，除了上述最后一点，你还是可以尝试不需要考虑太多 grid 和 grobs。\n\n4.3.1 修改 geom 默认值\n在许多情况下，你的新 geom 可能只是一个期望稍微不同的输入或具有不同默认参数值的现有 geom。前一节中的 stat_chull() 示例是一个很好的例子。注意，在使用 stat_chull() 创建图表时，我们必须手动指定 fill 和 colour 参数，如果它们没有映射到美学上，这些是不适合我们的凸包 geom 的默认值。为了让我们的生活稍微容易一些，我们可以创建一个 GeomPolygon 的子类，修改默认值，以便它默认产生一个空心多边形。我们可以通过覆盖 default_aes 值以直接的方式做到这一点：\n\nGeomPolygonHollow &lt;- ggproto(\"GeomPolygonHollow\", GeomPolygon,\n  default_aes = aes(\n    colour = \"black\", \n    fill = NA, \n    linewidth = 0.5,\n    linetype = 1,\n    alpha = NA\n  )\n)\n\n我们现在可以使用 GeomPolygonHollow 作为默认 geom 来定义我们的 geom_chull() 构造函数：\n\ngeom_chull &lt;- function(mapping = NULL, data = NULL, stat = \"chull\",\n                       position = \"identity\", na.rm = FALSE, \n                       show.legend = NA, inherit.aes = TRUE, ...) {\n  layer(\n    geom = GeomPolygonHollow, \n    data = data, \n    mapping = mapping, \n    stat = stat, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes,\n    params = list(na.rm = na.rm, ...)\n  )\n} \n\n为了一致性，我们还会定义 stat_chull() 使用这个作为默认值。无论如何，我们现在有一个新的 geom_chull() 函数，它工作得很好，不需要用户设置参数：\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_chull() +\n  geom_point()\n\n\n\n\n\n\n\n\n4.3.2 修改 geom 数据\n在其他情况下，你可能想要定义一个 geom，它在视觉上等同于现有的 geom，但接受不同格式的数据。ggplot2 源代码中的一个示例是 geom_spoke()，这是 geom_segment() 的一个变体，它接受极坐标数据。为了使这工作，GeomSpoke ggproto 对象从 GeomSegment 子类化，并使用 setup_data() 方法来获取用户的极坐标数据，然后将其转换为 GeomSegment 期望的格式。为了说明这种技术，我们将创建 geom_spike()，一个 geom，它重新实现了 geom_spoke() 的功能。这需要我们重写 required_aes 字段以及 setup_data() 方法：\n\nGeomSpike &lt;- ggproto(\"GeomSpike\", GeomSegment,\n  \n  # 指定所需的美学                   \n  required_aes = c(\"x\", \"y\", \"angle\", \"radius\"),\n  \n  # 在任何绘图发生之前转换数据\n  setup_data = function(data, params) {\n    transform(data,\n      xend = x + cos(angle) * radius,\n      yend = y + sin(angle) * radius\n    )\n  }\n)\n\n我们现在编写面向用户的 geom_spike() 函数：\n\ngeom_spike &lt;- function(mapping = NULL, data = NULL, \n                       stat = \"identity\", position = \"identity\", \n                       ..., na.rm = FALSE, show.legend = NA, \n                       inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    geom = GeomSpike, \n    stat = stat, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n我们现在可以使用 geom_spike() 在图表中：\n\ndf &lt;- data.frame(\n  x = 1:10,\n  y = 0,\n  angle = seq(from = 0, to = 2 * pi, length.out = 10),\n  radius = seq(from = 0, to = 2, length.out = 10)\n)\nggplot(df, aes(x, y)) +\n  geom_spike(aes(angle = angle, radius = radius)) + \n  coord_equal()\n\n\n\n\n\n\n\n如统计一样，geoms 也有 setup_params() 方法以及 setup_data() 方法，可以用来在任何绘图发生之前修改参数（见 Section 4.2.2 示例）。然而，在 geom 上下文中，有一点需要注意的是，setup_data() 在任何位置调整之前被调用。\n\n4.3.3 组合多个 geoms\n定义新 geoms 的一个有用技术是组合不同 geoms 的功能。例如，geom_smooth() 函数用于绘制非参数回归线，它使用 geom_line() 的功能来绘制回归线，并使用 geom_ribbon() 来绘制阴影误差带。要在新 geom 中实现这一点，通常通过考虑绘图过程来完成。就像统计通过调用 compute_layer() 然后 compute_panel() 最后是 compute_group() 的分层序列工作一样，geom 通过调用 draw_layer()、draw_panel() 和 draw_group() 来构建。\n如果你想组合多个 geoms 的功能，它通常可以通过在 draw_*() 调用内准备每个 geom 的数据并将其发送到不同的 geoms 来实现，使用 grid::gList() 收集输出时需要一个 grobs 列表，或者如果需要一个带有多个子项的单个 grob，则使用 grid::gTree()。\n作为一个相对简单的例子，考虑 GeomBarbell ggproto 对象，它创建由条形连接的两个点的 geoms：\n\nGeomBarbell &lt;- ggproto(\"GeomBarbell\", Geom,\n  \n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  \n  default_aes = aes(\n    colour = \"black\",\n    linewidth = .5,\n    size = 2,\n    linetype = 1,\n    shape = 19,\n    fill = NA,\n    alpha = NA,\n    stroke = 1\n  ),\n  \n  draw_panel = function(data, panel_params, coord, ...) {\n    \n    # 点的转换数据\n    point1 &lt;- transform(data) \n    point2 &lt;- transform(data, x = xend, y = yend)    \n    \n    # 返回所有三个组件\n    grid::gList(\n      GeomSegment$draw_panel(data, panel_params, coord, ...),\n      GeomPoint$draw_panel(point1, panel_params, coord, ...),\n      GeomPoint$draw_panel(point2, panel_params, coord, ...)\n    )\n  }\n) \n\n在这个例子中，draw_panel() 方法返回一个三个 grobs 的列表，一个来自 GeomSegment，两个来自 GeomPoint。像往常一样，如果我们希望 geom 对用户可见，我们添加一个包装器函数：\n\ngeom_barbell &lt;- function(mapping = NULL, data = NULL, \n                         stat = \"identity\", position = \"identity\", \n                         ..., na.rm = FALSE, show.legend = NA, \n                         inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomBarbell, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n我们现在可以使用组合 geom：\ndf &lt;- data.frame(x = 1:10, xend = 0:9, y = 0, yend = 1:10)\nbase &lt;- ggplot(df, aes(x, y, xend = xend, yend = yend))\n\nbase + geom_barbell()\nbase + geom_barbell(shape = 4, linetype = \"dashed\")  \n\n\n\n\n\n\n\n\n\n\n如果你不能利用任何现有的 geom 实现来创建 grobs，那么你将不得不从头开始实现完整的 draw_*() 方法，这需要对 grid 包有一点了解。有关 grid 的更多信息以及使用它来从网格原语构建 geom 的示例，请参见 Chapter 4。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2拓展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-coords",
    "href": "ggplot2extend.html#sec-new-coords",
    "title": "3  编写ggplot2拓展",
    "section": "\n4.4 新坐标",
    "text": "4.4 新坐标\n坐标的主要 作用是将位置美学重新缩放到 [0, 1] 范围，并在此过程中对其进行转换。定义新坐标相对罕见：在 ?sec-coord 中描述的坐标适用于大多数非制图案例，并且随着 coord_sf() 的引入，在 ?sec-maps 中讨论，ggplot2 能够开箱即用地捕获大多数制图投影。\n开发人员可能需要了解坐标系统内部的最常见情况是定义新的 geoms。坐标的 draw_*() 方法之一调用坐标的 transform() 方法并不少见。例如，CoordCartesian 的 transform() 方法用于重新缩放位置数据，但不会以其他方式转换它，geom 可能需要应用此重新缩放以正确绘制 grob。一个示例出现在 Chapter 4 中。\n除了转换位置数据外，坐标还负责渲染轴、轴标签、面板前景和面板背景。此外，坐标可以截获并修改图层数据和分面布局。如果绝对必要，大部分这些功能都可供开发人员使用（一个示例显示在 Section 4.1.3 中），但在大多数情况下，最好保留这些功能不变。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2拓展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-scales",
    "href": "ggplot2extend.html#sec-new-scales",
    "title": "3  编写ggplot2拓展",
    "section": "\n4.5 新比例尺",
    "text": "4.5 新比例尺\n有三种方式可能想要通过新比例尺扩展 ggplot2。最简单的情况是，当你想要为新调色板提供一个方便的包装器时，通常用于颜色或填充美学。作为一个不切实际的例子，假设你想使用像这样的调色板函数来填充小提琴或箱形图的随机颜色：\n\nrandom_colours &lt;- function(n) {\n  sample(colours(distinct = TRUE), n, replace = TRUE)\n} \n\n然后我们可以编写一个 scale_fill_random() 构造函数，将调色板传递给 discrete_scale()，然后在图表中使用它：\n\nscale_fill_random &lt;- function(..., aesthetics = \"fill\") {\n  discrete_scale(\n    aesthetics = aesthetics, \n    scale_name = \"random\", \n    palette = random_colours\n  )\n}\n\nggplot(mpg, aes(hwy, class, fill = class)) + \n  geom_violin(show.legend = FALSE) +\n  scale_fill_random()\n#&gt; Warning: The `scale_name` argument of `discrete_scale()` is deprecated as of ggplot2\n#&gt; 3.5.0.\n\n\n\n\n\n\n\n另一个相对简单的案例是，你提供了一个 geom，它采用新的美学类型，需要进行缩放。假设你创建了一个新的线 geom，并且你决定使用 width 美学而不是 size 美学。为了使 width 像你对 size 的缩放那样进行缩放，你必须为美学提供一个默认比例尺。默认比例尺是根据其名称和提供给美学的数据类型来找到的。如果你将连续值分配给 width 美学，ggplot2 将寻找 scale_width_continuous() 函数，并使用它如果没有添加其他宽度比例尺的话。如果找不到这样的函数（并且没有明确添加宽度比例尺），美学将不会被缩放。\n还有一个值得提及的可能性，但超出了这本书的范围，那就是创建一个新的主要比例尺类型。历史上，ggplot2 有两种主要的比例尺类型，连续和离散。最近，分箱比例尺加入其中，它允许将连续数据分箱为离散箱。可以开发进一步的主要比例尺类型，方法是子类化 Scale 或提供的主要比例尺之一，并创建新的 train() 和 map() 方法等。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2拓展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新位置",
    "href": "ggplot2extend.html#新位置",
    "title": "3  编写ggplot2拓展",
    "section": "\n4.6 新位置",
    "text": "4.6 新位置\nPosition ggproto 类比其他 ggproto 类要简单一些，反映了 position_*() 函数的非常狭窄的范围。位置的作用是在数据立即传递给任何绘图函数之前接收和修改数据。严格来说，位置可以以任何方式修改数据，但有一个隐含的期望，即它只修改位置美学。位置具有 compute_layer() 和 compute_panel() 方法，这些方法类似于统计的等效方法，但它没有 compute_group() 方法。它还包含 setup_params() 和 setup_data() 方法，这些方法类似于其他 ggproto 类的 setup_*() 方法，有一个值得注意的例外：setup_params() 方法只接收数据作为输入，而不是参数列表。原因是 position_*() 函数从不在 ggplot2 中单独使用：相反，它们总是在指定图层的主 geom_*() 或 stat_*() 命令中调用，主命令中的参数不会传递给 position_*() 函数调用。\n为了提供一个简单的例子，我们将实现一个稍微简化版的 position_jitternormal() 函数，它来自 ggforce 包，其行为与 position_jitter() 相同，只不过扰动是从正态分布而不是均匀分布中采样的。为了保持论述简单，我们假设我们有以下便利函数定义：\n\nnormal_transformer &lt;- function(x, sd) {\n  function(x) {x + rnorm(length(x), sd = sd)}\n}\n\n当被调用时，normal_transformer() 返回一个函数，通过添加均值为零、标准差为 sd 的随机噪声来扰动输入向量。创建我们的新位置的第一步是制作一个 Position 对象的子类：\n\nPositionJitterNormal &lt;- ggproto('PositionJitterNormal', Position,\n           \n  # 我们需要一个 x 和 y 位置美学                              \n  required_aes = c('x', 'y'),\n  \n  # 通过使用 \"self\" 参数，我们可以访问用户传递给位置的参数，并将它们添加为图层参数\n  setup_params = function(self, data) {\n    list(\n      sd_x = self$sd_x, \n      sd_y = self$sd_y\n    )\n  },\n\n  # 当计算图层时，我们可以从参数列表中读取标准差参数，并使用它们来转换位置美学\n  compute_layer = function(data, params, panel) {\n    \n    # 为 x 和 y 位置尺度构建变换器 \n    x_transformer &lt;- normal_transformer(x, params$sd_x)\n    y_transformer &lt;- normal_transformer(y, params$sd_y)\n    \n    # 返回转换后的数据\n    transform_position(\n      df = data,\n      trans_x = x_transformer,  \n      trans_y = y_transformer\n    )\n  }\n)\n\ncompute_layer() 方法使用了 transform_position()，这是 ggplot2 提供的一个便利函数，其作用是将用户供应的函数应用于与相关位置尺度相关联的所有美学（例如，不仅仅是 x 和 y，还有 xend 和 yend）。\n在现实的实现中，position_jitternormal() 构造函数将进行一些输入验证，以确保用户没有指定负的标准差，但在这个上下文中我们将保持简单：\n\nposition_jitternormal &lt;- function(sd_x = .15, sd_y = .15) {\n  ggproto(NULL, PositionJitterNormal, sd_x = sd_x, sd_y = sd_y)\n}\n\n我们现在可以在创建图表时使用我们的新位置函数。要查看 position_jitter() 和我们刚刚定义的 position_jitternormal() 函数之间的区别，请比较以下图表：\ndf &lt;- data.frame(\n  x = sample(1:3, 1500, TRUE),\n  y = sample(1:3, 1500, TRUE)\n)\n\nggplot(df, aes(x, y)) + geom_point(position = position_jitter())\nggplot(df, aes(x, y)) + geom_point(position = position_jitternormal())\n\n\n\n\n\n\n\n\n\n\n在设计新位置时需要考虑的一个实际问题是，用户很少直接调用位置构造函数。指定图层的命令更可能是像 position = \"dodge\" 而不是 position = position_dodge()，更不用说覆盖你的默认值了，就像用户指定 position = position_dodge(width = 0.9) 那样。因此，如果可能的话，重要的是要仔细思考并使默认值适用于大多数情况。这可能非常棘手：位置对图层数据的形状和格式几乎没有控制权，但用户将期望它们在所有情况下都可预测地行为。一个例子是躲避，用户可能想要躲避箱形图和点云，并期望点云出现在其相应的箱形图的相同区域。在用户层面上，这是一个完全合理的期望，但对开发人员来说可能很棘手。箱形图有一个明确的宽度，可以用来控制躲避，而点则不是这样，但用户期望它们以相同的方式移动。这种考虑通常意味着位置实现最终比最简单的解决方案要复杂得多，以照顾到广泛的边缘情况。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2拓展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新分面",
    "href": "ggplot2extend.html#新分面",
    "title": "3  编写ggplot2拓展",
    "section": "\n4.7 新分面",
    "text": "4.7 新分面\n分面是 ggplot2 中最强大的概念之一，扩展分面是修改 ggplot2 操作方式的最强大的方式之一。这种力量是有代价的：分面负责接收所有面板，将轴和条带附加到它们上，然后以预期的方式排列它们。从头开始创建一个全新的分面系统需要深入了解 grid 和 gtable，可能是一个令人生畏的挑战。幸运的是，你并不总是需要从头开始创建分面。例如，如果你的新分面将产生位于网格上的面板，你通常可以子类化 FacetWrap 或 FacetGrid 并修改一个或两个方法。特别是，你可能想要定义新的 compute_layout() 和/或 map_data() 方法：\n\ncompute_layout() 方法接收原始数据集，并创建布局规范，这是一个数据框，每行代表面板在网格上的位置，以及哪些轴限制应该是自由的，哪些应该是固定的。\nmap_data() 方法接收这个布局规范和原始数据作为输入，并将 PANEL 列 附加到它上面，用于将数据框中的每一行分配给布局中的一个面板。\n\n为了说明如何通过子类化现有分面来创建新分面，我们将创建一个相对简单的分面系统，该系统将“散布”面板，将它们随机放置在网格上。为此，我们将创建一个名为 FacetScatter 的新 ggproto 对象，它是 FacetWrap 的子类，并编写一个新的 compute_layout() 方法，将每个面板放置在面板网格中随机选择的单元格中：\n\nFacetScatter &lt;- ggproto(\"FacetScatter\", FacetWrap,\n  \n  # 这并不重要的例子：我们所做的一切是\n  # 强制所有面板使用固定尺度，以便\n  # 其余的例子可以保持简单\n  setup_params = function(data, params) {\n    params &lt;- FacetWrap$setup_params(data, params)\n    params$free &lt;- list(x = FALSE, y = FALSE)\n    return(params)\n  },                      \n  \n  # compute_layout() 方法做工作\n  compute_layout = function(data, params) {\n                  \n    # 创建一个数据框，每个分面变量一列，\n    # 每一行代表一个可能的值组合\n    # （即，每一行一个面板）\n    panels &lt;- combine_vars(\n      data = data,\n      env = params$plot_env, \n      vars = params$facets, \n      drop = FALSE\n    )\n    \n    # 创建一个数据框，ROW 和 COL 列，\n    # 每一行代表面板网格中可能的单元格\n    locations &lt;- expand.grid(ROW = 1:params$nrow, COL = 1:params$ncol)\n    \n    # 随机抽样位置的子集\n    shuffle &lt;- sample(nrow(locations), nrow(panels))\n    \n    # 为每个面板分配一个位置                      \n    layout &lt;- data.frame(\n      PANEL = 1:nrow(panels),       # 面板标识符\n      ROW = locations$ROW[shuffle], # 面板的行号\n      COL = locations$COL[shuffle], # 面板的列号\n      SCALE_X = 1L,                 # 所有 x 轴尺度都是固定的\n      SCALE_Y = 1L                  # 所有 y 轴尺度都是固定的\n    )\n    \n    # 将布局信息与面板标识符绑定\n    # 并返回得到的规范\n    return(cbind(layout, panels))\n  }                      \n)\n\n为了让你对这个输出的样子有一个感觉，这是在构建本节末尾显示的图表时创建的布局规范：\n\n#&gt;    PANEL ROW COL SCALE_X SCALE_Y manufacturer\n#&gt; 1      1   4   1       1       1         audi\n#&gt; 2      2   5   5       1       1    chevrolet\n#&gt; 3      3   5   1       1       1        dodge\n#&gt; 4      4   5   3       1       1         ford\n#&gt; 5      5   1   5       1       1        honda\n#&gt; 6      6   4   4       1       1      hyundai\n#&gt; 7      7   3   5       1       1         jeep\n#&gt; 8      8   2   2       1       1   land rover\n#&gt; 9      9   5   2       1       1      lincoln\n#&gt; 10    10   4   5       1       1      mercury\n#&gt; 11    11   2   4       1       1       nissan\n#&gt; 12    12   5   4       1       1      pontiac\n#&gt; 13    13   3   2       1       1       subaru\n#&gt; 14    14   5   6       1       1       toyota\n#&gt; 15    15   4   6       1       1   volkswagen\n\n接下来，我们将编写 facet_scatter() 构造函数，以将此功能暴露给用户。对于分面来说，这就像创建一个新的相关 ggproto 对象（在这种情况下是 FacetScatter）的实例一样简单，它将用户指定的参数传递给分面：\n\nfacet_scatter &lt;- function(facets, nrow, ncol, \n                          strip.position = \"top\", \n                          labeller = \"label_value\") {\n  \n  ggproto(NULL, FacetScatter, \n    params = list(\n      facets = rlang::quos_auto_name(facets),\n      strip.position = strip.position,\n      labeller = labeller, \n      ncol = ncol, \n      nrow = nrow\n    )\n  )\n}\n\n关于这个构造函数有几个注意事项。首先，为了保持示例简单，facet_scatter() 包含的参数比 facet_wrap() 少，我们将 nrow 和 ncol 作为必需参数：用户需要指定面板应该散布的网格的大小。其次，facet_scatter() 函数要求你使用 vars() 指定分面。如果用户尝试提供公式，它将不起作用。相关地，请注意使用 rlang::quos_auto_name()：vars() 函数返回一个未命名的表达式列表（技术上，quosures），但下游代码需要一个命名列表。只要你期望用户使用 vars()，这就是你需要的所有预处理，但如果你想支持其他输入格式，你需要更花哨一些（你可以通过查看 ggplot2 源代码来看如何做到这一点）。\n无论如何，我们现在有一个工作分面：\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  facet_scatter(vars(manufacturer), nrow = 5, ncol = 6)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2拓展</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html",
    "href": "ggplot2_spring1.html",
    "title": "4  一个学习案例",
    "section": "",
    "text": "5 A case study\nChapter 4 提供了创建 ggplot2 扩展的高级概述，基于 ?sec-internals 中对 ggplot2 内部结构的讨论。在这一章中，我们将更深入地探讨开发全功能扩展的过程。为此，我们将以一个示例为例——构建一个新的看起来像弹簧的 geom ——并跟随其整个开发过程。\n这是一个精心设计的示例。您可能实际上并不需要使用弹簧来可视化您的数据，因此 ggplot2 尚未提供弹簧 geom。然而，弹簧足够复杂，可以说明过程中最重要的部分。这使它们成为我们目的的理想选择！\n我们将分五个阶段开发这个扩展：\n一旦您完成了这一章的工作，我们强烈建议您浏览 ggplot2 源代码，看看其他 stats 和 geoms 是如何实现的。它们通常会比您需要的更复杂，但它们会给您一个您可以做的事情的感觉。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html#sec-intuitive-spring",
    "href": "ggplot2_spring1.html#sec-intuitive-spring",
    "title": "4  一个学习案例",
    "section": "\n5.1 什么是弹簧？",
    "text": "5.1 什么是弹簧？\n开发扩展通常从想要绘制的东西的想法开始。在这种情况下，我们想要在两个点之间绘制一个弹簧，所以我们需要一些代码来绘制一个看似合理的弹簧！可能有很多方法可以做到这一点，但一个简单的方法是在移动“笔”时绘制一个圆。以下是一个使用 100 个点定义圆的数据集：\n\ncircle &lt;- tibble(\n  radians = seq(0, 2 * pi, length.out = 100),\n  x = cos(radians),\n  y = sin(radians),\n  index = 1:100,\n  type = \"circle\"\n)\n\nggplot(circle, aes(x = x, y = y, alpha = -index)) + \n  geom_path(show.legend = FALSE) + \n  coord_equal()\n\n\n\n\n\n\n\n要使用 dplyr 将这个圆变成沿 x 轴延伸的弹簧，我们可能会这样做：\n\nspring &lt;- circle %&gt;% \n  mutate(\n    motion = seq(0, 1, length.out = 100),\n    x = x + motion,\n    type = \"spring\"\n  )\n\nggplot(spring, aes(x = x, y = y, alpha = -index)) + \n  geom_path(show.legend = FALSE) + \n  coord_equal()\n\n\n\n\n\n\n\n在这种情况下，我们的“弹簧”只循环了一次 —— 看起来并不像一个真正的弹簧 —— 但如果我们继续在移动 x 轴的同时描绘圆圈，我们最终会得到一个有多个循环的弹簧。我们移动“笔”的速度越快，弹簧就会越伸展。这让我们对两个特征弹簧的参数有了一定的了解：\n\n弹簧的 diameter，由圆的大小定义。\n弹簧的 tension，由我们沿 x 移动的速度定义。\n\n尽管这可能不是现实世界中弹簧的物理正确参数化，但这对我们的目的来说已经足够好了。\n现在我们已经找到了绘制弹簧的方法，值得花点时间思考基于这种方法的 geom 将需要什么。我们到目前为止编写的代码对于单一图表来说是完全可以的，但在创建扩展时有新的问题需要考虑：\n\n我们将如何指定弹簧的直径？\n即使我们在改变图表的纵横比时，我们如何保持圆圈的圆形？\n我们可以将直径和张力映射到数据中的变量吗？\n直径和张力应该是所有弹簧在一层中必须相同的参数，还是它们应该是可以从一个弹簧变化到另一个弹簧的缩放美学？\n如果我们计划将我们的弹簧 geom 分发给其他 R 用户，我们是否希望依赖于 dplyr 包？\n\n我们将在本章的工作中考虑这些问题。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html#sec-spring-stat",
    "href": "ggplot2_spring1.html#sec-spring-stat",
    "title": "4  一个学习案例",
    "section": "\n5.2 第一部分：一个统计",
    "text": "5.2 第一部分：一个统计\n让我们开始将这个想法转化为 ggplot2 扩展。因为我们正在创建一个绘制新 ggplot2 层的扩展，所以我们需要决定我们创建的 ggproto 对象应该是一个 Stat 还是一个 Geom。也许令人惊讶的是，这个决定不是由我们是否想要最终得到 geom_spring() 或 stat_spring() 来指导的：有很多 Stat 扩展是通过 geom_*() 构造函数使用的。一个更好的思考这个决定的方式是考虑我们是否可以使用现有 geom 与转换后的数据。如果是这样的话，我们可以使用一个 Stat，它通常比编码一个 Geom 更简单。\n我们在上一节中编写的代码非常适合这种描述。我们所做的一切都是绘制一条路径，但我们是在绕圈子而不是走直线。这表明我们可以使用一个 Stat，它转换数据，然后使用 GeomPath 来处理实际的绘图。\n\n5.2.1 构建功能\n每当您开发一个新的 Stat 时，一个合理的策略是先编写数据转换函数，然后一旦它工作了，就将其纳入 ggproto Stat。在这种情况下，我们需要一个 create_spring() 函数，它接受一个起点，一个终点，一个直径和一个张力。更精确地说：\n\n我们的起点由参数 x 和 y 定义。\n我们的终点由参数 xend 和 yend 定义。\n\ndiameter 参数用于缩放我们的圆的大小。\n定义 tension 有点棘手。我们实际上想要表达的数量是“弹簧移动的距离相对于圆圈的大小”。因此，我们将 tension 定义为从起点到终点移动的总距离除以圆圈的大小。1\n\n我们还有一个参数 n，用于定义每次革命的点数，定义弹簧的视觉保真度。\n\n我们现在可以为我们的 create_spring() 函数编写代码：\n\ncreate_spring &lt;- function(x, \n                          y, \n                          xend, \n                          yend, \n                          diameter = 1, \n                          tension = 0.75, \n                          n = 50) {\n  \n  # 验证输入参数\n  if (tension &lt;= 0) {\n    rlang::abort(\"`tension` 必须大于零。\")\n  }\n  if (diameter == 0) {\n    rlang::abort(\"`diameter` 不能为零。\")\n  }\n  if (n == 0) {\n    rlang::abort(\"`n` 必须大于零。\")\n  }\n  \n  # 计算弹簧路径的直接长度\n  length &lt;- sqrt((x - xend)^2 + (y - yend)^2)\n  \n  # 计算我们需要的革命次数和点数\n  n_revolutions &lt;- length / (diameter * tension)\n  n_points &lt;- n * n_revolutions\n  \n  # 计算弧度序列和 x 和 y 偏移值\n  radians &lt;- seq(0, n_revolutions * 2 * pi, length.out = n_points)\n  x &lt;- seq(x, xend, length.out = n_points)\n  y &lt;- seq(y, yend, length.out = n_points)\n  \n  # 创建并返回转换后的数据框\n  data.frame(\n    x = cos(radians) * diameter/2 + x,\n    y = sin(radians) * diameter/2 + y\n  )\n}\n\n这个函数保留了我们在 Section 5.1 中编写的弹簧代码的逻辑，但它做了一些新的事情，这些事情在编写扩展时非常重要：\n\n它精确地指定了定义弹簧的参数。\n它显式检查输入，并使用 rlang::abort() 在用户向函数传递无效值时抛出错误。\n它使用基础 R 函数来完成工作：这个函数中没有 dplyr 代码，因为我们不希望我们的 Stat 依赖于 dplyr。2\n\n\n编写 create_spring() 作为一个函数的一个好处是，我们可以测试它3来说服自己逻辑是正确的：\n\nspring &lt;- create_spring(\n  x = 4, y\n = 2, xend = 10, yend = 6,\n  diameter = 2, tension = 0.6, n = 50\n)\n\nggplot(spring) + \n  geom_path(aes(x = x, y = y)) + \n  coord_equal()\n\n\n\n\n\n\n\n\n5.2.2 创建统计\n现在我们已经拥有了转换函数，下一个任务是将其封装到一个 Stat 中。要做到这一点，我们将利用我们在 Section 4.2 中学到的关于创建 Stat 对象的知识，并稍作扩展。我们的第一步是编写一些代码来创建一个名为 StatSpring 的 Stat 子类：\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat)\n\n这创建了一个新的 Stat 子类名为 StatSpring。 这个类目前还没有什么有趣的：这段代码到目前为止所做的唯一事情就是给类一个名字。4 要使其有用，我们需要指定将构建我们所需功能的方法。 在 Section 4.2 中我们通过覆盖默认方法 compute_group() 和默认字段 required_aes 创建了一个 Stat，5 但 Stat 对象有许多属性您可以修改。 如果您打印 Stat 对象，您可以看到这些属性的列表：\n\nStat\n#&gt; &lt;ggproto object: Class Stat, gg&gt;\n#&gt;     aesthetics: function\n#&gt;     compute_group: function\n#&gt;     compute_layer: function\n#&gt;     compute_panel: function\n#&gt;     default_aes: uneval\n#&gt;     dropped_aes: \n#&gt;     extra_params: na.rm\n#&gt;     finish_layer: function\n#&gt;     non_missing_aes: \n#&gt;     optional_aes: \n#&gt;     parameters: function\n#&gt;     required_aes: \n#&gt;     retransform: TRUE\n#&gt;     setup_data: function\n#&gt;     setup_params: function\n\n您可以修改几乎所有这些：您不应该触摸的唯一一个是 aesthetics 和 parameters，它们是内部使用。\n对于我们的 StatSpring 示例，我们将需要指定的三个方法/字段是 setup_data()，compute_panel() 和 required_aes。 我们将在下一节中更详细地讨论这一点，但为了帮助您看到我们的目标，这里是我们统计的完整代码：\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat, \n  \n  # 编辑输入数据以确保组标识符是唯一的\n  setup_data = function(data, params) {\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  # 通过调用 create_spring() 构建此面板的数据\n  compute_panel = function(data, \n                           scales, \n                           diameter = 1, \n                           tension = 0.75, \n                           n = 50) {\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(\n      seq_len(nrow(data)), \n      function(i) {\n        spring_path &lt;- create_spring(\n          data$x[i], \n          data$y[i], \n          data$xend[i], \n          data$yend[i], \n          diameter = diameter, \n          tension = tension, \n          n = n\n        )\n        cbind(spring_path, unclass(data[i, cols_to_keep]))\n      }\n    )\n    do.call(rbind, springs)\n  },\n  \n  # 指定所需的美学\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\")\n)\n\n我们可以用命令如 StatSpring$compute_panel 或 StatSpring$setup_data 打印这些方法。\n\n5.2.3 方法\n让我们仔细看看为我们的 StatSpring 定义的方法。正如在 Section 4.2 中讨论的，统计最重要的方法是三个 compute_* 方法。 这些方法中必须定义一个，通常是 compute_group() 或 compute_panel()。 作为一个经验法则，如果统计操作在多行上，我们首先实现一个 compute_group() 方法，如果统计操作在单行上，我们实现一个 compute_panel() 方法。 我们的弹簧统计是后一种类型：每个弹簧由原始数据的一行定义，所以我们将使用 compute_panel() 方法，它接收单个面板的所有数据。\n通过查看我们的 compute_panel() 方法的源代码，您可以看到我们不仅仅是简单地调用我们的 create_spring() 函数：\n\nfunction(data, scales, diameter = 1, tension = 0.75, n = 50) {\n  cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n  springs &lt;- lapply(\n    seq_len(nrow(data)), \n    function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        diameter = diameter, \n        tension = tension, \n        n = n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    }\n  )\n  do.call(rbind, springs)\n}\n\n我们使用 lapply() 循环遍历数据的每一行，并创建绘制相应弹簧所需的点。 对于每个这样的弹簧，我们使用 cbind() 将弹簧数据与输入行的非位置列结合起来。 这非常重要，否则美学映射（例如颜色和大小）将会丢失。 最后，因为 lapply() 的输出是一个数据框列表（每个弹簧一个），我们使用 rbind() 将这些组合成一个单独的数据框以返回。\n在定义一个新的统计时，通常需要指定一个或两个 setup_data() 和 setup_params() 方法。 这些方法在绘图构建过程的最开始被调用，因此您可以使用它们来提前检查和修改参数和数据。\n对于我们的 StatSpring 示例，我们使用 setup_data() 方法来确保每个输入行都有一个唯一的组美学。 这很重要，因为我们将使用 GeomPath 绘制我们的弹簧，我们需要确保统计输出的数据框有一个唯一的标识符用于每个弹簧。 这样做确保 geom 将每个弹簧作为一条独立路径绘制，而不会在不同的弹簧之间绘制任何连接线。 同样，实现中有一些微妙的细节需要注意：\n\nfunction(data, params) {\n  if (anyDuplicated(data$group)) {\n    data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n  }\n  data\n}\n\n请注意，这个实现保留了 data$group 的原始值，如果需要的话，追加一个唯一 id。 这很重要，因为组美学有时用于携带元数据，我们不想丢失这些信息。\n我们新类的最后一部分是 required_aes 字段。 这是一个字符向量，给出了用户 必须 提供给统计的美学名称。 在这种情况下，我们需要确保用户提供了四个位置美学：x 和 y 定义弹簧的起始位置，而 xend 和 yend 定义其结束位置。 required_aes 字段，连同 default_aes 和 non_missing_aes，也定义了这个统计理解的美学。 任何没有出现在这些字段中（或相应 geom 的字段中）的美学将生成一个警告，并且映射将被忽略。\n\n5.2.4 构造函数\n现在我们已经拥有了 StatSpring ggproto 对象，是时候编写用户将与之交互的构造函数了。 严格来说，我们不需要这样做，因为 geom_path(stat = \"spring\") 已经可以工作了，但编写构造函数对于用户的便利是好的做法。 此外，构造函数是记录新功能的良好场所。\n也许令人惊讶的是，统计对象几乎总是与 geom_*() 构造函数配对，因为大多数 ggplot2 用户习惯于在构建绘图时添加 geoms，而不是 stats。 构造函数本身主要是样板代码，它包装了对 layer() 的调用；只是要注意匹配 ggplot2 的构造函数中使用的参数顺序和命名，以免让您的用户感到惊讶。\n\ngeom_spring &lt;- function(mapping = NULL,\n                        data = NULL, \n                        stat = \"spring\",\n                        position = \"identity\", \n                        ..., \n                        diameter = 1, \n                        tension = 0.75,\n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\",\n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE\n                        ) {\n  layer(\n    data = data,\n    mapping = mapping,\n    stat = stat,\n    geom = GeomPath,\n    position = position,\n    show.legend = show.legend,\n    inherit.aes = inherit.aes,\n    params = list(\n      diameter = diameter,\n      tension = tension,\n      n = n,\n      arrow = arrow,\n      lineend = lineend,\n      linejoin = linejoin,\n      na.rm = na.rm,\n      ...\n    )\n  )\n}\n\n为了完整性，您还应该创建一个 stat_*() 构造函数。 这里没有任何惊喜：stat_spring() 非常类似于 geom_spring() 除了它提供了一个默认 geom 而不是一个默认 stat。\n\nstat_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        geom = \"path\", \n                        position = \"identity\", \n                        ..., \n                        diameter = 1, \n                        tension = 0.75, \n                        n = 50, \n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = StatSpring, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      diameter = diameter, \n      tension = tension, \n      n = n, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\n\n5.2.5 测试统计\n现在一切都就绪了，我们可以测试我们的新层：\n\ndf &lt;- tibble(\n  x = runif(5, max = 10),\n  y = runif(5, max = 10),\n  xend = runif(5, max = 10),\n  yend = runif(5, max = 10),\n  class = sample(letters[1:2], 5, replace = TRUE)\n)\n\nggplot(df) + \n  geom_spring(aes(x = x, y = y, xend = xend, yend = yend)) +\n  coord_equal()\n\n\n\n\n\n\n\n这看起来相当不错。 用户可以调用我们的 geom_spring() 构造函数并获得合理的结果。 更好的是，因为我们已经编写了一个新的统计，我们免费获得了一些功能，如缩放和分面：\n\nggplot(df) + \n  geom_spring(\n    aes(x, y, xend = xend, yend = yend, colour = class),\n    linewidth = 1\n  ) +\n  coord_equal() + \n  facet_wrap(~ class)\n\n\n\n\n\n\n\n用户还可以选择调用 stat_spring() 构造函数，这在某些原因下他们想要用点而不是路径来绘制弹簧时很有帮助：\n\nggplot(df) + \n  stat_spring(\n    aes(x, y, xend = xend, yend = yend, colour = class),\n    geom = \"point\", \n    n = 15\n  ) +\n  coord_equal() + \n  facet_wrap(~ class)\n\n\n\n\n\n\n\n\n5.2.6 事后分析\n现在我们已经成功地创建了我们的第一个扩展。 它有效，但它有一些限制，我们现在需要考虑。\n我们实现的一个缺点是直径和张力是常数，只能为整个层设置。 这些设置更像是美学，并且如果它们的值可以映射到数据中的变量就好了。 我们将在 Section 5.3 和 Section 5.4 中讨论解决这个问题的方法。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html#sec-spring2",
    "href": "ggplot2_spring1.html#sec-spring2",
    "title": "4  一个学习案例",
    "section": "\n5.3 第二部分：添加美学",
    "text": "5.3 第二部分：添加美学\n我们在上一节中创建的统计将 diameter 和 tension 视为常数参数：它们不是美学，用户不能将它们映射到数据中的变量。 我们可以通过对 StatSpring 代码进行一些小改动来解决这个问题：\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat,\n                      \n  setup_data = function(data, params) {\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  compute_panel = function(data, scales, n = 50) {\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(seq_len(nrow(data)), function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        data$diameter[i],\n        data$tension[i], \n        n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    })\n    do.call(rbind, springs)\n  },\n  \n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  optional_aes = c(\"diameter\", \"tension\")\n)\n\n与我们之前的尝试的主要区别是 compute_panel() 的 diameter 和 tension 参数已经消失，现在它们来自数据（就像 x, y 等）。 这有一个缺点，我们将在 Section 5.4 中修复：我们不能再设置固定美学了。 因此，我们需要从构造函数中移除这些参数：\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"spring\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        na.rm = FALSE,\n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomPath, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\nstat_spring() 构造函数将需要相同的更改。\n所有剩下的就是测试我们的新实现：\n\ndf &lt;- tibble(\n  x = runif(5, max = 10),\n  y = runif(5, max = 10),\n  xend = runif(5, max = 10),\n  yend = runif(5, max = 10),\n  class = sample(letters[1:2], 5, replace = TRUE),\n  tension = runif(5),\n  diameter = runif(5, 0.5, 1.5)\n)\n\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(aes(tension = tension, diameter = diameter))\n\n\n\n\n\n\n\n它看起来有效。 然而，正如我们所预期的，不再可以设置 diameter 和 tension 作为参数了：\n\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(diameter = 0.5)\n#&gt; Warning in geom_spring(diameter = 0.5): Ignoring unknown parameters: `diameter`\n#&gt; Warning: Computation failed in `stat_spring()`.\n#&gt; Caused by error in `if (tension &lt;= 0) ...`:\n#&gt; ! argument is of length zero\n\n\n\n\n\n\n\n\n5.3.1 事后分析\n在这一节中，我们进一步开发了我们的弹簧统计，使得 diameter 和 tension 可以作为美学使用，从而在弹簧之间变化。 不幸的是，有一个主要缺点：这些功能不再可以全局设置。 我们还缺少一种控制这两种美学的缩放方法。 修复这两个问题需要相同的下一步：将我们的实现从 Stat 移向一个适当的 Geom。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html#sec-spring3",
    "href": "ggplot2_spring1.html#sec-spring3",
    "title": "4  一个学习案例",
    "section": "\n5.4 第三部分：一个 geom",
    "text": "5.4 第三部分：一个 geom\n在许多情况下，以统计为中心的方法是足够的，例如，ggforce 包提供的许多图形原语是统计。 但是，我们需要用弹簧 geom 进一步发展，因为 tension 和 diameter 美学需要以与坐标系无关的单位来指定。 因此，我们将重写我们的 geom 为一个适当的 Geom 扩展。\n\n5.4.1 Geom 扩展\n如在 Chapter 4 中所讨论的，Stat 和 Geom 扩展之间有许多相似之处。 最大的区别是 Stat 扩展返回修改后的输入数据版本，而 Geom 扩展返回图形对象。 在某些情况下创建一个新的 geom 需要您使用 grid 包（我们将在 Section 5.6 中介绍），但通常您不需要。\n就像统计对象一样，ggproto 中的 geom 对象有几个方法和字段您可以修改。 您可以通过打印对象来看到列表：\n\nGeom\n#&gt; &lt;ggproto object: Class Geom, gg&gt;\n#&gt;     aesthetics: function\n#&gt;     default_aes: uneval\n#&gt;     draw_group: function\n#&gt;     draw_key: function\n#&gt;     draw_layer: function\n#&gt;     draw_panel: function\n#&gt;     extra_params: na.rm\n#&gt;     handle_na: function\n#&gt;     non_missing_aes: \n#&gt;     optional_aes: \n#&gt;     parameters: function\n#&gt;     rename_size: FALSE\n#&gt;     required_aes: \n#&gt;     setup_data: function\n#&gt;     setup_params: function\n#&gt;     use_defaults: function\n\n\n5.4.2 创建 geom\n就像统计使用 compute_layer()，compute_panel() 和 compute_group() 方法来转换数据一样，geom 使用 draw_layer()，draw_panel() 和 draw_group() 来创建数据的图形表示。 就像我们通过编写 compute_panel() 方法来创建 StatSpring 一样，我们将通过编写 draw_panel() 方法来创建 GeomSpring：\n\nGeomSpring &lt;- ggproto(\"GeomSpring\", Geom,\n  \n  # 确保每一行都有一个唯一的组 id\n  setup_data = function(data, params) {\n    if (is.null(data$group)) {\n      data$group &lt;- seq_len(nrow(data))\n    }\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  # 在 draw_panel() 方法中转换数据\n\n  draw_panel = function(data, \n                        panel_params, \n                        coord, \n                        n = 50, \n                        arrow = NULL,\n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        linemitre = 10,\n                        na.rm = FALSE) {\n    \n    # 转换输入数据以指定弹簧路径\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(seq_len(nrow(data)), function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        data$diameter[i],\n        data$tension[i], \n        n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    })\n    springs &lt;- do.call(rbind, springs)\n    \n    # 使用 GeomPath$draw_panel() 方法进行绘图\n    GeomPath$draw_panel(\n      data = springs, \n      panel_params = panel_params, \n      coord = coord, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      linemitre = linemitre, \n      na.rm = na.rm\n    )\n  },\n  \n  # 指定默认和必需的美学\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  default_aes = aes(\n    colour = \"black\", \n    linewidth = 0.5, \n    linetype = 1L, \n    alpha = NA, \n    diameter = 1, \n    tension = 0.75\n  )\n)\n\n尽管这段代码很长，但大部分内容都是熟悉的：\n\nsetup_data() 方法本质上是相同的：在这两种情况下，它们确保输入数据的每一行都有一个唯一的组标识符。\n我们的 GeomSpring 对象的 draw_panel() 方法与 StatSpring 代码中的 compute_panel() 方法非常相似。 主要区别是我们的 draw_panel() 方法有一个额外的步骤：它将计算出的弹簧坐标传递给 GeomPath$draw_panel()。 因为弹簧只是花哨的路径，所以 GeomPath$draw_panel() 方法在这里非常有效。\n与我们之前编写的 StatSpring 代码不同，GeomSpring 代码使用 default_aes 字段为用户提供未指定的任何美学的默认值。\n\n这个代码的一个方面可能会让习惯于其他语言中面向对象设计的开发者感到惊讶。 直接调用同类对象的方法，就像我们在 GeomSpring$draw_panel() 内部调用 GeomPath$draw_panel() 一样，并不被认为是其他面向对象系统中的好做法。 然而，因为 ggproto 对象是无状态的（Section 2.4.5），这和继承 GeomPath 并调用父方法一样安全。 您可以在 ggplot2 源代码的很多地方看到这种方法。\n\n5.4.3 构造函数\n和我们之前的尝试一样，最后一步是编写用户可以调用的构造函数 geom_spring()。 代码与早期版本没有太大不同：我们使用 GeomSpring 而不是 GeomPath，我们使用身份统计而不是 StatSpring。\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"identity\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        na.rm = FALSE,\n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomSpring, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\n\n5.4.4 测试 geom\n现在我们有了一个具有工作默认美学和设置美学为参数的能力的适当 geom：\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(aes(tension = tension, diameter = diameter))\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(diameter = 0.5)\n\n\n\n\n\n\n\n\n\n\n它确实有一些限制，因为 diameter 和 tension 的单位是相对于原始数据的尺度来表示的。 具有 diameter = 0.5 的弹簧的实际直径将取决于轴的限制，如果 x 和 y 轴不在相同的尺度上，弹簧的形状将会被扭曲。 您可以在下面的例子中看到这一点：\n\nggplot() + \n  geom_spring(aes(x = 0, y = 0, xend = 3, yend = 20))\n\n\n\n\n\n\n\n相同的底层问题意味着弹簧的直径在坐标空间中表示。 这使得定义一个有意义的默认值变得困难，因为弹簧直径的绝对大小在数据尺度变化时会改变：\n\nggplot() + \n  geom_spring(aes(x = 0, y = 0, xend = 100, yend = 80))\n\n\n\n\n\n\n\n我们将在 Section 5.6 中解决这个问题。\n\n5.4.5 事后分析\n在这一节中，我们终于创建了我们自己的 Geom 扩展。 这通常是新层开发的自然结论，但并不总是如此。 有时您会发现统计方法对您的目的来说完全足够，它的优点是您可以使用多个 geoms 来使用统计。 最终的选择取决于您作为开发者，应由您预期人们如何使用该层来指导。\n也许令人惊讶的是，我们还没有讨论 draw_*() 方法内部发生了什么。 我们的 GeomSpring 对象依赖于 GeomPath$draw_panel() 方法来创建图形输出。 这很常见。 例如，即使是相对复杂的 GeomBoxplot 也只使用 GeomPoint()，GeomSegment 和 GeomCrossbar 的绘图方法。\n如果您需要深入了解，您将需要了解一些关于 grid 的知识。 创建 grid grobs 是一种高级技术，只有相对较少的 geoms 需要。 但创建一个 grid grob 使您能够使用绝对单位来表示直径（例如 1cm），并根据输出设备的大小调整 geom 的显示。 我们接下来将讨论这个。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html#grid-介绍",
    "href": "ggplot2_spring1.html#grid-介绍",
    "title": "4  一个学习案例",
    "section": "\n5.5 grid 介绍",
    "text": "5.5 grid 介绍\ngrid 包提供了 ggplot2 构建的底层图形系统。 它是基础 R 中包含的两种截然不同的绘图系统之一：基础图形和 grid。 基础图形有一个命令式的“纸上笔”模型：每个函数立即在图形设备上绘制一些东西。 就像 ggplot2 本身一样，grid 采用了一种更声明式的方法，您可以将图形描述为一个对象，稍后进行渲染。 这种声明式方法允许我们创建独立于图形设备的对象，并且可以传递、分析和修改。 重要的是，图形对象的部分可以引用其他部分，这使您能够做到诸如定义这个矩形的宽度等于那个文本字符串的长度等事情。\n作为一个 ggplot2 开发者，您会发现在没有直接与 grid 交互的情况下可以实现很多目标，但有些情况下，如果不深入到 grid 级别，就无法实现您想要的效果。 最常见的两种情况是：\n\n您需要创建在坐标系中正确定位的图形对象，但其中一些外观具有固定绝对大小。 在我们的案例中，这将是正确地在图表中的两个点之间延伸的弹簧，但直径以厘米为单位，而不是相对于坐标系。\n您需要在调整大小时更新的图形对象。 这可以是例如 ggrepel 包中的标签位置，或者是 ggforce 中的 geom_mark_*() geoms。\n\n我们无法在这本书中全面介绍 grid，但为了帮助您开始，我们将提供理解 ggplot2 如何使用 grid 的绝对最小词汇。 我们将介绍核心概念，如 grobs，视图端口，图形参数和单位，但请阅读 R Graphics by @murrell:2018 以获得详细信息。\n\n5.5.1 Grobs\n要了解 grid 的工作原理，首先需要了解的是 grobs。 Grobs (graphic objects) 是 grid 中图形元素的原子表示，包括点、线、圆圈、矩形和文本等类型。 grid 包提供了像 pointsGrob()，linesGrob()，circleGrob()，rectGrob() 和 textGrob() 这样的函数来创建图形对象，而不会将任何内容绘制到图形设备上。 这些函数是矢量化的，允许一个点 grob 表示多个点，例如：\n\nlibrary(grid)\ncircles &lt;- circleGrob(\n  x = c(0.1, 0.4, 0.7), \n  y = c(0.5, 0.3, 0.6),\n  r = c(0.1, 0.2, 0.3)\n)\ncircles\n#&gt; circle[GRID.circle.1]\n\n注意，这段代码没有绘制任何内容：它只是一组圆的描述。 要绘制它，我们首先调用 grid.newpage() 来清除当前图形设备，然后调用 grid.draw()：\n\ngrid.newpage()\ngrid.draw(circles)\n\n\n\n\n\n\n\ngrid 还提供了 grobTree()，它构建由多个原子 grobs 组成的复合对象。 这里有一个示例：\n\nlabels &lt;- textGrob(\n  label = c(\"small\", \"medium\", \"large\"),\n  x = c(0.1, 0.4, 0.7), \n  y = c(0.5, 0.3, 0.6),\n)\n\ncomposite &lt;- grobTree(circles, labels)\ngrid.newpage()\ngrid.draw(composite)\n\n\n\n\n\n\n\n您还可以定义自己的 grobs。 您可以使用 grob() 或 gTree() 定义一个新的原始 grob 类或一个新的复合类，然后为您的新类指定特殊行为。 我们将在片刻后看到这样一个例子。\n\n5.5.2 Viewports\ngrid 的第二个关键概念是 视图端口 的概念。 视图端口是一个矩形绘图区域，为在其内部绘制的 grobs 提供自己的坐标系统，并且还可以提供一个表格网格，其中其他视图端口可以嵌套。 一个单独的 grob 可以有自己的视图端口，或者如果没有提供，它将继承一个。 虽然我们在构建弹簧 grob 时不需要考虑视图端口，但它们是重要的概念，为 ggplot2 图形的高级布局提供动力，所以我们将在这里简要介绍它们。 在下面的示例中，我们使用 viewport() 定义了两个不同的视图端口，一个使用默认参数，第二个围绕中点旋转 15 度：\n\nvp_default &lt;- viewport()\nvp_rotated &lt;- viewport(angle = 15)\n\n这次，当我们创建我们的复合 grobs 时，我们将通过设置 vp 参数将它们显式分配给特定的视图端口：\n\ncomposite_default &lt;- grobTree(circles, labels, vp = vp_default)\ncomposite_rotated &lt;- grobTree(circles, labels, vp = vp_rotated)\n\n当我们绘制这两个 grobs 时，我们可以看到视图端口的效果：尽管 composite_default 和 composite_rotated 由相同的两个原始 grobs（即 circles 和 labels）组成，但它们属于不同的视图端口，所以在绘图时看起来不同：\n\ngrid.newpage()\ngrid.draw(composite_default)\ngrid.draw(composite_rotated)\n\n\n\n\n\n\n\nggplot2 自动生成大部分您需要的视图端口，但理解基本概念很重要。\n\n5.5.3 图形参数\n我们需要理解的下一个概念是 图形参数。 当我们定义 circles 和 labels grobs 时，我们只指定了它们的一些属性。 例如，我们没有提到颜色或透明度，所以这些属性都设置为默认值。 grid 中的 gpar() 函数允许您将图形参数指定为独立的对象：\n\ngp_blue &lt;- gpar(col = \"blue\", fill = NA)\ngp_orange &lt;- gpar(col = \"orange\", fill = NA)\n\ngp_blue 和 gp_orange 对象提供了图形设置列表，现在可以使用 gp 参数将它们应用到任何 grob 上：\n\ngrob1 &lt;- grobTree(circles, labels, vp = vp_default, gp = gp_blue)\ngrob2 &lt;- grobTree(circles, labels, vp = vp_rotated, gp = gp_orange)\n\n当我们绘制这两个 grobs 时，它们继承了图形参数提供的设置以及它们被分配的视图端口：\n\ngrid.newpage()\ngrid.draw(grob1)\ngrid.draw(grob2)\n\n\n\n\n\n\n\n\n5.5.4 单位\n我们需要讨论的最后一个核心概念是 单位 系统。 grid 包允许您使用灵活的规格来指定 grobs 和视图端口的位置（例如 x 和 y）和尺寸（例如 length 和 width）。 在 grid 单位系统中，有三种不同风格的单位：\n\n绝对单位，例如厘米、英寸和点，指的是物理大小。\n相对单位，例如 npc，它代表当前视图端口大小的比例。\n由字符串或其他 grobs 定义的单位，例如 strwidth，grobwidth。\n\nunit() 函数是我们在指定单位时主要使用的功能：unit(1, \"cm\") 是 1 厘米，而 unit(0.5, \"npc\") 是相关视图端口大小的一半。 单位系统支持在绘图时才解析的算术运算，这使得它可能结合不同类型的单位：unit(0.5, \"npc\") + unit(1, \"cm\") 定义了一个点，它位于当前视图端口中心右侧一厘米的位置。\n\n5.5.5 构建 grob 类\n现在我们已经对 grid 有了基本了解，让我们尝试创建我们自己的“惊喜” grob 类：如果它们小于 3 厘米，则为圆形，但每当它们大于 3 厘米时，它们会变成正方形。 这不是最有用的一种图形对象，但它有助于说明 grid 系统的灵活性。 第一步是使用 grob() 或 gTree() 编写我们自己的构造函数，这取决于我们是创建一个原始对象还是复合对象。 我们首先创建一个“精简”的构造函数：\n\nsurpriseGrob &lt;- function(x, \n                         y, \n                         size, \n                         default.units = \"npc\", \n                         name = NULL, \n                         gp = gpar(), \n                         vp = NULL) {\n  \n  # 确保输入参数是单位\n  if (!is.unit(x)) x &lt;- unit(x, default.units)\n  if (!is.unit(y)) y &lt;- unit(y, default.units)\n  if (!is.unit(size)) size &lt;- unit(size, default.units)\n  \n  # 构建惊喜 grob 子类作为 gTree\n  gTree(\n    x = x, \n    y = y, \n    size = size, \n    name = name, \n    gp = gp, \n    vp = vp, \n    cl = \"surprise\"\n  )\n}\n\n这个函数没有做太多。 它只是确保 x，y 和 size 参数是网格单位，并将类名设置为“surprise”。 要定义我们的 grob 的行为，我们需要为一个或两个通用函数 makeContext() 和 makeContent() 指定方法：\n\nmakeContext() 在父 grob 呈现时被调用，允许您控制 grob 的视图端口。 我们不需要为我们的惊喜 grob 使用这个。\nmakeContent() 在每次绘图区域调整大小时被调用，允许您根据大小或其他方面自定义 grob 的外观。\n\n因为这些通用函数使用 S3 面向对象编程系统，我们可以通过创建一个名为 makeContent.surprise() 的函数来定义我们的方法，该函数接受一个 grob 作为输入并返回一个修改后的 grob 作为输出：\n\nmakeContent.surprise &lt;- function(x) {\n  x_pos &lt;- x$x\n  y_pos &lt;- x$y\n  size &lt;- convertWidth(x$size, unitTo = \"cm\", valueOnly = TRUE)\n  \n  # 确定给定大小是否大于或小于 3 厘米\n  circles &lt;- size &lt; 3\n  \n  # 为小的创建一个圆形 grob\n  if (any(circles)) {\n    circle_grob &lt;- circleGrob(\n      x = x_pos[circles], \n      y = y_pos[circles], \n      r = unit(size[circles] / 2, \"cm\")\n    )\n  } else {\n    circle_grob &lt;- NULL\n  }\n  \n  # 为大的创建一个矩形 grob\n  if (any(!circles)) {\n    square_grob &lt;- rectGrob(\n      x = x_pos[!circles], \n      y = y_pos[!circles], \n      width = unit(size[!circles], \"cm\"),\n      height = unit(size[!circles], \"cm\")\n    )\n  } else {\n    square_grob &lt;- NULL\n  }\n  \n  # 将圆形和矩形 grob 作为我们输入 grob 的子项\n  setChildren(x, gList(circle_grob, square_grob))\n}\n\n我们在这里调用的一些函数是新的，但它们都重用了我们前面讨论的核心概念。 具体来说：\n\n\nconvertWidth() 用于将网格单位从一种类型转换为另一种类型。\n\ngList() 创建一个 grobs 列表。\n\nsetChildren() 指定属于 gTree 复合 grob 的 grobs。\n\n这个函数的效果是确保每次呈现 grob 时都会重新计算每个形状的绝对大小。 所有小于 3 厘米的形状都变成圆形，所有大于 3 厘米的形状都变成正方形。 要看看这如何运作，让我们调用我们的新函数：\n\nsurprises &lt;- surpriseGrob(\n  x = c(0.25, 0.45, 0.75), \n  y = c(0.5, 0.5, 0.5), \n  size = c(0.05, 0.15, 0.25)\n)\n\nsurprises grob 包含三个形状，它们的位置和大小相对于视图端口的大小已经指定。 此时，我们还不知道这些形状中哪些将是圆形，哪些将是正方形：这取决于 surprises grob 将要被绘制的视图端口的大小。 我们现在可以用通常的方式绘制 grob：\n\ngrid.newpage()\ngrid.draw(surprises)\n\n\n\n\n\n\n\n如果您交互式运行此代码并调整绘图窗口的大小，您将看到这三个对象会根据绘图窗口的大小改变形状。 这当然不是使用 grid 的最有用的方式，但希望您可以看到这种技术如何被用于实际工作。\n\n5.5.6 表格网格\n我们将讨论的 grid 的最后一个方面是 gtable 包提供的布局引擎。 了解 gtable 不是构建我们的弹簧 grob 所必需的，但还有其他类型的 ggplot2 扩展需要这些知识，所以我们将在这里简要概述。\n如在 Section 2.3 中所讨论的，当 ggplot2 将绘图传递给 grid 进行渲染时，它通过创建一个 ggplot_gtable() 来实现。 我们可以使用 ggplotGrob() 函数提取这个对象：\n\np &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()\ngrob_table &lt;- ggplotGrob(p)\ngrob_table\n#&gt; TableGrob (16 x 13) \"layout\": 22 grobs\n#&gt;     z         cells             name\n#&gt; 1   0 ( 1-16, 1-13)       background\n#&gt; 2   5 ( 8- 8, 6- 6)           spacer\n#&gt; 3   7 ( 9- 9, 6- 6)           axis-l\n#&gt; 4   3 (10-10, 6- 6)           spacer\n#&gt; 5   6 ( 8- 8, 7- 7)           axis-t\n#&gt; 6   1 ( 9- 9, 7- 7)            panel\n#&gt; 7   9 (10-10, 7- 7)           axis-b\n#&gt; 8   4 ( 8- 8, 8- 8)           spacer\n#&gt; 9   8 ( 9- 9, 8- 8)           axis-r\n#&gt; 10  2 (10-10, 8- 8)           spacer\n#&gt; 11 10 ( 7- 7, 7- 7)           xlab-t\n#&gt; 12 11 (11-11, 7- 7)           xlab-b\n#&gt; 13 12 ( 9- 9, 5- 5)           ylab-l\n#&gt; 14 13 ( 9- 9, 9- 9)           ylab-r\n#&gt; 15 14 ( 9- 9,11-11)  guide-box-right\n#&gt; 16 15 ( 9- 9, 3- 3)   guide-box-left\n#&gt; 17 16 (13-13, 7- 7) guide-box-bottom\n#&gt; 18 17 ( 5- 5, 7- 7)    guide-box-top\n#&gt; 19 18 ( 9- 9, 7- 7) guide-box-inside\n#&gt; 20 19 ( 4- 4, 7- 7)         subtitle\n#&gt; 21 20 ( 3- 3, 7- 7)            title\n#&gt; 22 21 (14-14, 7- 7)          caption\n#&gt;                                            grob\n#&gt; 1                rect[plot.background..rect.50]\n#&gt; 2                                zeroGrob[NULL]\n#&gt; 3            absoluteGrob[GRID.absoluteGrob.38]\n#&gt; 4                                zeroGrob[NULL]\n#&gt; 5                                zeroGrob[NULL]\n#&gt; 6                       gTree[panel-1.gTree.29]\n#&gt; 7            absoluteGrob[GRID.absoluteGrob.34]\n#&gt; 8                                zeroGrob[NULL]\n#&gt; 9                                zeroGrob[NULL]\n#&gt; 10                               zeroGrob[NULL]\n#&gt; 11                               zeroGrob[NULL]\n#&gt; 12 titleGrob[axis.title.x.bottom..titleGrob.42]\n#&gt; 13   titleGrob[axis.title.y.left..titleGrob.45]\n#&gt; 14                               zeroGrob[NULL]\n#&gt; 15                               zeroGrob[NULL]\n#&gt; 16                               zeroGrob[NULL]\n#&gt; 17                               zeroGrob[NULL]\n#&gt; 18                               zeroGrob[NULL]\n#&gt; 19                               zeroGrob[NULL]\n#&gt; 20         zeroGrob[plot.subtitle..zeroGrob.47]\n#&gt; 21            zeroGrob[plot.title..zeroGrob.46]\n#&gt; 22          zeroGrob[plot.caption..zeroGrob.48]\n\n输出说明了 ggplot2 布局的结构。 该图由 18 个不同的 grobs 组成，它们被安排在一个 TableGrob 中，该表格指定了一个 12 x 9 网格，这反过来又提供了一组视图端口，以便在其中绘制各个 grobs。 这个 TableGrob 本身是一个 grobtree，并且可以通过调用 grid 中的 grid.draw() 来渲染：\n\ngrid.newpage()\ngrid.draw(grob_table)\n\n\n\n\n\n\n\n为了说明 TableGrob 如何工作，我们将创建一个没有使用 ggplot2 的简化版本的这个输出。 我们的第一步是定义构成我们绘图的组成 grobs：\n\nxtick &lt;- 0:8\nytick &lt;- seq(0, 50, 10)\n\npoints &lt;- pointsGrob(\n  x = mpg$displ / xtick[length(xtick)],\n  y = mpg$hwy / ytick[length(ytick)],\n  default.units = 'npc',\n  size = unit(6, 'pt')\n)\n\nxaxis &lt;- xaxisGrob(\n  at = seq(0, 1, length.out = length(xtick)), \n  label = xtick\n)\n\nyaxis &lt;- yaxisGrob(\n  at = seq(0, 1, length.out = length(ytick)), \n  label = ytick\n)\n\npoints grob 包含要绘制的数据，而 xaxis 和 yaxis 是绘制标记轴的 grobs。 当我们绘制 points grob 时，我们得到了散点图的核心：\n\ngrid.newpage()\ngrid.draw(points)\n\n\n\n\n\n\n\n然而，如果我们想要添加轴到这个图中，我们需要一组以表格格式排列的视图端口，以便我们可以将 xaxis 立即放在 points 下面，并将 yaxis 放在 points 的左边。 在 ggplot2 中，这由 gtable 布局引擎处理。 首先，我们使用 gtable() 定义结构：\n\nlibrary(gtable)\n\nplot_layout &lt;- gtable(\n  widths = unit(c(1.5, 0, 1, 0.5), c('cm', 'cm', 'null', 'cm')),\n  heights = unit(c(0.5, 1, 0, 1.5), c('cm', 'null', 'cm', 'cm'))\n)\n\nplot_layout 对象是一个 4 x 4 TableGrob，它定义了与我们传递给 gtable() 的行 heights 和列 widths 相匹配的视图端口大小。 gtable_show_layout() 函数提供了一种方便的方式来可视化这个布局：\n\ngtable_show_layout(plot_layout)\n\n\n\n\n\n\n\n请注意，这个布局有一行高度为零，有一列宽度为零。 我们将 xaxis 和 yaxis grobs 放入这些行中，并允许它们“溢出”到相邻的行和列中，这些行和列指定了绘图的边距。\n要将 grobs 放入表格中，我们使用 gtable_add_grob() 函数。 一个 TableGrob 布局允许一个单独的 grob 使用参数 t，l，b 和 r 跨越多个单元格，以指定 grob 跨越的 topmost，leftmost，bottom 和 rightmost 单元格。 然而， 默认情况下，假定每个 grob 属于完全一个单元格，在这种情况下，只需要指定 t 和 l 参数：\n\nplot_layout &lt;- gtable_add_grob(\n  plot_layout,\n  grobs = list(points, xaxis, yaxis),\n  t = c(2, 3, 2), # 定义每个 grob 的顶部范围的行\n  l = c(3, 3, 2), # 定义每个 grob 的左边范围的列\n  clip = 'off'\n)\n\n如果我们检查我们的 plot_layout 对象，我们会看到与 ggplot2 代码上面产生的 TableGrob 具有相同结构的东西：\n\nplot_layout\n#&gt; TableGrob (4 x 4) \"layout\": 3 grobs\n#&gt;   z     cells   name                   grob\n#&gt; 1 1 (2-2,3-3) layout points[GRID.points.51]\n#&gt; 2 2 (3-3,3-3) layout   xaxis[GRID.xaxis.52]\n#&gt; 3 3 (2-2,2-2) layout   yaxis[GRID.yaxis.53]\n\n我们现在可以使用 grid.draw() 绘制我们的绘图：\n\ngrid.newpage()\ngrid.draw(plot_layout)\n\n\n\n\n\n\n\n显然，我们仍然缺少许多在真实绘图中必要的重要细节，但希望现在很清楚 ggplot2 如何在结构化的绘图布局中安排一组 grobs。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html#sec-spring4",
    "href": "ggplot2_spring1.html#sec-spring4",
    "title": "4  一个学习案例",
    "section": "\n5.6 第四部分：一个 grid grob",
    "text": "5.6 第四部分：一个 grid grob\n让我们回到手头的问题。 凭借我们对 grid 系统的新认识，我们可以构建一个指定直径为绝对单位的弹簧 grob。\n\n5.6.1 弹簧Grob\n让我们首先定义 springGrob() 函数。 我们的关键见解是，我们可以编写 grob 代码，将弹簧绘制操作推到 makeContent() 函数级别。 通过这样做，我们可以确保直径在绘图时使用绝对单位计算，而不是相对于图表坐标定义。\n我们将首先创建我们的构造函数。 这个函数的参数基于 segmentsGrob()，因为我们本质上正在绘制修改后的线段：\n\nspringGrob &lt;- function(x0 = unit(0, \"npc\"), \n                       y0 = unit(0, \"npc\"), \n                       x1 = unit(1, \"npc\"), \n                       y1 = unit(1, \"npc\"), \n                       diameter = unit(0.1, \"npc\"), \n                       tension = 0.75,\n                       n = 50, \n                       default.units = \"npc\", \n                       name = NULL, \n                       gp = gpar(), \n                       vp = NULL) {\n  \n  # 如果用户没有指定，则使用默认单位\n  if (!is.unit(x0)) x0 &lt;- unit(x0, default.units)\n  if (!is.unit(x1)) x1 &lt;- unit(x1, default.units)\n  if (!is.unit(y0)) y0 &lt;- unit(y0, default.units)\n  if (!is.unit(y1)) y1 &lt;- unit(y1, default.units)\n  if (!is.unit(diameter)) diameter &lt;- unit(diameter, default.units)\n  \n  # 返回一个类为 \"spring\" 的 gTree\n  gTree(\n    x0 = x0, \n    y0 = y0, \n    x1 = x1, \n    y1 = y1, \n    diameter = diameter, \n    tension = tension, \n    n = n, \n    name = name, \n    gp = gp, \n    vp = vp, \n    cl = \"spring\"\n  )\n}\n\n我们看到，我们的构造函数再次是一个非常薄的包装器，围绕 gTree()。 它没有引入任何新概念：它只是确保如果需要的话将参数转换为单位，然后返回一个具有 “spring” 类的复合 grob。 绘制我们的弹簧的工作发生在 makeContent() 方法中：\n\nmakeContent.spring &lt;- function(x) {\n  \n  # 将位置和直径值转换为绝对单位\n  x0 &lt;- convertX(x$x0, \"mm\", valueOnly = TRUE)\n  x1 &lt;- convertX(x$x1, \"mm\", valueOnly = TRUE)\n  y0 &lt;- convertY(x$y0, \"mm\", valueOnly = TRUE)\n  y1 &lt;- convertY(x$y1, \"mm\", valueOnly = TRUE)\n  diameter &lt;- convertWidth(x$diameter, \"mm\", valueOnly = TRUE)\n  \n  # 保持张力和 n 不变\n  tension &lt;- x$tension\n  n &lt;- x$n\n  \n  # 转换输入数据为包含弹簧路径的数据框\n  springs &lt;- lapply(seq_along(x$x0), function(i) {\n    cbind(\n      create_spring(\n        x = x0[i], \n        y = y0[i], \n        xend = x1[i], \n        yend = y1[i], \n        diameter = diameter[i], \n        tension = tension[i], \n        n = n\n      ),\n      id = i\n    )\n  })\n  springs &lt;- do.call(rbind, springs)\n  \n  # 构建 grob\n  spring_paths &lt;- polylineGrob(\n    x = springs$x, \n    y = springs$y, \n    id = springs$id, \n    default.units = \"mm\", \n    gp = x$gp\n  )\n  setChildren(x, gList(spring_paths))\n}\n\n再次，这里有几个新的 grid 函数，但希望不难弄清楚它们的功能。 实际上这里没有发生什么花哨的事情。 每当绘图调整大小时，我们从弹簧 grob 获取坐标和直径设置，并将其全部转换为毫米。 只有在将重要数量转换为绝对单位之后，我们才使用 create_spring() 函数构建弹簧路径，然后将其作为 polyline grob 返回。\n我们现在有了一个适合在 ggplot2 中使用的弹簧 grob。 在下一节中，我们将围绕它构建一个 geom，但在此之前让我们检查一下我们的代码是否按预期工作：\n\nlibrary(grid)\nsprings &lt;- springGrob(\n  x0 = c(0, 0),\n  y0 = c(0, 0.5),\n  x1 = c(1, 1),\n  y1 = c(1, 0.5),\n  diameter = unit(c(1, 3), \"cm\"),\n  tension = c(0.2, 0.7)\n)\ngrid.newpage()\ngrid.draw(springs)\n\n\n\n\n\n\n\n这看起来不错，所以我们现在可以设计我们的新（也是最终的）geom。\n\n5.6.2 最后的 GeomSpring\n现在我们有了自定义 grob 来绘制弹簧，我们可以创建一个使用它的 GeomSpring ggproto 对象。 以下是该 geom 的完整代码：\n\nGeomSpring &lt;- ggproto(\"GeomSpring\", Geom,\n  \n  # 检查用户是否指定了合理的参数                    \n  setup_params = function(data, params) {\n    if (is.null(params$n)) {\n      params$n &lt;- 50\n    } else if (params$n &lt;= 0) {\n      rlang::abort(\"Springs must be defined with `n` greater than 0\")\n    }\n    params\n  },\n  \n  # 检查输入数据并返回 grobs\n  draw_panel = function(data, \n                        panel_params, \n                        coord, \n                        n = 50, \n                        lineend = \"butt\", \n                        na.rm = FALSE) {\n    \n    # 删除缺失数据，如果全部缺失则提前返回\n    data &lt;- remove_missing(\n      df = data, \n      na.rm = na.rm,\n      vars = c(\"x\", \"y\", \"xend\", \"yend\", \"linetype\", \"linewidth\"),\n      name = \"geom_spring\"\n    )\n    if (is.null(data) || nrow(data) == 0) return(zeroGrob())\n    \n    # 提供绘图的坐标系统\n    if (!coord$is_linear()) {\n      rlang::warn(\n        \"spring geom only works correctly on linear coordinate systems\"\n      )\n    }\n    coord &lt;- coord$transform(data, panel_params)\n    \n    # 构建 grob\n    springGrob(\n      coord$x, \n      coord$y, \n      coord$xend, \n      coord$yend,\n      default.units = \"native\", \n      diameter = unit(coord$diameter, \"cm\"),\n      tension = coord$tension, \n      n = n,\n      gp = gpar(\n        col = alpha(coord$colour, coord$alpha),\n        lwd = coord$linewidth * .pt,\n        lty = coord$linetype,\n        lineend = lineend\n      )\n    )\n  },\n  \n  # 指定必需和默认的美学\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  default_aes = aes(\n    colour = \"black\", \n    linewidth = 0.5, \n    linetype = 1L, \n    alpha = NA, \n    diameter = 0.35, \n    tension = 0.75\n  )\n)\n\n这里有几件事情需要注意。 正如您所期望的，主要的变化来自 draw_panel() 方法（见下文）。 但还有其他一些变化。\n\n以前的 GeomSpring 版本 —— 和之前的 StatSpring —— 包括一个 setup_data() 方法，该方法修改了输入数据中的组列。 现在没有了：我们不再需要担心这个，因为这个新版本的 geom 不直接调用 create_spring()。 就 geom 而言，每个弹簧由输入数据中的一行（且仅一行）定义。 将此“扩展”为弹簧状路径的所有工作都由 grob 处理。\n这个版本的 GeomSpring 有一个 setup_params() 方法。 它的唯一工作是检查用于定义弹簧的点数。\ndefault_aes 字段略有不同。 重要的变化是我们现在可以为 diameter 设置一个有意义的默认值。\n\n让我们现在仔细看看新的 draw_panel() 方法。 因为我们不再依赖 GeomPath$draw_panel() 来完成工作，我们有一些新任务需要处理：\n\n它检查坐标系统是否为非线性（例如 coord_polar()），如果是，则发出警告，因为我们的弹簧 grob 未设计用于该上下文。\n它使用坐标系统通过调用 coord 对象的 transform() 方法来重新调整位置美学。 这将所有位置美学重新映射到 0 到 1 之间，其中 0 是我们视图端口中可见的最低值（包括比例尺扩展），1 是最高值。 有了这个重新映射，坐标就准备好传递给 grob 了。\n我们使用 grid 的 gpar() 函数向 grob 传递一组图形参数。 并非所有 grobs 都关心 gpar() 中的所有条目，由于我们正在构建一条线，我们只关心 polylineGrob() 理解的图形参数，即：col（笔画颜色），lwd（线宽），lty（线型），lineend（线条末端形状）。\n\n现在 GeomSpring 定义好了，剩下的就是创建一个构造函数，用户可以调用它：\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"identity\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        lineend = \"butt\", \n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomSpring, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      lineend = lineend, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\n最后，我们可以好好利用我们的新 geom_spring() 函数了：\n\nggplot(df) + \n  geom_spring(aes(\n    x = x * 100, \n    y = y, \n    xend = xend, \n    yend = yend, \n    diameter = diameter, \n    tension = tension\n  ))\n\n\n\n\n\n\n\n正如您从上面的输出中看到的，我们现在有在改变图表的纵横比或当 x 和 y 轴在不同尺度上时表现合理的弹簧。 调整图表大小将触发路径的重新计算，所以它将继续看起来像它应该的那样。\n\n5.6.3 事后分析\n我们终于到达了我们开始制作的弹簧 geom。 我们的弹簧的直径美学对于我们的绘图来说，行为类似于线宽美学，即在调整大小和/或改变图表的纵横比时保持固定。 我们仍然可以（并且应该）进行改进。 最明显的是我们的 create_spring() 函数仍然是未矢量化的，需要单独调用每个弹簧。 正确矢量化这个函数将允许在渲染许多弹簧时大大加速（如果那是需要的话）。 我们将把这个练习留给读者。\n虽然 geom 现在已经完成了，但我们仍然有一些工作要做。 我们需要创建一个直径比例尺，并提供图例键，这些键可以正确地传达直径和张力。 这将是最后一节的主题。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html#sec-spring5",
    "href": "ggplot2_spring1.html#sec-spring5",
    "title": "4  一个学习案例",
    "section": "\n5.7 第五部分：比例尺",
    "text": "5.7 第五部分：比例尺\n我们过程的最后一步是定义新的尺度。 我们想做这个，因为我们已经定义了两种新的美学（直径和张力），我们希望用户能够对它们进行缩放。 没有为美学提供比例尺（这意味着映射的值不变）并没有错，但如果我们希望用户能够控制以及有可能的图例，我们将需要为美学提供尺度。 这是这一节的目标。\n\n5.7.1 缩放\n幸运的是，与我们迄今为止所做的工作相比，创建新的尺度并不是一个巨大的任务。 我们在 Section 4.5 中讨论 了基本思想，我们可以在这里应用这些概念，而不会有太多的痛苦。 我们的主要任务是创建一个具有适当名称的函数，该函数输出一个 Scale 对象。 大多数比例尺函数是三个基本比例尺构造函数的简单包装器，continuous_scale()，discrete_scale() 和 binned_scale()。 这里是我们如何为张力美学这样做的：\n\nscale_tension_continuous &lt;- function(..., range = c(0.1, 1)) {\n  continuous_scale(\n    aesthetics = \"tension\", \n    scale_name = \"tension_c\", \n    palette = scales::rescale_pal(range), \n    ...\n  )\n}\n\n这个 scale_tension_continuous() 函数表明它适用于哪些 aesthetics，提供了一个明确的 scale_name，并提供了一个 palette 函数，将输入域转换为输出范围。 所有其他您通常会在比例尺函数中看到参数，如 name，breaks，limits，通过点 ... 传递给 continuous_scale()。\n对于张力美学，我们预计用户将只将其应用于连续尺度，因此将 scale_tension() 定义为 scale_tension_continuous() 的别名非常方便：\n\nscale_tension &lt;- scale_tension_continuous\n\n最后，因为我们不希望人们尝试将张力美学映射到离散数据，我们还将定义一个 scale_tension_discrete() 函数，该函数总是抛出错误：\n\nscale_tension_discrete &lt;- function(...) {\n  rlang::abort(\"Tension cannot be used with discrete data\")\n}\n\n这种方法之所以有效，是因为 ggplot2 通过寻找一个名为 scale_&lt;aesthetic-name&gt;_&lt;data-type&gt; 的函数来分配美学的默认比例尺，所以任何时候用户将张力美学映射到一个离散变量，ggplot2 都会找到 scale_tension_discrete() 函数并抛出错误。 这也是为什么在预期大多数用户将使用 scale_tension() 别名的情况下，我们仍然需要包括 scale_tension_continuous() 的原因。\n直径美学的比例尺函数只是稍微复杂一些：\n\nscale_diameter_continuous &lt;- function(..., \n                                      range = c(0.25, 0.7), \n                                      unit = \"cm\") {\n  range &lt;- grid::convertWidth(\n    unit(range, unit), \n    \"cm\", \n    valueOnly = TRUE\n  )\n  continuous_scale(\n    aesthetics = \"diameter\", \n    scale_name = \"diameter_c\", \n    palette = scales::rescale_pal(range), \n    ...\n  )\n}\nscale_diameter &lt;- scale_diameter_continuous\nscale_diameter_discrete &lt;- function(...) {\n  rlang::abort(\"Diameter cannot be used with discrete data\")\n}\n\n我们对 tension 比例尺所做的唯一改变是我们允许用户定义直径范围应该以哪种单位测量。 由于 geom 期望的是厘米，我们将在将其传递到比例尺构造函数之前将其转换为厘米。 这样用户就可以自由地使用对他们来说感觉自然的任何绝对单位。\n有了我们的比例尺定义，让我们看一下：\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5)) \n#&gt; Warning: The `scale_name` argument of `continuous_scale()` is deprecated as of ggplot2\n#&gt; 3.5.0.\n\n\n\n\n\n\n\n从这个输出中我们可以看到，默认比例尺有效（即，我们没有为直径添加显式比例尺，但绘图正确渲染），自定义比例尺也有效（即，我们明确调用了 scale_tension()）。\n输出还告诉我们，我们的工作还没有完全完成，因为图例并不是很有帮助。 这是因为我们的 geom 使用了默认图例键构造函数 draw_key_point()。 这个函数不了解我们的新美学，所以完全忽略了它们。 我们可以通过定义一个自定义图例键函数 draw_key_spring() 来解决这个问题。\n\n5.7.2 draw_key_spring\n让我们通过检查 draw_key_point() 的源代码来看一看如何编写一个键构造器，这些是相当简单的函数，它们接受一个美学值的数据框，并返回一个适当的 grob，该 grob 提供图例键中显示的描述：\n\ndraw_key_point\n#&gt; function (data, params, size) \n#&gt; {\n#&gt;     if (is.null(data$shape)) {\n#&gt;         data$shape &lt;- 19\n#&gt;     }\n#&gt;     else if (is.character(data$shape)) {\n#&gt;         data$shape &lt;- translate_shape_string(data$shape)\n#&gt;     }\n#&gt;     stroke_size &lt;- data$stroke %||% 0.5\n#&gt;     stroke_size[is.na(stroke_size)] &lt;- 0\n#&gt;     pointsGrob(0.5, 0.5, pch = data$shape, gp = gpar(col = alpha(data$colour %||% \n#&gt;         \"black\", data$alpha), fill = fill_alpha(data$fill %||% \n#&gt;         \"black\", data$alpha), fontsize = (data$size %||% 1.5) * \n#&gt;         .pt + stroke_size * .stroke/2, lwd = stroke_size * .stroke/2))\n#&gt; }\n#&gt; &lt;bytecode: 0x3bb97330&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n在这段代码中，data 是一个数据框，其中一行给出了用于键的美学值，params 是层的 geom 参数，size 是键区域的大小，以厘米为单位。 您经常在 tidyverse 源代码中看到的 %||% 操作符用于在变量具有 null 值时提供默认值：\n\n`%||%` &lt;- function(x, y) {\n  if (is.null(x)) y else x\n}\n\n要定义我们的 draw_key_spring() 函数，我们需要创建一个类似的函数，它使用 springGrob() 来绘制键：\n\ndraw_key_spring &lt;- function(data, params, size) {\n  springGrob(\n    x0 = 0, \n    y0 = 0, \n    x1 = 1, \n    y1 = 1,\n    diameter = unit(data$diameter, \"cm\"), \n    tension = data$tension,\n    gp = gpar(\n      col = alpha(data$colour %||% \"black\", data$alpha),\n      lwd = (data$size %||% 0.5) * .pt,\n      lty = data$linetype %||% 1\n    ),\n    vp = viewport(clip = \"on\")\n  )\n} \n\n这段代码中唯一可能不熟悉的部分是不必要的小修饰 —— 它为我们的 grob 定义了一个裁剪视图端口，使用 vp 参数。 我们添加这个的原因是为了确保图例键中绘制的弹簧将被严格限制在它们的框内，不会溢入邻近的键区域。\n现在我们有了这个函数，我们所要做的就是告诉 GeomSpring 在绘制图例键时使用它。 这非常简单：我们只需要更改我们现有 Geom 的 draw_key() 方法：\n\nGeomSpring$draw_key &lt;- draw_key_spring\n\n有了这个最后的改变，我们的图例开始变得有意义：\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5))\n\n\n\n\n\n\n\n默认键大小对我们的键来说有点挤，但这是用户需要做的事情：ggplot2 不了解 diameter 美学，并且不能像它对 size 美学那样智能地调整键大小。\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5)) +\n  theme(legend.key.size = unit(1, \"cm\"))\n\n\n\n\n\n\n\n方便的是，我们的新图例键将用于所有缩放的美学，而不仅仅是 diameter 和 tension，从而确保键的样式将始终与层的样式匹配：\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    colour = class\n  )) + \n  theme(legend.key.size = unit(1, \"cm\"))\n\n\n\n\n\n\n\n\n5.7.3 事后分析\n这总结了我们关于创建弹簧 geom 的详细案例研究。 希望现在已经变得清晰，实现相同的 geom 扩展有许多不同的方式，您最终到达的地方主要由您的需求和您想要投入的精力决定。 案例研究侧重于层和（在较小程度上）比例尺，但希望您可以使用 Chapter 4 中的更简单示例来指导您，如果您想探索其他类型的 ggplot2 扩展。 您还可以研究 ggplot2 中的 facet 和 coord 类的源代码，以及 ggforce 和其他包中可用的扩展。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring1.html#footnotes",
    "href": "ggplot2_spring1.html#footnotes",
    "title": "4  一个学习案例",
    "section": "",
    "text": "如果您有统计背景，您会认识到这大致类似于如何计算 z 统计量。↩︎\n如果您有开发包的经验，您可能会对使用 rlang::abort() 而不是使用基础 stop() 函数的选择感到好奇。 我们当然可以选择使用基础 R 函数，但由于 ggplot2 本身使用 rlang 包，所以在这种情况下差异非常小。↩︎\n如果我们计划将此代码捆绑为一个 R 包，我们可以使用 testthat 包为 create_spring() 编写正式的单元测试。↩︎\n按照惯例，ggproto 类总是使用大驼峰式命名，并且新类总是保存在具有相同名称的变量中。↩︎\n如我们前面提到的，ggproto 不对方法和字段进行严格区分。 Stat 对象期望 compute_group() 是一个函数，所以我们将其称为方法，因为这是面向对象编程的标准术语。 相比之下，Stat 期望 required_aes 是一个变量，所以我们称它为字段。↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>一个学习案例</span>"
    ]
  },
  {
    "objectID": "top50en.html",
    "href": "top50en.html",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "5.1 Correlation\n查看简体中文版本: Top 50 ggplot2 可视化 (Chapter 6)\nAn effective chart is one that:\nThe list below sorts the visualizations based on its primary purpose. Primarily, there are 8 types of objectives you may construct plots. So, before you actually make the plot, try and figure what findings and relationships you would like to convey or examine through the visualization. Chances are it will fall under one (or sometimes more) of these 8 categories.\nThese packages are used in this article:\nThe following plots help to examine how well correlated two variables are.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#correlation",
    "href": "top50en.html#correlation",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "5.1.1 Scatterplot\nThe most frequently used plot for data analysis is undoubtedly the scatterplot. Whenever you want to understand the nature of relationship between two variables, invariably the first choice is the scatterplot.\n\ntheme_set(theme_bw())\noptions(scipen = 999)\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n5.1.2 Scatterplot With Encircling\nWhen presenting the results, sometimes I would encirlce certain special group of points or region in the chart so as to draw the attention to those peculiar cases. This can be conveniently done using the geom_encircle() in ggalt package.\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n5.1.3 Counts Chart\nThe second option to overcome the problem of data points overlap is to use what is called a counts chart. Whereever there is more points overlap, the size of the circle gets bigger.\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n5.1.4 Bubble plot\nWhile scatterplot lets you compare the relationship between 2 continuous variables, bubble chart serves well if you want to understand relationship within the underlying groups based on:\nA Categorical variable (by changing the color) and Another continuous variable (by changing the size of points). In simpler words, bubble charts are more suitable if you have 4-Dimensional data where two of them are numeric (X and Y) and one other categorical (color) and another numeric variable (size).\nThe bubble chart clearly distinguishes the range of displ between the manufacturers and how the slope of lines-of-best-fit varies, providing a better visual comparison between the groups.\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n5.1.5 Marginal Histogram / Boxplot\nIf you want to show the relationship as well as the distribution in the same chart, use the marginal histogram. It has a histogram of the X and Y variables at the margins of the scatterplot.\nThis can be implemented using the ggMarginal() function from the ggExtra package. Apart from a histogram, you could choose to draw a marginal boxplot or density plot by setting the respective type option.\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#deviation",
    "href": "top50en.html#deviation",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.2 Deviation",
    "text": "5.2 Deviation\nCompare variation in values between small number of items (or categories) with respect to a fixed reference.\n\n5.2.1 Diverging bars\nDiverging Bars is a bar chart that can handle both negative and positive values. This can be implemented by a smart tweak with geom_bar(). But the usage of geom_bar() can be quite confusing. Thats because, it can be used to make a bar chart as well as a histogram. Let me explain.\nBy default, geom_bar() has the stat set to count. That means, when you provide just a continuous X variable (and no Y variable), it tries to make a histogram out of the data.\nIn order to make a bar chart create bars instead of histogram, you need to do two things.\nSet stat=identity provide both x and y inside aes() where, x is either character or factor and y is numeric. In order to make sure you get diverging bars instead of just bars, make sure, your categorical variable has 2 categories that changes values at a certain threshold of the continuous variable. In below example, the mpg from mtcars dataset is normalised by computing the z score. Those vehicles with mpg above zero are marked green and those below are marked red.\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n5.2.2 Diverging Lollipop Chart\nLollipop chart conveys the same information as bar chart and diverging bar. Except that it looks more modern. Instead of geom_bar(), I use geom_point() and geom_segment() to get the lollipops right. Let’s draw a lollipop using the same data I prepared in the previous example of diverging bars.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n5.2.3 Diverging Dot Plot\nDot plot conveys similar information. The principles are same as what we saw in Diverging bars, except that only point are used. Below example uses the same data prepared in the diverging bars example.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#ranking",
    "href": "top50en.html#ranking",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.3 Ranking",
    "text": "5.3 Ranking\nUsed to compare the position or performance of multiple items with respect to each other. Actual values matters somewhat less than the ranking.\n\n5.3.1 Dot Plot\nDot plots are very similar to lollipops, but without the line and is flipped to horizontal position. It emphasizes more on the rank ordering of items with respect to actual values and how far apart are the entities with respect to each other.\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n5.3.2 Slope Chart\nSlope charts are an excellent way of comparing the positional placements between 2 points on time. At the moment, there is no builtin function to construct this. Following code serves as a pointer about how you may approach this.\n\n# Prepare data\ndf &lt;- read_csv(\"data/top50ggplot2/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n5.3.3 Dumbbell Plot\nDumbbell charts are a great tool if you wish to: 1. Visualize relative positions (like growth and decline) between two points in time. 2. Compare distance between two categories.\nIn order to get the correct ordering of the dumbbells, the Y variable should be a factor and the levels of the factor variable should be in the same order as it should appear in the plot.\n\n# Prepare data\nhealth &lt;- read.csv(\"data/top50ggplot2/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#distribution",
    "href": "top50en.html#distribution",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.4 Distribution",
    "text": "5.4 Distribution\nWhen you have lots and lots of data points and want to study where and how the data points are distributed.\n\n5.4.1 Tufte Boxplot\nTufte box plot, provided by ggthemes package is inspired by the works of Edward Tufte. Tufte’s Box plot is just a box plot made minimal and visually appealing.\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n5.4.2 Population Pyramid\nPopulation pyramids offer a unique way of visualizing how much population or what percentage of population fall under a certain category. The below pyramid is an excellent example of how many users are retained at each stage of a email marketing campaign funnel.\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"data/top50ggplot2/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#composition",
    "href": "top50en.html#composition",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.5 Composition",
    "text": "5.5 Composition\n\n5.5.1 Waffle Chart\nWaffle charts is a nice way of showing the categorical composition of the total population. Though there is no direct function, it can be articulated by smartly maneuvering the ggplot2 using geom_tile() function. The below template should help you create your own waffle.\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n5.5.2 Treemap\nTreemap is a nice way of displaying hierarchical data by using nested rectangles. The treemapify package provides the necessary functions to convert the data in desired format (treemapify) as well as draw the actual plot (ggplotify).\nIn order to create a treemap, the data must be converted to desired format using treemapify(). The important requirement is, your data must have one variable each that describes the area of the tiles, variable for fill color, variable that has the tile’s label and finally the parent group.\nOnce the data formatting is done, just call ggplotify() on the treemapified data.\n\nproglangs &lt;- read.csv(\"data/top50ggplot2/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#groups",
    "href": "top50en.html#groups",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.6 Groups",
    "text": "5.6 Groups\n\n5.6.1 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n5.6.2 Clusters\nIt is possible to show the distinct clusters or groups using geom_encircle(). If the dataset has multiple weak features, you can compute the principal components and draw a scatterplot using PC1 and PC2 as X and Y axis.\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50zh.html",
    "href": "top50zh.html",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "",
    "text": "6.1 相关 Correlation\n英文原版 For original version in English: Top 50 ggplot2 Visualizations (Chapter 5)\n一个好的图形包含以下要素:\n下面的示例可以根据可视化的目标分为8类图表。在实际绘制之前，你应该弄清楚你想通过数据可视化来传达或研究哪些发现和关系，它很有可能属于这8个类别中的一个或多个。\n文章中用到的R包:\n下面的图形帮助解释两个变量之间的相关性。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#相关-correlation",
    "href": "top50zh.html#相关-correlation",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "",
    "text": "6.1.1 点图 Scatterplot\n最常使用的数据分析图无疑是散点图。每当您想了解两个变量之间的关系时，第一个选择就是散点图。\n\ntheme_set(theme_bw())\noptions(scipen = 999) # 关闭科学计数显示\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n6.1.2 有圈点图 Scatterplot With Encircling\n在展示结果时，有时会在图表中强调某些特殊点组成的区域，以引起人们对这些特殊情况的注意。使用 ggalt 软件包中的geom_encircle()可以很方便地做到这一点。\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n6.1.3 计数图 Counts Chart\n当数据点重叠时，散点图可能无法清楚地显示数据，因此可以使用计数图。在计数图中，数据点重叠越多的地方会显示一更大的圆。\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n6.1.4 气泡图 Bubble plot\n散点图可以比较两个连续变量之间的关系，而气泡图则可以很好地帮助理解一个分类变量（通过改变颜色）和另一个连续变量（通过改变点的大小）的基础组内关系。简单地说，如果您有四维数据，其中两个是 X 和 Y（连续变量），另两个是表示颜色（分类变量）和大小（连续变量）的变量，那么气泡图就比较适合。\n气泡图可以清楚地区分不同制造商之间的displ范围以及最佳拟合直线斜率的变化情况，从而更好地对各组数据进行直观比较。\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n6.1.5 边际直方图 Marginal Histogram / Boxplot\n如果想在同一张图表中显示关系和分布，可以使用边际直方图。它在散点图的边缘显示 X 和 Y 变量的直方图。\n可以使用 ggExtra 软件包中的 ggMarginal() 函数来实现。除了直方图，您还可以通过设置相应的类型选项来绘制边际盒状图或密度图。\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#偏差-deviation",
    "href": "top50zh.html#偏差-deviation",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.2 偏差 Deviation",
    "text": "6.2 偏差 Deviation\n比较少量项目（或类别）之间相对于固定参照物的数值变化。\n\n6.2.1 发散型条形图 Diverging bars\n发散条形图是一种可以处理负值和正值的条形图。可以通过对 geom_bar()进行巧妙的调整来实现。但是，“geom_bar()”的用法可能相当令人困惑。这是因为它既可以用来制作柱状图，也可以用来制作直方图。让我来解释一下。\n默认情况下，geom_bar() 的统计量为计数。这意味着，当你只提供一个连续的 X 变量（而没有 Y 变量）时，它会尝试将数据制成柱状图。为了让条形图创建条形而不是直方图，需要做两件事。\n在 “aes()”中设置 “stat=identity”，同时提供 x 和 y，其中 x 是字符或因子，y 是数字。为了确保得到的是发散条形图而不是单纯的条形图，请确保您的分类变量有两个类别，其值在连续变量的某个阈值时会发生变化。在下面的示例中，mtcars 数据集中的 mpg 通过计算 z 分数进行归一化。mpg高于零的车辆标记为绿色，低于零的标记为红色。\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n6.2.2 发散型棒棒糖图 Diverging Lollipop Chart\n棒棒糖图传达的信息与柱状图和发散柱状图相同。只不过它看起来更现代。我没有使用 geom_bar()，而是使用了 geom_point() 和 geom_segment() 来正确绘制棒棒糖图。让我们用上一个发散条形图示例中的相同数据来画一个棒棒糖图。\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n6.2.3 发散型点图 Diverging Dot Plot\n点图也能传递类似的信息。其原理与我们在发散条形图中看到的相同，只是只使用了点。下面的示例使用了发散条形图示例中的相同数据。\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#排序-ranking",
    "href": "top50zh.html#排序-ranking",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.3 排序 Ranking",
    "text": "6.3 排序 Ranking\n用于比较多个变量之间的的排位。在排序中，变量实际值的重要性会显得没有他们的排位重要。\n\n6.3.1 点图 Dot Plot\n点图与棒棒糖图非常相似，但没有线段，且翻转到水平位置。它更强调变量实际值的排序，以及不同变量与起始位置之间的距离。\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n6.3.2 坡度图 Slope Chart\n坡度图提供了比较两点在不同时间上的位置的极佳方法。目前，还没有内置函数来构建这种图表。下面的代码可作为您如何处理这一问题的指南。\n\n# Prepare data\ndf &lt;- read_csv(\"data/top50ggplot2/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n6.3.3 哑铃图 Dumbbell Plot\n哑铃图是一个针对以下问题的很好的数据可视化工具：\n\n直观显示两个时间点之间的相对位置（如增长和下降）。\n比较两个类别变量之间的距离。\n\n为了获得正确的哑铃图排序，Y 变量应该是一个因子类型的数据，因子变量的水平应该与它在图中出现的顺序相同。\n\n# Prepare data\nhealth &lt;- read.csv(\"data/top50ggplot2/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#分布-distribution",
    "href": "top50zh.html#分布-distribution",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.4 分布 Distribution",
    "text": "6.4 分布 Distribution\n当你有大量的数据点，并且想研究数据点在哪里以及如何分布时。\n\n6.4.1 Tufte Boxplot\n由 ggthemes 软件包提供的 Tufte 方框图灵感来自 Edward Tufte 的作品。Tufte 的盒状图只是一个盒状图，它的设计简约而具有视觉吸引力。\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n6.4.2 人口金字塔 Population Pyramid\n人口金字塔提供了一种独特的方式，可以直观地显示有多少人口或多大比例的人口属于某个类别。下面的金字塔就是一个很好的例子，说明在电子邮件营销活动中的每个阶段有多少用户被留住。\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"data/top50ggplot2/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#组成-composition",
    "href": "top50zh.html#组成-composition",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.5 组成 Composition",
    "text": "6.5 组成 Composition\n\n6.5.1 华夫图 Waffle Chart\n华夫图是显示总人口分类组成的一种好方法。虽然没有直接的函数，但可以通过使用 geom_tile() 函数巧妙地操纵 ggplot2 来实现。下面的模板可以帮助你创建自己的华夫图。\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n6.5.2 树形图 Treemap\n树形图是一种通过嵌套矩形显示分层数据的好方法。treemapify 软件包提供了将数据转换为所需格式（treemapify）以及绘制实际图形（ggplotify）的必要函数。\n要创建树形图，必须使用 treemapify() 将数据转换为所需格式。您的数据必须分别包含一个变量，用于描述瓦片的面积、填充颜色、瓦片标签以及父组。\n数据格式化完成后，只需在树状地图数据上调用 ggplotify()。\n\nproglangs &lt;- read.csv(\"data/top50ggplot2/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#分组-groups",
    "href": "top50zh.html#分组-groups",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.6 分组 Groups",
    "text": "6.6 分组 Groups\n\n6.6.1 分层树枝图 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n6.6.2 聚类 Clusters\n可以使用 geom_encircle()来显示不同的聚类或分组。如果数据集具有多个弱特征，可以计算主成分，并以 PC1 和 PC2 为 X 轴和 Y 轴绘制散点图。\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  }
]
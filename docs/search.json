[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R语言数据可视化学习笔记",
    "section": "",
    "text": "欢迎\n欢迎来到R语言数据可视化的学习笔记，本项目主要记录了我在学习使用R语言ggplot2包进行数据可视化时的一些思考和代码。\nggplot2 是 R 语言中一个用于创建高质量图形和图表的强大包。它是基于“图形语法”（Grammar of Graphics）理论构建的，提供了一种灵活且一致的方式来描述和构建各种复杂的图形。ggplot2 的核心思想是将图形分解为多个组成部分，包括数据 (data)、映射（aes）、几何对象（geom）、统计变换（stat）、刻度（scale）和主题（theme）等。通过组合这些组件，用户可以轻松地创建从简单的散点图和柱状图到复杂的分层图形和地图等多种类型的图表。目前，ggplot2已经形成强大的拓展生态系统，可以利用ggplot2的扩展，轻松创建更加复杂和个性化的图形。\n笔记不会不含基础ggplot2绘图的相关知识，如果是初学者，建议先学习ggplot2: Elegant Graphics for Data Analysis (3e)。在这里，主要主要包含ggplot2的一些高级用法，包括ggplot2内部如何工作，编写ggplot2扩展的原理和利用ggplot2进行高级绘图。\n本项目旨在记录自己学习R语言数据可视化的过程，如有错误，欢迎在issue中提出。",
    "crumbs": [
      "欢迎"
    ]
  },
  {
    "objectID": "ChangeLog.html",
    "href": "ChangeLog.html",
    "title": "更新日志",
    "section": "",
    "text": "Top 50 ggplot2 Visualizations\n\n目前是英文版，简单介绍了一些常用的绘图原则，以及如何组合ggplot2本身自带的函数来绘制一些高级图形，部分图形会用到ggplot2的拓展包。2024-10-31 1  Top 50 ggplot2 Visualizations\n中文版已更新 2024-11-12 2  Top 50 ggplot2 可视化\n\n基础统计绘图更新\n\n曼哈顿图 2024-11-05\n分裂小提琴图 2024-11-07\n阴影条带哑铃图 2024-11-07\n\n网络相关绘图更新\n\n相关性网络图 2024-11-07",
    "crumbs": [
      "更新日志"
    ]
  },
  {
    "objectID": "top50en.html",
    "href": "top50en.html",
    "title": "1  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "1.1 Correlation\n查看简体中文版本 Chapter 2\nAn effective chart is one that:\nThe list below sorts the visualizations based on its primary purpose. Primarily, there are 8 types of objectives you may construct plots. So, before you actually make the plot, try and figure what findings and relationships you would like to convey or examine through the visualization. Chances are it will fall under one (or sometimes more) of these 8 categories.\nThese packages are used in this article:\nThe following plots help to examine how well correlated two variables are.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#correlation",
    "href": "top50en.html#correlation",
    "title": "1  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "1.1.1 Scatterplot\nThe most frequently used plot for data analysis is undoubtedly the scatterplot. Whenever you want to understand the nature of relationship between two variables, invariably the first choice is the scatterplot.\n\ntheme_set(theme_bw())\noptions(scipen = 999)\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n1.1.2 Scatterplot With Encircling\nWhen presenting the results, sometimes I would encirlce certain special group of points or region in the chart so as to draw the attention to those peculiar cases. This can be conveniently done using the geom_encircle() in ggalt package.\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n1.1.3 Counts Chart\nThe second option to overcome the problem of data points overlap is to use what is called a counts chart. Whereever there is more points overlap, the size of the circle gets bigger.\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n1.1.4 Bubble plot\nWhile scatterplot lets you compare the relationship between 2 continuous variables, bubble chart serves well if you want to understand relationship within the underlying groups based on:\nA Categorical variable (by changing the color) and Another continuous variable (by changing the size of points). In simpler words, bubble charts are more suitable if you have 4-Dimensional data where two of them are numeric (X and Y) and one other categorical (color) and another numeric variable (size).\nThe bubble chart clearly distinguishes the range of displ between the manufacturers and how the slope of lines-of-best-fit varies, providing a better visual comparison between the groups.\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n1.1.5 Marginal Histogram / Boxplot\nIf you want to show the relationship as well as the distribution in the same chart, use the marginal histogram. It has a histogram of the X and Y variables at the margins of the scatterplot.\nThis can be implemented using the ggMarginal() function from the ggExtra package. Apart from a histogram, you could choose to draw a marginal boxplot or density plot by setting the respective type option.\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#deviation",
    "href": "top50en.html#deviation",
    "title": "1  Top 50 ggplot2 Visualizations",
    "section": "\n1.2 Deviation",
    "text": "1.2 Deviation\nCompare variation in values between small number of items (or categories) with respect to a fixed reference.\n\n1.2.1 Diverging bars\nDiverging Bars is a bar chart that can handle both negative and positive values. This can be implemented by a smart tweak with geom_bar(). But the usage of geom_bar() can be quite confusing. Thats because, it can be used to make a bar chart as well as a histogram. Let me explain.\nBy default, geom_bar() has the stat set to count. That means, when you provide just a continuous X variable (and no Y variable), it tries to make a histogram out of the data.\nIn order to make a bar chart create bars instead of histogram, you need to do two things.\nSet stat=identity provide both x and y inside aes() where, x is either character or factor and y is numeric. In order to make sure you get diverging bars instead of just bars, make sure, your categorical variable has 2 categories that changes values at a certain threshold of the continuous variable. In below example, the mpg from mtcars dataset is normalised by computing the z score. Those vehicles with mpg above zero are marked green and those below are marked red.\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n1.2.2 Diverging Lollipop Chart\nLollipop chart conveys the same information as bar chart and diverging bar. Except that it looks more modern. Instead of geom_bar(), I use geom_point() and geom_segment() to get the lollipops right. Let’s draw a lollipop using the same data I prepared in the previous example of diverging bars.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n1.2.3 Diverging Dot Plot\nDot plot conveys similar information. The principles are same as what we saw in Diverging bars, except that only point are used. Below example uses the same data prepared in the diverging bars example.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#ranking",
    "href": "top50en.html#ranking",
    "title": "1  Top 50 ggplot2 Visualizations",
    "section": "\n1.3 Ranking",
    "text": "1.3 Ranking\nUsed to compare the position or performance of multiple items with respect to each other. Actual values matters somewhat less than the ranking.\n\n1.3.1 Dot Plot\nDot plots are very similar to lollipops, but without the line and is flipped to horizontal position. It emphasizes more on the rank ordering of items with respect to actual values and how far apart are the entities with respect to each other.\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n1.3.2 Slope Chart\nSlope charts are an excellent way of comparing the positional placements between 2 points on time. At the moment, there is no builtin function to construct this. Following code serves as a pointer about how you may approach this.\n\n# Prepare data\ndf &lt;- read_csv(\"data/top50ggplot2/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n1.3.3 Dumbbell Plot\nDumbbell charts are a great tool if you wish to: 1. Visualize relative positions (like growth and decline) between two points in time. 2. Compare distance between two categories.\nIn order to get the correct ordering of the dumbbells, the Y variable should be a factor and the levels of the factor variable should be in the same order as it should appear in the plot.\n\n# Prepare data\nhealth &lt;- read.csv(\"data/top50ggplot2/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#distribution",
    "href": "top50en.html#distribution",
    "title": "1  Top 50 ggplot2 Visualizations",
    "section": "\n1.4 Distribution",
    "text": "1.4 Distribution\nWhen you have lots and lots of data points and want to study where and how the data points are distributed.\n\n1.4.1 Tufte Boxplot\nTufte box plot, provided by ggthemes package is inspired by the works of Edward Tufte. Tufte’s Box plot is just a box plot made minimal and visually appealing.\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n1.4.2 Population Pyramid\nPopulation pyramids offer a unique way of visualizing how much population or what percentage of population fall under a certain category. The below pyramid is an excellent example of how many users are retained at each stage of a email marketing campaign funnel.\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"data/top50ggplot2/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#composition",
    "href": "top50en.html#composition",
    "title": "1  Top 50 ggplot2 Visualizations",
    "section": "\n1.5 Composition",
    "text": "1.5 Composition\n\n1.5.1 Waffle Chart\nWaffle charts is a nice way of showing the categorical composition of the total population. Though there is no direct function, it can be articulated by smartly maneuvering the ggplot2 using geom_tile() function. The below template should help you create your own waffle.\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n1.5.2 Treemap\nTreemap is a nice way of displaying hierarchical data by using nested rectangles. The treemapify package provides the necessary functions to convert the data in desired format (treemapify) as well as draw the actual plot (ggplotify).\nIn order to create a treemap, the data must be converted to desired format using treemapify(). The important requirement is, your data must have one variable each that describes the area of the tiles, variable for fill color, variable that has the tile’s label and finally the parent group.\nOnce the data formatting is done, just call ggplotify() on the treemapified data.\n\nproglangs &lt;- read.csv(\"data/top50ggplot2/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#groups",
    "href": "top50en.html#groups",
    "title": "1  Top 50 ggplot2 Visualizations",
    "section": "\n1.6 Groups",
    "text": "1.6 Groups\n\n1.6.1 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n1.6.2 Clusters\nIt is possible to show the distinct clusters or groups using geom_encircle(). If the dataset has multiple weak features, you can compute the principal components and draw a scatterplot using PC1 and PC2 as X and Y axis.\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50zh.html",
    "href": "top50zh.html",
    "title": "2  Top 50 ggplot2 可视化",
    "section": "",
    "text": "2.1 相关 Correlation\n英文原版 For original version in English Chapter 1\n一个好的图形包含以下要素:\n下面的示例可以根据可视化的目标分为8类图表。在实际绘制之前，你应该弄清楚你想通过数据可视化来传达或研究哪些发现和关系，它很有可能属于这8个类别中的一个或多个。\n文章中用到的R包:\n下面的图形帮助解释两个变量之间的相关性。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#相关-correlation",
    "href": "top50zh.html#相关-correlation",
    "title": "2  Top 50 ggplot2 可视化",
    "section": "",
    "text": "2.1.1 点图 Scatterplot\n最常使用的数据分析图无疑是散点图。每当您想了解两个变量之间的关系时，第一个选择就是散点图。\n\ntheme_set(theme_bw())\noptions(scipen = 999) # 关闭科学计数显示\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n2.1.2 有圈点图 Scatterplot With Encircling\n在展示结果时，有时会在图表中强调某些特殊点组成的区域，以引起人们对这些特殊情况的注意。使用 ggalt 软件包中的geom_encircle()可以很方便地做到这一点。\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n2.1.3 计数图 Counts Chart\n当数据点重叠时，散点图可能无法清楚地显示数据，因此可以使用计数图。在计数图中，数据点重叠越多的地方会显示一更大的圆。\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n2.1.4 气泡图 Bubble plot\n散点图可以比较两个连续变量之间的关系，而气泡图则可以很好地帮助理解一个分类变量（通过改变颜色）和另一个连续变量（通过改变点的大小）的基础组内关系。简单地说，如果您有四维数据，其中两个是 X 和 Y（连续变量），另两个是表示颜色（分类变量）和大小（连续变量）的变量，那么气泡图就比较适合。\n气泡图可以清楚地区分不同制造商之间的displ范围以及最佳拟合直线斜率的变化情况，从而更好地对各组数据进行直观比较。\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n2.1.5 边际直方图 Marginal Histogram / Boxplot\n如果想在同一张图表中显示关系和分布，可以使用边际直方图。它在散点图的边缘显示 X 和 Y 变量的直方图。\n可以使用 ggExtra 软件包中的 ggMarginal() 函数来实现。除了直方图，您还可以通过设置相应的类型选项来绘制边际盒状图或密度图。\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#偏差-deviation",
    "href": "top50zh.html#偏差-deviation",
    "title": "2  Top 50 ggplot2 可视化",
    "section": "\n2.2 偏差 Deviation",
    "text": "2.2 偏差 Deviation\n比较少量项目（或类别）之间相对于固定参照物的数值变化。\n\n2.2.1 发散型条形图 Diverging bars\n发散条形图是一种可以处理负值和正值的条形图。可以通过对 geom_bar()进行巧妙的调整来实现。但是，“geom_bar()”的用法可能相当令人困惑。这是因为它既可以用来制作柱状图，也可以用来制作直方图。让我来解释一下。\n默认情况下，geom_bar() 的统计量为计数。这意味着，当你只提供一个连续的 X 变量（而没有 Y 变量）时，它会尝试将数据制成柱状图。为了让条形图创建条形而不是直方图，需要做两件事。\n在 “aes()”中设置 “stat=identity”，同时提供 x 和 y，其中 x 是字符或因子，y 是数字。为了确保得到的是发散条形图而不是单纯的条形图，请确保您的分类变量有两个类别，其值在连续变量的某个阈值时会发生变化。在下面的示例中，mtcars 数据集中的 mpg 通过计算 z 分数进行归一化。mpg高于零的车辆标记为绿色，低于零的标记为红色。\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n2.2.2 发散型棒棒糖图 Diverging Lollipop Chart\n棒棒糖图传达的信息与柱状图和发散柱状图相同。只不过它看起来更现代。我没有使用 geom_bar()，而是使用了 geom_point() 和 geom_segment() 来正确绘制棒棒糖图。让我们用上一个发散条形图示例中的相同数据来画一个棒棒糖图。\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n2.2.3 发散型点图 Diverging Dot Plot\n点图也能传递类似的信息。其原理与我们在发散条形图中看到的相同，只是只使用了点。下面的示例使用了发散条形图示例中的相同数据。\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#排序-ranking",
    "href": "top50zh.html#排序-ranking",
    "title": "2  Top 50 ggplot2 可视化",
    "section": "\n2.3 排序 Ranking",
    "text": "2.3 排序 Ranking\n用于比较多个变量之间的的排位。在排序中，变量实际值的重要性会显得没有他们的排位重要。\n\n2.3.1 点图 Dot Plot\n点图与棒棒糖图非常相似，但没有线段，且翻转到水平位置。它更强调变量实际值的排序，以及不同变量与起始位置之间的距离。\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n2.3.2 坡度图 Slope Chart\n坡度图提供了比较两点在不同时间上的位置的极佳方法。目前，还没有内置函数来构建这种图表。下面的代码可作为您如何处理这一问题的指南。\n\n# Prepare data\ndf &lt;- read_csv(\"data/top50ggplot2/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n2.3.3 哑铃图 Dumbbell Plot\n哑铃图是一个针对以下问题的很好的数据可视化工具：\n\n直观显示两个时间点之间的相对位置（如增长和下降）。\n比较两个类别变量之间的距离。\n\n为了获得正确的哑铃图排序，Y 变量应该是一个因子类型的数据，因子变量的水平应该与它在图中出现的顺序相同。\n\n# Prepare data\nhealth &lt;- read.csv(\"data/top50ggplot2/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#分布-distribution",
    "href": "top50zh.html#分布-distribution",
    "title": "2  Top 50 ggplot2 可视化",
    "section": "\n2.4 分布 Distribution",
    "text": "2.4 分布 Distribution\n当你有大量的数据点，并且想研究数据点在哪里以及如何分布时。\n\n2.4.1 Tufte Boxplot\n由 ggthemes 软件包提供的 Tufte 方框图灵感来自 Edward Tufte 的作品。Tufte 的盒状图只是一个盒状图，它的设计简约而具有视觉吸引力。\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n2.4.2 人口金字塔 Population Pyramid\n人口金字塔提供了一种独特的方式，可以直观地显示有多少人口或多大比例的人口属于某个类别。下面的金字塔就是一个很好的例子，说明在电子邮件营销活动中的每个阶段有多少用户被留住。\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"data/top50ggplot2/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#组成-composition",
    "href": "top50zh.html#组成-composition",
    "title": "2  Top 50 ggplot2 可视化",
    "section": "\n2.5 组成 Composition",
    "text": "2.5 组成 Composition\n\n2.5.1 华夫图 Waffle Chart\n华夫图是显示总人口分类组成的一种好方法。虽然没有直接的函数，但可以通过使用 geom_tile() 函数巧妙地操纵 ggplot2 来实现。下面的模板可以帮助你创建自己的华夫图。\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n2.5.2 树形图 Treemap\n树形图是一种通过嵌套矩形显示分层数据的好方法。treemapify 软件包提供了将数据转换为所需格式（treemapify）以及绘制实际图形（ggplotify）的必要函数。\n要创建树形图，必须使用 treemapify() 将数据转换为所需格式。您的数据必须分别包含一个变量，用于描述瓦片的面积、填充颜色、瓦片标签以及父组。\n数据格式化完成后，只需在树状地图数据上调用 ggplotify()。\n\nproglangs &lt;- read.csv(\"data/top50ggplot2/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#分组-groups",
    "href": "top50zh.html#分组-groups",
    "title": "2  Top 50 ggplot2 可视化",
    "section": "\n2.6 分组 Groups",
    "text": "2.6 分组 Groups\n\n2.6.1 分层树枝图 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n2.6.2 聚类 Clusters\n可以使用 geom_encircle()来显示不同的聚类或分组。如果数据集具有多个弱特征，可以计算主成分，并以 PC1 和 PC2 为 X 轴和 Y 轴绘制散点图。\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  }
]
[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R语言数据可视化学习笔记",
    "section": "",
    "text": "欢迎\n欢迎来到R语言数据可视化的学习笔记，本项目主要记录了我在学习使用R语言ggplot2包进行数据可视化时的一些思考和代码。\nggplot2 是 R 语言中一个用于创建高质量图形和图表的强大包。它是基于“图形语法”（Grammar of Graphics）理论构建的，提供了一种灵活且一致的方式来描述和构建各种复杂的图形。ggplot2 的核心思想是将图形分解为多个组成部分，包括数据 (data)、映射（aes）、几何对象（geom）、统计变换（stat）、刻度（scale）和主题（theme）等。通过组合这些组件，用户可以轻松地创建从简单的散点图和柱状图到复杂的分层图形和地图等多种类型的图表。目前，ggplot2已经形成强大的拓展生态系统，可以利用ggplot2的扩展，轻松创建更加复杂和个性化的图形。\n笔记不会不含基础ggplot2绘图的相关知识，如果是初学者，建议先学习ggplot2: Elegant Graphics for Data Analysis (3e)。在这里，主要主要包含ggplot2的一些高级用法，包括ggplot2内部如何工作，编写ggplot2扩展的原理和利用ggplot2进行高级绘图。\n本项目旨在记录自己学习R语言数据可视化的过程，如有错误，欢迎在issue中提出。",
    "crumbs": [
      "欢迎"
    ]
  },
  {
    "objectID": "ChangeLog.html",
    "href": "ChangeLog.html",
    "title": "更新日志",
    "section": "",
    "text": "Top 50 ggplot2 Visualizations: 简单介绍了一些常用的绘图原则，以及如何组合ggplot2本身自带的函数来绘制一些高级图形，部分图形会用到ggplot2的拓展包。\n\n目前是英文版 2024-10-31 5  Top 50 ggplot2 Visualizations\n中文版已更新 2024-11-12 6  Top 50 ggplot2 可视化\n\n基础统计绘图更新\n\n曼哈顿图 2024-11-05\n分裂小提琴图 2024-11-07\n阴影条带哑铃图 2024-11-07\n\n网络相关绘图更新\n\n相关性网络图 2024-11-07",
    "crumbs": [
      "更新日志"
    ]
  },
  {
    "objectID": "ggplot2intro.html",
    "href": "ggplot2intro.html",
    "title": "1  ggplot2简介",
    "section": "",
    "text": "图层 Layers: 数据 data, 映射 mapping (美学 aesthetic), 几何对象 geom, 统计变换 stat, 位置调整 position adjustment\n标度 Scales：位置标度 position scales, 颜色标度 color scales, 大小标度 size scales, 线条标度 line scales, 形状标度 shape scales\n坐标系 coordinate system\n分面 Faceting\n主题 Themes",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2简介</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html",
    "href": "ggplot2internal.html",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "2.1 The plot method\n在了解 ggplot2 的底层机制时，重要的是要认识到与绘图相关的几乎所有内容都是在打印 ggplot 对象时发生的，而不是在构建对象时发生的。例如，下面的代码中，对象 p 是绘图数据的抽象表示，如图层等。它并没有构造图像本身：\np &lt;- ggplot(mpg, aes(displ, hwy, color = drv)) + \n  geom_point(position = \"jitter\") +\n  geom_smooth(method = \"lm\", formula = y ~ x) + \n  facet_wrap(vars(year)) + \n  ggtitle(\"A plot for expository purposes\")\nggplot2 被设计成允许用户向图中添加新元素，而无需重新计算任何内容。这种设计的一个含义是，如果你想了解 ggplot2 的机制，你必须跟踪你的绘图是如何进入 plot()1的。你可以通过在控制台中输入 ggplot2:::plot.ggplot 来检查 ggplot 对象的打印方法，但本章我们将使用一个简化的版本。剥离到最基本的形式，ggplot2 的绘图方法与以下 ggprint() 函数的结构相同：\nggprint &lt;- function(x) {\n  data &lt;- ggplot_build(x)\n  gtable &lt;- ggplot_gtable(data)\n  grid::grid.newpage()\n  grid::grid.draw(gtable)\n  return(invisible(x))\n}\n这个函数并不处理所有可能的情况，但它足以绘制上面指定的图表：\nggprint(p)\n在我们简化的打印方法的代码中，显示了四个不同的步骤：\n这个过程揭示了 ggplot2 本身并不进行底层绘图：当创建了 gtable 对象后，它的责任就结束了。 gtable 包（实现了 gtable 类）也不进行任何绘制。 所有绘图工作都由 grid 软件包和激活的图形设备共同完成。 这是非常重要的一点，因为这意味着 ggplot2 或 ggplot2 的任何扩展都不会关心可视化输出的细枝末节。 相反，它的工作是将用户数据转换为一个或多个图形基元，如多边形、线、点等，然后将责任移交给 grid 包。\n尽管严格来说并不正确，但我们将称这个过程为渲染过程。接下来的两个部分数据将沿着渲染过程向下推进，通过 build step（?sec-ggplotbuild）和 gtable step（?sec-ggplotgtable），最终将图形基元的集合传给 grid 。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-plot-method",
    "href": "ggplot2internal.html#sec-plot-method",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "首先，调用 ggplot_build()，这一步会准备每个图层的数据并整理成适合绘图的标准格式。\n其次，将准备好的数据传递给 ggplot_gtable()，并将其转化为存储在 gtable 中的图形元素（我们稍后再讨论 gtable 是什么）。\n第三，在 grid 软件包的帮助下，将 gtable 对象转换为图像。\n第四，将原始 ggplot 对象隐形返回给用户。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#ggplot2internal-sec-ggplotbuild",
    "href": "ggplot2internal.html#ggplot2internal-sec-ggplotbuild",
    "title": "2  ggplot2工作原理",
    "section": "2.2 The build step",
    "text": "2.2 The build step\n正如上面讨论的，ggplot_build() 接受使用公共 API 构建的声明性表示，并通过准备数据以将其转换为图形基元来增强它。\n\n2.2.1 数据准备\n数据准备的第一步是获取每个图层的相关数据，并将其转换成可预测的格式。 图层数据可以通过以下三种方式提供：自己提供数据（由 geom 的 data 参数提供），继承 ggplot() 提供的全局数据，由一个函数提供，这个函数会在行使功能时返回一个data frame。 在所有三种情况下，图层数据都是一个data frame，它将传递给绘图布局，来协调坐标系和分面。 数据首先传递到绘图坐标系，坐标系可能会改变数据（但通常不会），然后传递到分面，分面会检查数据以确定绘图中应该有多少个面板以及如何组织这些面板。在这个过程中，每一个图层的数据都会增加一列名叫 “PANEL”的数据 。 这一列数据将（必须）在整个渲染过程中保留，用于将数据的每一行链接到最终绘图中的特定面板。\n数据准备的第二步是将图层数据转换为经过计算的美学（aesthetic）值。 这包括在图层数据上评估来自 aes() 的所有美学表达式。 此外，如果没有明确给出，group美学值会从所有非连续美学值的交互中计算出来。 group美学和PANEL一样，是必须在整个处理过程中保留的特殊列。 例如，前面创建的p图只包含geom_point()指定的一个图层，在数据准备过程结束时，与该图层相关的前 10 行数据是这样的：\n\n\n\n\n\n\n这一步会在图层数据中添加两列数据：group和PANEL。PANEL列指定了哪些数据在哪一个绘图面板上（比如指定了分面变量year，该变量包含2000，2001，2008三个离散值，那么PANEL列就会保存哪些数据属于哪一年），group列指定了哪些数据属于一个组（也就是在绘图中看到的分组，比如在p中，颜色被指定为drv变量，那么group就会记录哪些数据属于哪一类drv）。\n\n\n\n\n\n     x  y colour PANEL group\n1  1.8 29      f     1     2\n2  1.8 29      f     1     2\n3  2.0 31      f     2     2\n4  2.0 30      f     2     2\n5  2.8 26      f     1     2\n6  2.8 26      f     1     2\n7  3.1 27      f     2     2\n8  1.8 26      4     1     1\n9  1.8 25      4     1     1\n10 2.0 28      4     2     1\n\n\n\n\n2.2.2 数据转换\n图层数据转换为可预测的格式后，还需要进行一系列转换，直到转换为绘图所需的格式。\n该过程的第一步是对数据中的列进行标度（scale）转换。 在这一阶段，任何标度中的 trans 参数都会产生影响，所有后续的渲染都将在这一转换后进行。 这就是在标度中设置位置变换（对x和y进行变换）与在坐标系中设置位置变换效果不同的原因。 如果在标度中指定变换，则变换会在任何其他计算之前应用，但如果在坐标系中指定变换，则变换会在这些计算之后应用。 例如，我们最初绘制的p图不涉及标度变换，因此图层数据在此阶段保持不变。 前三行如下所示：\n\n\n    x  y colour PANEL group\n1 1.8 29      f     1     2\n2 1.8 29      f     1     2\n3 2.0 31      f     2     2\n\n\n相反，如果我们的绘图对象是 p + scale_x_log10()，并在处理过程中检查此时的图层数据，我们就会看到 x 变量已进行了适当的转换：\n\n\n          x  y colour PANEL group\n1 0.2552725 29      f     1     2\n2 0.2552725 29      f     1     2\n3 0.3010300 31      f     2     2\n\n\n该过程的第二步是使用位置标度（position scales 即x和y）映射位置美学 (position aesthetic)，根据所涉及的位置标度类型（连续，离散，bins），映射过程会有所不同。 对于连续位置标度（例如我们示例中使用的标度），此时会应用 oob 参数中指定的出界函数，并删除图层数据中的 NA 值。 这对 p 没有什么影响，但如果我们绘制的是 p + xlim(2, 8)，则 oob 函数 – 本例中的 scales::censor() – 会用 NA 替换 2 以下的 x 值，如下图所示：\n\n\nWarning: Removed 22 rows containing non-finite values (stat_smooth).\n\n\n   x  y colour PANEL group\n1 NA 29      f     1     2\n2 NA 29      f     1     2\n3  2 31      f     2     2\n\n\n对于离散位置标度，变化则更为复杂，原始数值会与用户提供的limits参数或 breaks参数相匹配，然后转换为整型数值。 最后，对于 bins 位置标度，首先使用 breaks 参数将连续数据切成 bins，然后将每个 bin 的位置设置为其范围的中点。 在这一阶段进行映射的原因是保持数据的一致性：无论使用哪种位置标度，在 stat 和 geom 计算中看起来都是连续的。 这一点非常重要，否则离散标度的闪避和抖动等计算都会失败。\n在该过程的第三步中，数据被移交给统计变换（stat），由统计变换进行统计转换。程序如下：首先，统计变换可以检查数据并修改其参数，然后对数据进行一次性处理。接下来，按 “PANEL”和 “group”对图层数据进行拆分，并在数据重新组合之前计算统计数据。[^ggplot2-internal-2] 一旦数据以新的形式重新组合，就会经过另一个美学映射过程。在这个过程中，使用 stat()（或旧的 ...var...符号）延迟计算的任何美学数据都会被添加到数据中。请注意，这就是为什么stat()表达式（包括用于在示例图p的geom_smooth()层中指定回归模型的公式）不能引用原始数据。此时，原始数据根本不存在。\n举例来说，我们可以看一下图中的第二图层，它可以产生线性回归结果。在进行统计计算之前，该图层的数据只包含坐标以及所需的 “PANEL”和 “group”列。\n\n\n    x  y colour PANEL group\n1 1.8 29      f     1     2\n2 1.8 29      f     1     2\n3 2.0 31      f     2     2\n\n\n在统计计算结束后，图层数据也会相应的改变：\n\n\n         x        y     ymin     ymax        se flipped_aes colour PANEL group\n1 1.800000 24.33592 23.07845 25.59339 0.6250675       FALSE      4     1     1\n2 1.859494 24.17860 22.94830 25.40890 0.6115600       FALSE      4     1     1\n3 1.918987 24.02127 22.81795 25.22460 0.5981528       FALSE      4     1     1\n\n\n此时，geom 接管了 stat 的工作（几乎）。它要做的第一件事就是检查数据、更新参数，并可能对数据进行第一次修改（与 stat 的设置相同）。这可能会对某些列进行重新参数化，例如将 x+width 改为 xmin+xmax。之后，位置调整将被应用，例如，重叠的条形图将被堆叠等。对于我们的示例图 p 来说，这一步是在图的第一层应用抖动，并对 x 和 y 坐标进行扰动：\n\n\n         x        y colour PANEL group\n1 1.794572 29.28162      f     1     2\n2 1.777769 28.91003      f     1     2\n3 2.027313 30.93527      f     2     2\n\n\n接下来–也许令人惊讶的是–位置标度将全部重置、重新训练并应用于图层数据。仔细想想，这绝对是必要的，因为，例如，堆叠会极大地改变其中一个坐标轴的范围。在某些情况下（例如在上面的直方图示例中），其中一个位置美学可能甚至要到统计计算之后才能获得，如果不对刻度进行重新训练，它就永远不会得到训练。\n数据转换的最后一步是训练和映射所有非位置美学，即把映射的离散或连续输入转换成图形参数，如颜色、线型、大小等。此外，还将添加地形图中的任何默认美学，以便数据现在处于地形图的可预测状态。在最后一步，在构建步骤完成之前，stat 和 facet 都有最后一次机会使用它们的 “finish_data()”方法修改数据的最终映射形式。对于绘图对象 p 来说，图层数据最终状态的前几行是这样的：\n\n\n   colour        x        y PANEL group shape size fill alpha stroke\n1 #00BA38 1.777799 28.66776     1     2    19  1.5   NA    NA    0.5\n2 #00BA38 1.826653 28.62685     1     2    19  1.5   NA    NA    0.5\n3 #00BA38 2.017731 30.70364     2     2    19  1.5   NA    NA    0.5\n\n\n\n\n2.2.3 输出\nggplot_build()的返回值是一个包含ggplot_built类的列表结构。它包含计算数据以及一个Layout` 对象，该对象包含有关训练过的坐标系和分面的信息。此外，它还包含一个原始绘图对象的副本，使用经过训练的标度。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#ggplot2internal-sec-ggplotgtable",
    "href": "ggplot2internal.html#ggplot2internal-sec-ggplotgtable",
    "title": "2  ggplot2工作原理",
    "section": "2.3 The gtable step",
    "text": "2.3 The gtable step\nggplot_gtable()的目的是获取 build step 的输出，并在 gtable 软件包的帮助下将其转化为可以使用grid绘制的对象。此时，负责进一步计算的主要元素是地形、坐标系、切面和主题。统计和位置调整已经不再发挥了它们的作用。\n\n2.3.1 渲染面板\n首先是将数据转换成图形表示。这分两步进行。首先，将每个图层转换为图形对象列表（“grobs”）。与统计一样，转换是通过分割数据进行的，首先是按 “PANEL”分割，然后是按 “group”分割，出于性能考虑，geom 可能会拦截这种分割。虽然很多数据准备工作已经完成，但在这一步中，geom 还会对数据进行一些额外的转换，这种情况并不少见。其中最关键的部分是位置数据的转换和归一化。这是由坐标系完成的，虽然这通常只是意味着根据坐标系的限制对数据进行归一化，但也可能包括激进的转换，如将位置转换为极坐标。这样做的结果是为每个图层生成一个gList对象列表，该列表与切面布局中的每个面板相对应。之后，切面接手并组装面板。它首先从图层中收集每个面板的凹槽，以及基于主题的渲染条、背景、网格线和坐标轴，并将所有这些合并到每个面板的单个 gList 中。然后，它会根据计算出的面板布局将所有这些面板排列到一个 gtable 中。对于大多数绘图来说，这很简单，因为只有一个面板，但对于使用了 “facet_wrap()”的绘图来说，这可能会相当复杂。输出结果是最终 gtable 对象的基础。在处理过程的这一阶段，我们的示例图 p 看起来是这样的：\n\n\n\n\n\n\n\n\n\n\n\n2.3.2 添加导图\nggplot2 中有两种类型的导图：坐标轴和图例。正如我们的图 p 所示，此时坐标轴已经渲染完成，并与面板组装在一起，但图例仍然缺失。渲染图例是一个复杂的过程，首先要为每个比例尺训练一个向导。然后，如果映射允许，可能会合并多个导引器，然后再要求为图例作出贡献的图层为图例中的每个键提供键槽。然后，这些键槽会在各图层之间进行组合，并合并成最终的图例，这个过程让人想起图层是如何合并成面板的 gtable 的。最后输出的是一个 gtable，其中包含根据主题和指南规格排列和样式的每个图例框。创建完成后，会根据 legend.position主题设置将引导 gtable 添加到主 gtable 中。至此，我们的示例绘图在大多数方面都已完成：唯一缺少的就是标题。\n\n\n\n\n\n\n\n\n\n\n\n2.3.3 添加修饰\n剩下的工作就是添加标题、副标题、标题和标签，以及添加背景和页边距，这样最终的表格就完成了。\n\n\n2.3.4 Output\n至此，ggplot2 已准备好移交给 grid。我们的渲染过程大致相当于下面的代码，最终结果如上所述，是一个 gtable：\n\np_built &lt;- ggplot_build(p)\np_gtable &lt;- ggplot_gtable(p_built)\n\nclass(p_gtable)\n\n[1] \"gtable\" \"gTree\"  \"grob\"   \"gDesc\" \n\n\n不那么明显的是，对象的尺寸是不可预测的，将取决于切面、图例位置和绘制的标题。因此，如果要进一步修改 gtable，建议不要在代码中依赖行和列的位置。不过，gtable 中的所有元素都已命名，因此仍可以通过一些工作可靠地检索到，例如左上角 y 轴的槽。下面的代码显示了我们的绘图 p 的 gtable：\n\np_gtable\n\nTableGrob (13 x 15) \"layout\": 22 grobs\n    z         cells        name                                          grob\n1   0 ( 1-13, 1-15)  background               rect[plot.background..rect.741]\n2   1 ( 8- 8, 5- 5)   panel-1-1                      gTree[panel-1.gTree.612]\n3   1 ( 8- 8, 9- 9)   panel-2-1                      gTree[panel-2.gTree.627]\n4   3 ( 6- 6, 5- 5)  axis-t-1-1                                zeroGrob[NULL]\n5   3 ( 6- 6, 9- 9)  axis-t-2-1                                zeroGrob[NULL]\n6   3 ( 9- 9, 5- 5)  axis-b-1-1           absoluteGrob[GRID.absoluteGrob.631]\n7   3 ( 9- 9, 9- 9)  axis-b-2-1           absoluteGrob[GRID.absoluteGrob.631]\n8   3 ( 8- 8, 8- 8)  axis-l-1-2                                zeroGrob[NULL]\n9   3 ( 8- 8, 4- 4)  axis-l-1-1           absoluteGrob[GRID.absoluteGrob.639]\n10  3 ( 8- 8,10-10)  axis-r-1-2                                zeroGrob[NULL]\n11  3 ( 8- 8, 6- 6)  axis-r-1-1                                zeroGrob[NULL]\n12  2 ( 7- 7, 5- 5) strip-t-1-1                                 gtable[strip]\n13  2 ( 7- 7, 9- 9) strip-t-2-1                                 gtable[strip]\n14  4 ( 5- 5, 5- 9)      xlab-t                                zeroGrob[NULL]\n15  5 (10-10, 5- 9)      xlab-b titleGrob[axis.title.x.bottom..titleGrob.694]\n16  6 ( 8- 8, 3- 3)      ylab-l   titleGrob[axis.title.y.left..titleGrob.697]\n17  7 ( 8- 8,11-11)      ylab-r                                zeroGrob[NULL]\n18  8 ( 8- 8,13-13)   guide-box                             gtable[guide-box]\n19  9 ( 4- 4, 5- 9)    subtitle         zeroGrob[plot.subtitle..zeroGrob.737]\n20 10 ( 3- 3, 5- 9)       title          titleGrob[plot.title..titleGrob.736]\n21 11 (11-11, 5- 9)     caption          zeroGrob[plot.caption..zeroGrob.739]\n22 12 ( 2- 2, 2- 2)         tag              zeroGrob[plot.tag..zeroGrob.738]\n\n\n正如人们所希望的那样，最终的情节看起来与原作完全相同：\n\ngrid::grid.newpage()\ngrid::grid.draw(p_gtable)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#ggplot2internal-sec-ggproto",
    "href": "ggplot2internal.html#ggplot2internal-sec-ggproto",
    "title": "2  ggplot2工作原理",
    "section": "2.4 ggproto 简介",
    "text": "2.4 ggproto 简介\nSection 2.1 到 ?sec-ggplotgtable 的重点是构建 ggplot 所涉及的事件顺序，但对于执行这项工作的编程对象类型却有意含糊其辞。\n所有的ggplot2对象都是使用面向对象编程的ggproto系统构建的。这是一个历史性的意外：ggplot2 最初使用 proto 进行面向对象编程，但由于 proto 系统的局限性，需要一个正式的扩展机制，这就成了一个问题。试图将 ggplot2 转换到其他系统（如 R6）的尝试被证明是困难的，而创建一个专门针对 ggplot2 需求的面向对象系统被证明是最不坏的解决方案。\n如果你想编写 ggplot2 扩展程序，了解 ggproto 面向对象编程系统是非常重要的。我们将在@sec-ggplot2extend和@sec-spring1 中遇到 ggplot2 使用的 ggproto 对象。与更著名的 R6 系统一样，ggproto 使用引用语义，允许继承和访问父类的方法。虽然 ggproto 并不强制执行这些设计原则，但它们对于理解如何在 ggplot2 中使用该系统至关重要。为了说明这些概念，本节将以简化的形式介绍 ggproto 的核心机制。\n\n2.4.1 ggproto 对象\n创建一个新的ggproto对象需要使用ggproto()函数，该函数的第一个参数是新类的名称，第二个参数是新类继承的另一个ggproto对象。例如，我们可以用下面的命令创建一个ggproto对象–尽管它没有任何有用的功能：\n\nNewObject &lt;- ggproto(\n  `_class` = NULL, \n  `_inherits` = NULL\n)\n\n按照惯例，ggproto 对象使用 “UpperCamelCase”（大写字母）命名，每个单词都以大写字母开头。省略`_class`和`_inherits`参数的名称也是惯例，因此该命令的常规形式如下：\n\nNewObject &lt;- ggproto(NULL, NULL)\n\n如果我们打印这个对象，就会发现它确实是一个 ggproto 对象，但没有显示其他信息。\n\nNewObject \n\n&lt;ggproto object: Class gg&gt;\n\n\n\n\n2.4.2 创建新类\n要创建一个新的 ggproto 类，唯一严格需要做的就是提供一个类名作为 ggproto() 的第一个参数。定义一个新类的最简单命令可能是这样的\n\nNewClass &lt;- ggproto(\"NewClass\", NULL)\n\nNewClass变量仍然指向一个 ggproto 对象，但我们可以通过打印它来验证它是否具有所需的类名：\n\nNewClass\n\n&lt;ggproto object: Class NewClass, gg&gt;\n\n\n然而，到目前为止，我们所做的唯一一件事就是创建一个指定类的对象。NewClass对象什么也不做。要创建一个有用的 ggproto 类，我们需要在定义类时提供一个字段和方法列表。在这里，“字段”用于存储与对象相关的数据，而 “方法”则是可以使用对象中存储的数据的函数。字段和方法的构造是一样的，从用户的角度来看，它们不会被区别对待。\n为了说明这一点，我们将创建一个名为 Person 的新类，用来存储和操作一个人的信息。我们可以通过向 ggproto() 函数提供名称/值对来实现这一点：\n\nPerson &lt;- ggproto(\"Person\", NULL,\n  \n  # fields                  \n  given_name = NA,\n  family_name = NA,\n  birth_date = NA,\n  \n  # methods\n  full_name = function(self, family_last = TRUE) {\n    if(family_last == TRUE) {\n      return(paste(self$given_name, self$family_name))\n    }\n    return(paste(self$family_name, self$given_name))\n  },\n  age = function(self) {\n    days_old &lt;- Sys.Date() - self$birth_date\n    floor(as.integer(days_old) / 365.25)\n  },\n  description = function(self) {\n    paste(self$full_name(), \"is\", self$age(), \"years old\")\n  }\n)\n\n现在，Person类有三个字段，分别对应人的 given_name, family_name和birth_date。它还拥有三个方法：full_name()方法是一个构造人的全名的函数，使用的惯例是将给名放在前面，姓氏放在后面；age()方法以年为单位计算人的年龄；description()方法打印出人的简短描述。\n打印对象会显示与其相关的字段和方法：\n\nPerson\n\n&lt;ggproto object: Class Person, gg&gt;\n    age: function\n    birth_date: NA\n    description: function\n    family_name: NA\n    full_name: function\n    given_name: NA\n\n\nPerson这个 ggproto 对象本质上是类的模板，我们可以用它来创建单个人的特定记录（在@sec-ggproto-instances 中讨论）。如果你熟悉其他面向对象编程系统，你可能会期待一些不同的东西：通常新类的定义有一个专门的构造函数。ggproto的一个怪癖是ggproto()不会这样做：相反，类的构造函数本身就是一个对象。\n定义方法时需要注意的另一点是使用 self 作为第一个参数。这是一个特殊参数，用于让方法访问与 ggproto 对象相关的字段和方法（示例参见@sec-ggproto-subclass）。这个参数的特殊地位在打印 ggproto 方法时显而易见：\n\nPerson$full_name\n\n&lt;ggproto method&gt;\n  &lt;Wrapper function&gt;\n    function (...) \nf(..., self = self)\n\n  &lt;Inner function (f)&gt;\n    function (self, family_last = TRUE) \n{\n    if (family_last == TRUE) {\n        return(paste(self$given_name, self$family_name))\n    }\n    return(paste(self$family_name, self$given_name))\n}\n\n\n这个输出结果似乎有点出人意料：当我们之前定义 full_name() 时，我们只提供了作为 “内部函数”列出的代码。现在的情况是，ggproto() 自动将我的函数封装在一个封装函数中，该封装函数调用我的代码作为内部函数，同时确保使用了适当的 self 定义。当打印该方法时，控制台会同时显示封装函数（通常没什么意义）和内部函数。这种格式的输出出现在@sec-extensions和@sec-spring1 中。\n\n\n2.4.3 创建新的实例\n既然已经定义了 Person 类，我们就可以创建该类的实例了。方法是将一个 ggproto 对象作为第二个参数传递给 ggproto()，而不在第一个参数中指定一个新的类名。例如，我们可以如下创建新对象 Thomas 和 Danielle ，它们都是 Person 类的实例：\n\nThomas &lt;- ggproto(NULL, Person,\n  given_name = \"Thomas Lin\",\n  family_name = \"Pedersen\",\n  birth_date = as.Date(\"1985/10/12\")\n)\n\nDanielle &lt;- ggproto(NULL, Person,\n  given_name = \"Danielle Jasmine\",\n  family_name = \"Navarro\",\n  birth_date = as.Date(\"1977/09/12\")\n)\n\n将 NULL 指定为第一个参数，将指示 ggproto() 不定义一个新类，而是创建第二个参数中指定的类的新实例。由于 Thomas 和 Danielle 都是 Person 类的实例，它们自动继承了 age(), full_name() 和 description() 方法：\n\nThomas$description()\n\n[1] \"Thomas Lin Pedersen is 39 years old\"\n\nDanielle$description()\n\n[1] \"Danielle Jasmine Navarro is 47 years old\"\n\n\n\n\n2.4.4 创建子类\n在前面的示例中，我们创建了一个全新的类 Person。在实践中，你几乎永远不需要这样做：相反，你可能会使用现有的 ggproto 对象创建一个子类。为此，您可以在调用 ggproto() 时指定子类的名称及其继承对象：\n\n# define the subclass\nNewSubClass &lt;- ggproto(\"NewSubClass\", Person)\n\n# verify that this works\nNewSubClass\n\n&lt;ggproto object: Class NewSubClass, Person, gg&gt;\n    age: function\n    birth_date: NA\n    description: function\n    family_name: NA\n    full_name: function\n    given_name: NA\n    super:  &lt;ggproto object: Class Person, gg&gt;\n\n\n上面的输出显示，NewSubClass现在提供了自己的类，它继承了我们之前创建的 Person对象的所有字段和方法。但是，这个新的子类并没有添加任何新功能。\n在创建子类时，我们经常要添加新的字段或方法，并覆盖一些已有的字段或方法。例如，假设我们要将 Royalty定义为Person的子类，并添加与相关皇室成员的 rank及其统治的territory相对应的字段。由于皇室成员通常以头衔和领地而不是姓氏和名字来称呼，因此我们还需要更改 full_name() 方法的定义方式：\n\nRoyalty &lt;- ggproto(\"Royalty\", Person,\n  rank = NA,\n  territory = NA,\n  full_name = function(self) {\n    paste(self$rank, self$given_name, \"of\", self$territory)\n  }\n)\n\nThe Royalty object now defines a subclass of person that inherits some fields (given_name, family_name, birth_date) from the Person class, and supplies other fields (rank, territory). It inherits the age() and description() methods from Person, but it overwrites the full_name() method.\nRoyalty 对象现在定义了一个 Person 类的子类，它从 Person 类继承了一些字段（given_name、family_name、birth_date），并提供其他字段（rank、territory）。它从 Person 类继承了 age() 和 description() 方法，但它重写了 full_name() 方法。\n我们可以使用 ggproto() 创建 Royalty 类的实例，如下所示：\n\nVictoria &lt;- ggproto(NULL, Royalty,\n  given_name = \"Victoria\",\n  family_name = \"Hanover\",\n  rank = \"Queen\",\n  territory = \"the United Kingdom\",\n  birth_date = as.Date(\"1819/05/24\")\n)\n\n因此，当我们调用 Victoria 的 full_name() 方法时，输出结果会使用 Royalty 类中指定的方法，而不是 Person 类中定义的方法：\n\nVictoria$full_name()\n\n[1] \"Queen Victoria of the United Kingdom\"\n\n\n值得注意的是，当我们调用 description() 方法时会发生什么。该方法继承自 Person，但该方法的定义调用了 self$full_name()。尽管 description() 是在 Person 中定义的，但在此上下文中，self 仍然指的是 Victoria，她仍然是 Royalty。这意味着继承的 description() 方法的输出将使用为子类定义的 full_name() 方法：\n\nVictoria$description()\n\n[1] \"Queen Victoria of the United Kingdom is 205 years old\"\n\n\n创建子类有时需要访问父类及其方法，我们可以借助 ggproto_parent() 函数来实现。例如，我们可以定义一个 Police子类，该子类与 Royalty子类一样包含一个 rank字段，但只将该rank用作 description()方法的一部分：\n\nPolice &lt;- ggproto(\"Police\", Person,\n  rank = NA, \n  description = function(self) {\n    paste(\n      self$rank,\n      ggproto_parent(Person, self)$description()\n    )\n  }\n)\n\n在这个例子中，Police 子类的 description() 方法被定义成明确引用 Person 父类的 description() 方法。通过使用 ggproto_parent(Person, self) 的这种方式，我们能够引用父类内的方法，同时仍然保留 self 的适当本地定义。和之前一样，我们将创建一个特定的实例并验证这如预期般工作：\n\nJohn &lt;- ggproto(NULL, Police,\n  given_name = \"John\",\n  family_name = \"McClane\",\n  rank = \"Detective\",\n  birth_date = as.Date(\"1955/03/19\")\n)\n\nJohn$full_name() \n\n[1] \"John McClane\"\n\nJohn$description()\n\n[1] \"Detective John McClane is 69 years old\"\n\n\n由于我们将在下文讨论的原因，ggprot_parent() 的使用在 ggplot2 源代码中并不普遍。\n\n\n2.4.5 ggproto 代码风格\n由于 ggproto 是一个最小化的类系统，专门为 ggplot2 设计，不涉及其他任何内容，因此重要的是要认识到 ggproto 在 ggplot2 中的使用方式是非常特定的。它存在的目的是支持 ggplot2 的扩展系统，您不太可能在编写 ggplot2 扩展以外的任何环境中遇到 ggproto。考虑到这一点，了解 ggplot2 如何使用 ggproto 是有用的：\n\nggproto 类被有选择地使用。在 ggplot2 中使用 ggproto 并不是全面的。只有选择性的功能是基于 ggproto 的，并且既不期望也不建议在您的扩展中创建完全新的 ggproto 类。作为扩展开发者，您永远不会创建完全的 ggproto 对象，而是需要继承 ggplot2 提供的某个主要的 ggproto 类。Chapter 4 和 ?sec-spring1 将详细介绍如何做到这一点。\nggproto 类是无状态的。除了用于编排渲染的少数内部类之外，ggplot2 中的 ggproto 类被认为是”无状态的”。这意味着 ggplot2 预期在它们被构建之后，它们不会改变。这打破了对于基于引用的类（其中的方法通常可以安全地改变对象的状态）的常见期望，但在 ggplot2 中这样做是不安全的。如果您的代码违反了这个原则，并在渲染过程中改变了 Stat 或 Geom 的状态，那么绘制已保存的 ggplot 对象将会影响 所有 该 Stat 或 Geom 的实例（即使那些在其他图表中使用的实例），因为它们都指向同一个 ggproto 父对象。考虑到这一点，您应该只在两种情况下指定 ggplot2 中 ggproto 对象的状态。首先，您可以在创建对象时指定状态：这是可以接受的，因为此状态应该在任何实例之间共享。其次，您可以通过在别处管理的 params 对象来指定状态。正如您将在后面看到的（参见 Section 4.2 和 Section 4.3），大多数 ggproto 类都有一个 setup_params() 方法，在那里可以检查数据并计算和存储特定的属性。\nggproto 类有简单的继承。由于 ggproto 类实例是无状态的，调用定义在其他类内部的方法，而不是显式地从该类继承，是相对安全的。这就是为什么在 ggplot2 源代码中很少调用 ggproto_parent() 函数的原因。例如，GeomErrorbar 中的 setup_params() 方法被定义为：\n\n\n    #| eval: false\n    GeomErrorbar &lt;- ggproto(\n      # ...\n      setup_params = function(data, params) {\n        GeomLinerange$setup_params(data, params)\n      }\n      # ...\n    )\n\n这种模式通常比使用 ggproto_parent() 更容易读取，而且因为 ggproto 对象是无状态的，所以也同样安全。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#footnotes",
    "href": "ggplot2internal.html#footnotes",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "你通常不会直接调用这个 plot() 方法，因为它是由打印方法调用的，因此每当打印 ggplot 对象时都会调用它。↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html",
    "href": "ggplot2extend.html",
    "title": "3  编写ggplot2扩展",
    "section": "",
    "text": "4 扩展 ggplot2\nggplot2 包的设计使其能够相对容易的通过通用语法组件来构建新的绘图类型，以扩展其功能。ggplot2 允许拓展开发者将其拓展作为包进行分发，拓展的易制作性也使编写一次性拓展来解决特定的绘图问题成为可能。本章讨论了编写 ggplot2 拓展的不同方式，并强调了需要注意的特定问题。我们将在整章中提供小示例，但要从头到尾查看一个完整的示例，请参见 ?sec-spring1。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新主题-new-themes",
    "href": "ggplot2extend.html#新主题-new-themes",
    "title": "3  编写ggplot2扩展",
    "section": "4.1 新主题 New themes",
    "text": "4.1 新主题 New themes\n\n4.1.1 修改主题\n主题可能是最简单的拓展形式，它们只需要使用在 ggplot2 创建图表时会使用的代码。虽然可以从零开始构建新主题，但通常修改现有主题更简单且不易出错。ggplot2 源代码中通常采用这种方法。例如，这是 theme_minimal() 的源代码：\n\ntheme_minimal &lt;- function(base_size = 11, \n                          base_family = \"\", \n                          base_line_size = base_size/22, \n                          base_rect_size = base_size/22) {\n    theme_bw(\n      base_size = base_size, \n      base_family = base_family, \n      base_line_size = base_line_size, \n      base_rect_size = base_rect_size\n    ) %+replace% \n    theme(\n      axis.ticks = element_blank(), \n      legend.background = element_blank(), \n      legend.key = element_blank(), \n      panel.background = element_blank(), \n      panel.border = element_blank(), \n      strip.background = element_blank(), \n      plot.background = element_blank(), \n      complete = TRUE\n    )\n}\n\n如你所见，代码与在为图表添加样式时写的代码没有太大不同。theme_minimal() 函数使用 theme_bw() 作为基础主题，然后使用 %+replace% 运算符替换了其中某些参数的值。在创建新主题时，为用户提供一些参数来自定义主题是比较好的做法，比如文本、线条的粗细和主题辅助颜色等。例如，我们可以创建一个 theme_minimal() 的变体，允许用户指定图表的背景颜色：\ntheme_background &lt;- function(background = \"white\", ...) {\n  theme_minimal(...) %+replace%\n    theme(\n      plot.background = element_rect(\n        fill = background,\n        colour = background\n      ),\n      complete = TRUE\n    )\n}\n\nbase &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()\nbase + theme_minimal(base_size = 14)\nbase + theme_background(base_size = 14)\nbase + theme_background(base_size = 14, background = \"grey70\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.1.2 完整的主题\n需要注意的是， theme_minimal() 和 theme_background() 的代码中 complete = TRUE 的使用。在创建自己的 ggplot2 主题时，complete = TRUE将确保你的主题的行为与默认主题相同，因此不太可能让用户很惊讶。为了理解为什么这是必要的，比较这两个主题：\n\n# good \ntheme_predictable &lt;- function(...) {\n  theme_classic(...) %+replace% \n    theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\"),\n      complete = TRUE\n    )\n}\n\n# bad\ntheme_surprising &lt;- function(...) {\n  theme_classic(...) %+replace% \n    theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\")\n    )\n}\n\n两个主题都打算做同一件事：更改默认的 theme_classic()主题，以便 x 轴用蓝色线条绘制，y 轴用橙色线条绘制。乍一看，两个版本似乎都符合用户期望：\nbase + theme_classic()\nbase + theme_predictable()\nbase + theme_surprising()\n\n\n\n\n\n\n\n\n\n\n\n\n\n然而，假设你的主题用户想要移除轴线条：\nbase + theme_classic() + theme(axis.line = element_blank())\nbase + theme_predictable() + theme(axis.line = element_blank())\nbase + theme_surprising() + theme(axis.line = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\ntheme_predictable() 的行为与 theme_classic() 相同，轴线条被移除，但对于 theme_surprising() 则不是这样。原因是 ggplot2 将完整主题视为一系列“后备”值：当用户向完整主题添加 theme(axis.line = element_blank()) 时，不需要依赖 axis.line.x 或 axis.line.y 的后备值，因为这些是从用户命令中的 axis.line 继承的。这是对用户的善意，因为它允许他们使用像 theme_predictable() + theme(axis.line = ...) 这样的命令覆盖所有从 axis.line 继承的内容。相比之下，theme_surprising() 没有指定一个完整主题。当用户调用 theme_surprising() 时，后备值来自 theme_classic()，但更重要的是，ggplot2 将设置 axis.line.x 和 axis.line.y 的 theme() 命令完全视为用户输入的命令。因此，图表规范等效于此：\n\nbase + \n  theme_classic() +\n  theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\"),\n      axis.line = element_blank()\n  )\n\n\n\n\n\n\n\n\n在这段代码中，特定优先继承规则适用，因此设置 axis.line 不会覆盖更具体的 axis.line.x。\n\n\n4.1.3 定义主题元素\n在 ?sec-polishing 中我们看到，ggplot2 主题的结构由元素树定义。元素树指定了每个主题元素的类型以及它从哪里继承其值（你可以使用 get_element_tree() 函数将此树作为列表返回）。ggplot2 的扩展系统允许你通过使用 register_theme_elements() 函数将新主题元素注册为元素树的一部分来定义新主题元素。假设你正在编写一个名为 “ggxyz” 的新包，它包括作为坐标系统一部分的面板注释，你希望这个面板注释成为一个主题元素：\n\nregister_theme_elements(\n  ggxyz.panel.annotation = element_text(\n    color = \"blue\", \n    hjust = 0.95, \n    vjust = 0.05\n  ),\n  element_tree = list(\n    ggxyz.panel.annotation = el_def(\n      class = \"element_text\", \n      inherit = \"text\"\n    )\n  )\n)\n\n在包中定义新主题元素时要注意两点：\n\n重要的是要从包的 .onLoad() 函数中调用 register_theme_elements()，以便新主题元素对使用包中函数的任何人都可用，无论包是否已附加。\n始终是个好主意在任何新主题元素前包含你的包的名称作为前缀。这样，如果有人写了另一个面板注释包 ggabc，就不会有主题元素 ggxyz.panel.annotation 和 ggabc.panel.annotation 之间的潜在冲突。\n\n元素树更新后，包可以定义一个使用新主题元素的新坐标系统。一个简单的方法是定义一个创建新的 CoordCartesian ggproto 对象的函数。我们将在 Section 4.4 中更多地讨论这一点，但现在只需注意这段代码将有效：\n\ncoord_annotate &lt;- function(label = \"panel annotation\") {\n  ggproto(NULL, CoordCartesian,\n          limits = list(x = NULL, y = NULL),\n          expand = TRUE,\n          default = FALSE,\n          clip = \"on\",\n          render_fg = function(panel_params, theme) {\n            element_render(\n              theme = theme, \n              element = \"ggxyz.panel.annotation\", \n              label = label\n            )\n          }\n  )\n}\n\n所以现在这将有效：\nbase + coord_annotate(\"annotation in blue\")\nbase + coord_annotate(\"annotation in blue\") + theme_dark()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n修改了元素树后，值得一提的是 reset_theme_settings() 函数会恢复默认元素树，丢弃所有新元素定义，并（除非关闭）将当前激活的主题重置为默认。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-stats",
    "href": "ggplot2extend.html#sec-new-stats",
    "title": "3  编写ggplot2扩展",
    "section": "4.2 新统计",
    "text": "4.2 新统计\n可能令人惊讶的是，创建新统计是扩展 ggplot2 功能最有用的方式之一。当用户向图表添加新图层时，他们通常使用 geom 函数，因此作为开发人员，你可能会认为你的 ggplot2 扩展应该封装为一个新的 geom。在一定程度上这是正确的，因为你的用户可能会想要使用 geom 函数，但实际上不同 geoms 之间的多样性主要是由于不同的统计。使用统计的好处之一是它们纯粹是关于数据转换的。大多数 R 用户和开发人员对数据转换非常熟悉，这使得定义新统计变得更容易。只要所需的行为可以封装在一个统计中，就无需对任何 grid 调用进行调整。\n\n4.2.1 创建统计\n如在 ?sec-internals 中讨论的，统计的核心行为由对 compute_layer()、compute_panel() 和 compute_group() 的分层调用序列捕获，所有这些都是与定义统计的 ggproto 对象相关联的方法。默认情况下，前两个函数不执行太多操作，它们只是将数据集按 PANEL 列拆分，调用 compute_panel()，然后重新组装结果。\n\ncompute_layer() 按 PANEL 列拆分数据集，调用 compute_panel()，并重新组装结果。\ncompute_panel() 将面板数据按 group 列拆分，调用 compute_group()，并重新组装结果。\n\n因此，作为开发人员，你通常只需要指定 compute_group() 函数，其工作是获取单个组的数据并适当转换它。这将足以创建一个工作统计，尽管可能不会产生最佳性能。因此，开发人员有时会发现将一些工作转移到 compute_panel() 是有价值的：这样做可以允许你矢量化计算并避免昂贵的拆分-组合步骤（我们将在 ?sec-spring-stat 中看到这样一个例子）。然而，通常最好首先仅修改 compute_group()，然后看看性能是否足够。\n为了说明这一点，我们首先创建一个计算一组点的凸包的统计，使用 grDevices 中包含的 chull() 函数。正如你可能预期的，大部分工作是由我们将要创建的新 ggproto 对象完成的：\n\nStatChull &lt;- ggproto(\"StatChull\", Stat,\n  compute_group = function(data, scales) {\n    data[chull(data$x, data$y), , drop = FALSE]\n  },\n  required_aes = c(\"x\", \"y\")\n)\n\n如在 ?sec-ggproto 中所述，ggproto() 的前两个参数用于指示此对象定义了一个新的类（方便地命名为 \"StatChull\"），它从 Stat 对象继承字段和方法。然后我们指定只需要从 Stat 提供的默认值中更改的字段和方法，即 compute_group() 和 required_aes。我们的 compute_group() 函数接受两个输入，data 和 scales—因为这是 ggplot2 所期望的—但实际计算仅依赖于 data。请注意，由于计算必须同时存在两个位置美学，我们还指定了 required_aes 字段，以确保 ggplot2 知道这些美学是必需的。\n通过创建这个 ggproto 对象，我们有一个工作统计，但还没有给用户提供访问它的方式。为了解决这个问题，我们编写一个图层函数 stat_chull()。所有图层函数都有相同的形式：你在函数参数中指定默认值，然后调用 layer()，将 ... 传递到 params 参数中。... 中的参数将是 geom 的参数（如果你正在制作一个统计包装器），统计的参数（如果你正在制作一个 geom 包装器），或者要设置的美学。\n\nstat_chull &lt;- function(mapping = NULL, data = NULL, \n                       geom = \"polygon\", position = \"identity\", \n                       na.rm = FALSE, show.legend = NA, \n                       inherit.aes = TRUE, ...) {\n  layer(\n    stat = StatChull, \n    data = data, \n    mapping = mapping, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n现在我们的统计可以在图表中使用：\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  stat_chull(fill = NA, colour = \"black\")\n\nggplot(mpg, aes(displ, hwy, colour = drv)) + \n  geom_point() + \n  stat_chull(fill = NA)\n\n\n\n\n\n\n\n\n\n\n创建新统计时，通常是个好主意提供相应的 geom_*() 构造函数以及 stat_*() 构造函数，因为大多数用户习惯于使用 geoms 而不是统计来添加图表图层。我们将在 Section 4.3 中展示一个 geom_chull() 函数可能是什么样子。\n请注意，并不总是能够以有意义的方式定义 geom_*() 构造函数。当没有明显的默认 geom 用于新统计，或者统计旨在为现有的 geom/stat 对提供轻微修改时，这种情况就会发生。在这种情况下，可能明智的做法是只提供 stat_*() 函数。\n\n\n4.2.2 修改参数和数据\n在定义新统计时，通常需要指定 setup_params() 和/或 setup_data() 函数。这些函数在 compute_*() 函数之前被调用，它们允许统计响应并修改自身以响应参数和数据（特别是数据，在统计构造时不可用）：\n\nsetup_params() 函数首先被调用。它接受两个参数，分别对应于图层 data 和在构造期间指定的参数列表（params），并返回将在后续计算中使用的修改后的参数列表。由于参数由 compute_*() 函数使用，列表的元素应对应于 compute_*() 函数中的参数名称以便可用。\nsetup_data() 函数接下来被调用。它也接受 data 和 params 作为输入—尽管它接收的参数是 setup_params() 返回的修改后的参数—并返回修改后的图层数据。重要的是，无论在 setup_data() 中发生什么修改，PANEL 和 group 列都必须保持不变。\n\n以下示例展示了如何使用 setup_params() 方法定义新统计。修改 setup_data() 方法的示例稍后包含在 Section 4.3.2 中。假设我们想要创建 StatDensityCommon，一个统计，它在将数据分组后计算变量的密度估计，并估计应用于所有组的默认带宽。这可以通过许多不同的方式完成，但为了简单起见，我们假设我们有一个 common_bandwidth() 函数，它使用 bw.nrd0() 函数为每个组分别估计带宽，然后返回平均值：\n\ncommon_bandwidth &lt;- function(data) {\n  split_data &lt;- split(data$x, data$group)\n  bandwidth &lt;- mean(vapply(split_data, bw.nrd0, numeric(1)))\n  return(bandwidth)\n}\n\n我们希望 StatDensityCommon 使用 common_bandwith() 函数在数据被分组并传递给 compute_group() 函数之前设置一个共同的带宽。这是 setup_params() 方法的用途：\n\nStatDensityCommon &lt;- ggproto(\"StatDensityCommon\", Stat,\n  required_aes = \"x\",\n  \n  setup_params = function(data, params) {\n    if(is.null(params$bandwith)) {\n      params$bandwidth &lt;- common_bandwidth(data)\n      message(\"Picking bandwidth of \", signif(params$bandwidth, 3))\n    }\n    return(params)\n  },\n    \n  compute_group = function(data, scales, bandwidth = 1) {\n    d &lt;- density(data$x, bw = bandwidth)\n    return(data.frame(x = d$x, y = d$y))\n  }  \n)\n\n然后我们以通常的方式定义 stat_*() 函数：\n\nstat_density_common &lt;- function(mapping = NULL, data = NULL, \n                                geom = \"line\", position = \"identity\", \n                                na.rm = FALSE, show.legend = NA, \n                                inherit.aes = TRUE, bandwidth = NULL, ...) {\n  layer(\n    stat = StatDensityCommon, \n    data = data, \n    mapping = mapping, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      bandwidth = bandwidth, \n      na.rm = na.rm,\n      ...\n    )\n  )\n}\n\n现在我们可以应用我们的新统计：\n\nggplot(mpg, aes(displ, colour = drv)) + \n  stat_density_common()\n#&gt; Picking bandwidth of 0.345",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-geoms",
    "href": "ggplot2extend.html#sec-new-geoms",
    "title": "3  编写ggplot2扩展",
    "section": "4.3 新 geoms",
    "text": "4.3 新 geoms\n虽然通过创建新统计可以实现许多事情，但在某些情况下创建新的 geom 是必要的。这些情况包括：\n\n从统计返回的数据以任何当前 geoms 可以理解的形式返回是没有意义的。\n图层需要组合多个 geoms 的输出。\ngeom 需要返回当前现有 geoms 不可用的 grobs。\n\n创建新的 geoms 可能比创建新的统计看起来稍微有些令人生畏，因为最终结果是一个 grobs 集合而不是一个修改后的数据框，这对许多开发人员来说是一个不熟悉的领域。尽管如此，除了上述最后一点，你还是可以尝试不需要考虑太多 grid 和 grobs。\n\n4.3.1 修改 geom 默认值\n在许多情况下，你的新 geom 可能只是一个期望稍微不同的输入或具有不同默认参数值的现有 geom。前一节中的 stat_chull() 示例是一个很好的例子。注意，在使用 stat_chull() 创建图表时，我们必须手动指定 fill 和 colour 参数，如果它们没有映射到美学上，这些是不适合我们的凸包 geom 的默认值。为了让我们的生活稍微容易一些，我们可以创建一个 GeomPolygon 的子类，修改默认值，以便它默认产生一个空心多边形。我们可以通过覆盖 default_aes 值以直接的方式做到这一点：\n\nGeomPolygonHollow &lt;- ggproto(\"GeomPolygonHollow\", GeomPolygon,\n  default_aes = aes(\n    colour = \"black\", \n    fill = NA, \n    linewidth = 0.5,\n    linetype = 1,\n    alpha = NA\n  )\n)\n\n我们现在可以使用 GeomPolygonHollow 作为默认 geom 来定义我们的 geom_chull() 构造函数：\n\ngeom_chull &lt;- function(mapping = NULL, data = NULL, stat = \"chull\",\n                       position = \"identity\", na.rm = FALSE, \n                       show.legend = NA, inherit.aes = TRUE, ...) {\n  layer(\n    geom = GeomPolygonHollow, \n    data = data, \n    mapping = mapping, \n    stat = stat, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes,\n    params = list(na.rm = na.rm, ...)\n  )\n} \n\n为了一致性，我们还会定义 stat_chull() 使用这个作为默认值。无论如何，我们现在有一个新的 geom_chull() 函数，它工作得很好，不需要用户设置参数：\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_chull() +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n4.3.2 修改 geom 数据\n在其他情况下，你可能想要定义一个 geom，它在视觉上等同于现有的 geom，但接受不同格式的数据。ggplot2 源代码中的一个示例是 geom_spoke()，这是 geom_segment() 的一个变体，它接受极坐标数据。为了使这工作，GeomSpoke ggproto 对象从 GeomSegment 子类化，并使用 setup_data() 方法来获取用户的极坐标数据，然后将其转换为 GeomSegment 期望的格式。为了说明这种技术，我们将创建 geom_spike()，一个 geom，它重新实现了 geom_spoke() 的功能。这需要我们重写 required_aes 字段以及 setup_data() 方法：\n\nGeomSpike &lt;- ggproto(\"GeomSpike\", GeomSegment,\n  \n  # 指定所需的美学                   \n  required_aes = c(\"x\", \"y\", \"angle\", \"radius\"),\n  \n  # 在任何绘图发生之前转换数据\n  setup_data = function(data, params) {\n    transform(data,\n      xend = x + cos(angle) * radius,\n      yend = y + sin(angle) * radius\n    )\n  }\n)\n\n我们现在编写面向用户的 geom_spike() 函数：\n\ngeom_spike &lt;- function(mapping = NULL, data = NULL, \n                       stat = \"identity\", position = \"identity\", \n                       ..., na.rm = FALSE, show.legend = NA, \n                       inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    geom = GeomSpike, \n    stat = stat, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n我们现在可以使用 geom_spike() 在图表中：\n\ndf &lt;- data.frame(\n  x = 1:10,\n  y = 0,\n  angle = seq(from = 0, to = 2 * pi, length.out = 10),\n  radius = seq(from = 0, to = 2, length.out = 10)\n)\nggplot(df, aes(x, y)) +\n  geom_spike(aes(angle = angle, radius = radius)) + \n  coord_equal()\n\n\n\n\n\n\n\n\n如统计一样，geoms 也有 setup_params() 方法以及 setup_data() 方法，可以用来在任何绘图发生之前修改参数（见 Section 4.2.2 示例）。然而，在 geom 上下文中，有一点需要注意的是，setup_data() 在任何位置调整之前被调用。\n\n\n4.3.3 组合多个 geoms\n定义新 geoms 的一个有用技术是组合不同 geoms 的功能。例如，geom_smooth() 函数用于绘制非参数回归线，它使用 geom_line() 的功能来绘制回归线，并使用 geom_ribbon() 来绘制阴影误差带。要在新 geom 中实现这一点，通常通过考虑绘图过程来完成。就像统计通过调用 compute_layer() 然后 compute_panel() 最后是 compute_group() 的分层序列工作一样，geom 通过调用 draw_layer()、draw_panel() 和 draw_group() 来构建。\n如果你想组合多个 geoms 的功能，它通常可以通过在 draw_*() 调用内准备每个 geom 的数据并将其发送到不同的 geoms 来实现，使用 grid::gList() 收集输出时需要一个 grobs 列表，或者如果需要一个带有多个子项的单个 grob，则使用 grid::gTree()。\n作为一个相对简单的例子，考虑 GeomBarbell ggproto 对象，它创建由条形连接的两个点的 geoms：\n\nGeomBarbell &lt;- ggproto(\"GeomBarbell\", Geom,\n  \n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  \n  default_aes = aes(\n    colour = \"black\",\n    linewidth = .5,\n    size = 2,\n    linetype = 1,\n    shape = 19,\n    fill = NA,\n    alpha = NA,\n    stroke = 1\n  ),\n  \n  draw_panel = function(data, panel_params, coord, ...) {\n    \n    # 点的转换数据\n    point1 &lt;- transform(data) \n    point2 &lt;- transform(data, x = xend, y = yend)    \n    \n    # 返回所有三个组件\n    grid::gList(\n      GeomSegment$draw_panel(data, panel_params, coord, ...),\n      GeomPoint$draw_panel(point1, panel_params, coord, ...),\n      GeomPoint$draw_panel(point2, panel_params, coord, ...)\n    )\n  }\n) \n\n在这个例子中，draw_panel() 方法返回一个三个 grobs 的列表，一个来自 GeomSegment，两个来自 GeomPoint。像往常一样，如果我们希望 geom 对用户可见，我们添加一个包装器函数：\n\ngeom_barbell &lt;- function(mapping = NULL, data = NULL, \n                         stat = \"identity\", position = \"identity\", \n                         ..., na.rm = FALSE, show.legend = NA, \n                         inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomBarbell, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n我们现在可以使用组合 geom：\ndf &lt;- data.frame(x = 1:10, xend = 0:9, y = 0, yend = 1:10)\nbase &lt;- ggplot(df, aes(x, y, xend = xend, yend = yend))\n\nbase + geom_barbell()\nbase + geom_barbell(shape = 4, linetype = \"dashed\")  \n\n\n\n\n\n\n\n\n\n\n如果你不能利用任何现有的 geom 实现来创建 grobs，那么你将不得不从头开始实现完整的 draw_*() 方法，这需要对 grid 包有一点了解。有关 grid 的更多信息以及使用它来从网格原语构建 geom 的示例，请参见 ?sec-spring1。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-coords",
    "href": "ggplot2extend.html#sec-new-coords",
    "title": "3  编写ggplot2扩展",
    "section": "4.4 新坐标",
    "text": "4.4 新坐标\n坐标的主要 作用是将位置美学重新缩放到 [0, 1] 范围，并在此过程中对其进行转换。定义新坐标相对罕见：在 ?sec-coord 中描述的坐标适用于大多数非制图案例，并且随着 coord_sf() 的引入，在 ?sec-maps 中讨论，ggplot2 能够开箱即用地捕获大多数制图投影。\n开发人员可能需要了解坐标系统内部的最常见情况是定义新的 geoms。坐标的 draw_*() 方法之一调用坐标的 transform() 方法并不少见。例如，CoordCartesian 的 transform() 方法用于重新缩放位置数据，但不会以其他方式转换它，geom 可能需要应用此重新缩放以正确绘制 grob。一个示例出现在 ?sec-spring1 中。\n除了转换位置数据外，坐标还负责渲染轴、轴标签、面板前景和面板背景。此外，坐标可以截获并修改图层数据和分面布局。如果绝对必要，大部分这些功能都可供开发人员使用（一个示例显示在 Section 4.1.3 中），但在大多数情况下，最好保留这些功能不变。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-scales",
    "href": "ggplot2extend.html#sec-new-scales",
    "title": "3  编写ggplot2扩展",
    "section": "4.5 新比例尺",
    "text": "4.5 新比例尺\n有三种方式可能想要通过新比例尺扩展 ggplot2。最简单的情况是，当你想要为新调色板提供一个方便的包装器时，通常用于颜色或填充美学。作为一个不切实际的例子，假设你想使用像这样的调色板函数来填充小提琴或箱形图的随机颜色：\n\nrandom_colours &lt;- function(n) {\n  sample(colours(distinct = TRUE), n, replace = TRUE)\n} \n\n然后我们可以编写一个 scale_fill_random() 构造函数，将调色板传递给 discrete_scale()，然后在图表中使用它：\n\nscale_fill_random &lt;- function(..., aesthetics = \"fill\") {\n  discrete_scale(\n    aesthetics = aesthetics, \n    scale_name = \"random\", \n    palette = random_colours\n  )\n}\n\nggplot(mpg, aes(hwy, class, fill = class)) + \n  geom_violin(show.legend = FALSE) +\n  scale_fill_random()\n#&gt; Warning: The `scale_name` argument of `discrete_scale()` is deprecated as of ggplot2\n#&gt; 3.5.0.\n\n\n\n\n\n\n\n\n另一个相对简单的案例是，你提供了一个 geom，它采用新的美学类型，需要进行缩放。假设你创建了一个新的线 geom，并且你决定使用 width 美学而不是 size 美学。为了使 width 像你对 size 的缩放那样进行缩放，你必须为美学提供一个默认比例尺。默认比例尺是根据其名称和提供给美学的数据类型来找到的。如果你将连续值分配给 width 美学，ggplot2 将寻找 scale_width_continuous() 函数，并使用它如果没有添加其他宽度比例尺的话。如果找不到这样的函数（并且没有明确添加宽度比例尺），美学将不会被缩放。\n还有一个值得提及的可能性，但超出了这本书的范围，那就是创建一个新的主要比例尺类型。历史上，ggplot2 有两种主要的比例尺类型，连续和离散。最近，分箱比例尺加入其中，它允许将连续数据分箱为离散箱。可以开发进一步的主要比例尺类型，方法是子类化 Scale 或提供的主要比例尺之一，并创建新的 train() 和 map() 方法等。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新位置",
    "href": "ggplot2extend.html#新位置",
    "title": "3  编写ggplot2扩展",
    "section": "4.6 新位置",
    "text": "4.6 新位置\nPosition ggproto 类比其他 ggproto 类要简单一些，反映了 position_*() 函数的非常狭窄的范围。位置的作用是在数据立即传递给任何绘图函数之前接收和修改数据。严格来说，位置可以以任何方式修改数据，但有一个隐含的期望，即它只修改位置美学。位置具有 compute_layer() 和 compute_panel() 方法，这些方法类似于统计的等效方法，但它没有 compute_group() 方法。它还包含 setup_params() 和 setup_data() 方法，这些方法类似于其他 ggproto 类的 setup_*() 方法，有一个值得注意的例外：setup_params() 方法只接收数据作为输入，而不是参数列表。原因是 position_*() 函数从不在 ggplot2 中单独使用：相反，它们总是在指定图层的主 geom_*() 或 stat_*() 命令中调用，主命令中的参数不会传递给 position_*() 函数调用。\n为了提供一个简单的例子，我们将实现一个稍微简化版的 position_jitternormal() 函数，它来自 ggforce 包，其行为与 position_jitter() 相同，只不过扰动是从正态分布而不是均匀分布中采样的。为了保持论述简单，我们假设我们有以下便利函数定义：\n\nnormal_transformer &lt;- function(x, sd) {\n  function(x) {x + rnorm(length(x), sd = sd)}\n}\n\n当被调用时，normal_transformer() 返回一个函数，通过添加均值为零、标准差为 sd 的随机噪声来扰动输入向量。创建我们的新位置的第一步是制作一个 Position 对象的子类：\n\nPositionJitterNormal &lt;- ggproto('PositionJitterNormal', Position,\n           \n  # 我们需要一个 x 和 y 位置美学                              \n  required_aes = c('x', 'y'),\n  \n  # 通过使用 \"self\" 参数，我们可以访问用户传递给位置的参数，并将它们添加为图层参数\n  setup_params = function(self, data) {\n    list(\n      sd_x = self$sd_x, \n      sd_y = self$sd_y\n    )\n  },\n\n  # 当计算图层时，我们可以从参数列表中读取标准差参数，并使用它们来转换位置美学\n  compute_layer = function(data, params, panel) {\n    \n    # 为 x 和 y 位置尺度构建变换器 \n    x_transformer &lt;- normal_transformer(x, params$sd_x)\n    y_transformer &lt;- normal_transformer(y, params$sd_y)\n    \n    # 返回转换后的数据\n    transform_position(\n      df = data,\n      trans_x = x_transformer,  \n      trans_y = y_transformer\n    )\n  }\n)\n\ncompute_layer() 方法使用了 transform_position()，这是 ggplot2 提供的一个便利函数，其作用是将用户供应的函数应用于与相关位置尺度相关联的所有美学（例如，不仅仅是 x 和 y，还有 xend 和 yend）。\n在现实的实现中，position_jitternormal() 构造函数将进行一些输入验证，以确保用户没有指定负的标准差，但在这个上下文中我们将保持简单：\n\nposition_jitternormal &lt;- function(sd_x = .15, sd_y = .15) {\n  ggproto(NULL, PositionJitterNormal, sd_x = sd_x, sd_y = sd_y)\n}\n\n我们现在可以在创建图表时使用我们的新位置函数。要查看 position_jitter() 和我们刚刚定义的 position_jitternormal() 函数之间的区别，请比较以下图表：\ndf &lt;- data.frame(\n  x = sample(1:3, 1500, TRUE),\n  y = sample(1:3, 1500, TRUE)\n)\n\nggplot(df, aes(x, y)) + geom_point(position = position_jitter())\nggplot(df, aes(x, y)) + geom_point(position = position_jitternormal())\n\n\n\n\n\n\n\n\n\n\n在设计新位置时需要考虑的一个实际问题是，用户很少直接调用位置构造函数。指定图层的命令更可能是像 position = \"dodge\" 而不是 position = position_dodge()，更不用说覆盖你的默认值了，就像用户指定 position = position_dodge(width = 0.9) 那样。因此，如果可能的话，重要的是要仔细思考并使默认值适用于大多数情况。这可能非常棘手：位置对图层数据的形状和格式几乎没有控制权，但用户将期望它们在所有情况下都可预测地行为。一个例子是躲避，用户可能想要躲避箱形图和点云，并期望点云出现在其相应的箱形图的相同区域。在用户层面上，这是一个完全合理的期望，但对开发人员来说可能很棘手。箱形图有一个明确的宽度，可以用来控制躲避，而点则不是这样，但用户期望它们以相同的方式移动。这种考虑通常意味着位置实现最终比最简单的解决方案要复杂得多，以照顾到广泛的边缘情况。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新分面",
    "href": "ggplot2extend.html#新分面",
    "title": "3  编写ggplot2扩展",
    "section": "4.7 新分面",
    "text": "4.7 新分面\n分面是 ggplot2 中最强大的概念之一，扩展分面是修改 ggplot2 操作方式的最强大的方式之一。这种力量是有代价的：分面负责接收所有面板，将轴和条带附加到它们上，然后以预期的方式排列它们。从头开始创建一个全新的分面系统需要深入了解 grid 和 gtable，可能是一个令人生畏的挑战。幸运的是，你并不总是需要从头开始创建分面。例如，如果你的新分面将产生位于网格上的面板，你通常可以子类化 FacetWrap 或 FacetGrid 并修改一个或两个方法。特别是，你可能想要定义新的 compute_layout() 和/或 map_data() 方法：\n\ncompute_layout() 方法接收原始数据集，并创建布局规范，这是一个数据框，每行代表面板在网格上的位置，以及哪些轴限制应该是自由的，哪些应该是固定的。\nmap_data() 方法接收这个布局规范和原始数据作为输入，并将 PANEL 列 附加到它上面，用于将数据框中的每一行分配给布局中的一个面板。\n\n为了说明如何通过子类化现有分面来创建新分面，我们将创建一个相对简单的分面系统，该系统将“散布”面板，将它们随机放置在网格上。为此，我们将创建一个名为 FacetScatter 的新 ggproto 对象，它是 FacetWrap 的子类，并编写一个新的 compute_layout() 方法，将每个面板放置在面板网格中随机选择的单元格中：\n\nFacetScatter &lt;- ggproto(\"FacetScatter\", FacetWrap,\n  \n  # 这并不重要的例子：我们所做的一切是\n  # 强制所有面板使用固定尺度，以便\n  # 其余的例子可以保持简单\n  setup_params = function(data, params) {\n    params &lt;- FacetWrap$setup_params(data, params)\n    params$free &lt;- list(x = FALSE, y = FALSE)\n    return(params)\n  },                      \n  \n  # compute_layout() 方法做工作\n  compute_layout = function(data, params) {\n                  \n    # 创建一个数据框，每个分面变量一列，\n    # 每一行代表一个可能的值组合\n    # （即，每一行一个面板）\n    panels &lt;- combine_vars(\n      data = data,\n      env = params$plot_env, \n      vars = params$facets, \n      drop = FALSE\n    )\n    \n    # 创建一个数据框，ROW 和 COL 列，\n    # 每一行代表面板网格中可能的单元格\n    locations &lt;- expand.grid(ROW = 1:params$nrow, COL = 1:params$ncol)\n    \n    # 随机抽样位置的子集\n    shuffle &lt;- sample(nrow(locations), nrow(panels))\n    \n    # 为每个面板分配一个位置                      \n    layout &lt;- data.frame(\n      PANEL = 1:nrow(panels),       # 面板标识符\n      ROW = locations$ROW[shuffle], # 面板的行号\n      COL = locations$COL[shuffle], # 面板的列号\n      SCALE_X = 1L,                 # 所有 x 轴尺度都是固定的\n      SCALE_Y = 1L                  # 所有 y 轴尺度都是固定的\n    )\n    \n    # 将布局信息与面板标识符绑定\n    # 并返回得到的规范\n    return(cbind(layout, panels))\n  }                      \n)\n\n为了让你对这个输出的样子有一个感觉，这是在构建本节末尾显示的图表时创建的布局规范：\n\n#&gt;    PANEL ROW COL SCALE_X SCALE_Y manufacturer\n#&gt; 1      1   4   1       1       1         audi\n#&gt; 2      2   5   5       1       1    chevrolet\n#&gt; 3      3   5   1       1       1        dodge\n#&gt; 4      4   5   3       1       1         ford\n#&gt; 5      5   1   5       1       1        honda\n#&gt; 6      6   4   4       1       1      hyundai\n#&gt; 7      7   3   5       1       1         jeep\n#&gt; 8      8   2   2       1       1   land rover\n#&gt; 9      9   5   2       1       1      lincoln\n#&gt; 10    10   4   5       1       1      mercury\n#&gt; 11    11   2   4       1       1       nissan\n#&gt; 12    12   5   4       1       1      pontiac\n#&gt; 13    13   3   2       1       1       subaru\n#&gt; 14    14   5   6       1       1       toyota\n#&gt; 15    15   4   6       1       1   volkswagen\n\n接下来，我们将编写 facet_scatter() 构造函数，以将此功能暴露给用户。对于分面来说，这就像创建一个新的相关 ggproto 对象（在这种情况下是 FacetScatter）的实例一样简单，它将用户指定的参数传递给分面：\n\nfacet_scatter &lt;- function(facets, nrow, ncol, \n                          strip.position = \"top\", \n                          labeller = \"label_value\") {\n  \n  ggproto(NULL, FacetScatter, \n    params = list(\n      facets = rlang::quos_auto_name(facets),\n      strip.position = strip.position,\n      labeller = labeller, \n      ncol = ncol, \n      nrow = nrow\n    )\n  )\n}\n\n关于这个构造函数有几个注意事项。首先，为了保持示例简单，facet_scatter() 包含的参数比 facet_wrap() 少，我们将 nrow 和 ncol 作为必需参数：用户需要指定面板应该散布的网格的大小。其次，facet_scatter() 函数要求你使用 vars() 指定分面。如果用户尝试提供公式，它将不起作用。相关地，请注意使用 rlang::quos_auto_name()：vars() 函数返回一个未命名的表达式列表（技术上，quosures），但下游代码需要一个命名列表。只要你期望用户使用 vars()，这就是你需要的所有预处理，但如果你想支持其他输入格式，你需要更花哨一些（你可以通过查看 ggplot2 源代码来看如何做到这一点）。\n无论如何，我们现在有一个工作分面：\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  facet_scatter(vars(manufacturer), nrow = 5, ncol = 6)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "top50en.html",
    "href": "top50en.html",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "5.1 Correlation\nThe following plots help to examine how well correlated two variables are.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#correlation",
    "href": "top50en.html#correlation",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "5.1.1 Scatterplot\nThe most frequently used plot for data analysis is undoubtedly the scatterplot. Whenever you want to understand the nature of relationship between two variables, invariably the first choice is the scatterplot.\n\ntheme_set(theme_bw())\noptions(scipen = 999)\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n\n\n5.1.2 Scatterplot With Encircling\nWhen presenting the results, sometimes I would encirlce certain special group of points or region in the chart so as to draw the attention to those peculiar cases. This can be conveniently done using the geom_encircle() in ggalt package.\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n\n\n5.1.3 Counts Chart\nThe second option to overcome the problem of data points overlap is to use what is called a counts chart. Whereever there is more points overlap, the size of the circle gets bigger.\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n\n\n5.1.4 Bubble plot\nWhile scatterplot lets you compare the relationship between 2 continuous variables, bubble chart serves well if you want to understand relationship within the underlying groups based on:\nA Categorical variable (by changing the color) and Another continuous variable (by changing the size of points). In simpler words, bubble charts are more suitable if you have 4-Dimensional data where two of them are numeric (X and Y) and one other categorical (color) and another numeric variable (size).\nThe bubble chart clearly distinguishes the range of displ between the manufacturers and how the slope of lines-of-best-fit varies, providing a better visual comparison between the groups.\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n\n\n5.1.5 Marginal Histogram / Boxplot\nIf you want to show the relationship as well as the distribution in the same chart, use the marginal histogram. It has a histogram of the X and Y variables at the margins of the scatterplot.\nThis can be implemented using the ggMarginal() function from the ggExtra package. Apart from a histogram, you could choose to draw a marginal boxplot or density plot by setting the respective type option.\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#deviation",
    "href": "top50en.html#deviation",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "5.2 Deviation",
    "text": "5.2 Deviation\nCompare variation in values between small number of items (or categories) with respect to a fixed reference.\n\n5.2.1 Diverging bars\nDiverging Bars is a bar chart that can handle both negative and positive values. This can be implemented by a smart tweak with geom_bar(). But the usage of geom_bar() can be quite confusing. Thats because, it can be used to make a bar chart as well as a histogram. Let me explain.\nBy default, geom_bar() has the stat set to count. That means, when you provide just a continuous X variable (and no Y variable), it tries to make a histogram out of the data.\nIn order to make a bar chart create bars instead of histogram, you need to do two things.\nSet stat=identity provide both x and y inside aes() where, x is either character or factor and y is numeric. In order to make sure you get diverging bars instead of just bars, make sure, your categorical variable has 2 categories that changes values at a certain threshold of the continuous variable. In below example, the mpg from mtcars dataset is normalised by computing the z score. Those vehicles with mpg above zero are marked green and those below are marked red.\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n5.2.2 Diverging Lollipop Chart\nLollipop chart conveys the same information as bar chart and diverging bar. Except that it looks more modern. Instead of geom_bar(), I use geom_point() and geom_segment() to get the lollipops right. Let’s draw a lollipop using the same data I prepared in the previous example of diverging bars.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n5.2.3 Diverging Dot Plot\nDot plot conveys similar information. The principles are same as what we saw in Diverging bars, except that only point are used. Below example uses the same data prepared in the diverging bars example.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#ranking",
    "href": "top50en.html#ranking",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "5.3 Ranking",
    "text": "5.3 Ranking\nUsed to compare the position or performance of multiple items with respect to each other. Actual values matters somewhat less than the ranking.\n\n5.3.1 Dot Plot\nDot plots are very similar to lollipops, but without the line and is flipped to horizontal position. It emphasizes more on the rank ordering of items with respect to actual values and how far apart are the entities with respect to each other.\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n5.3.2 Slope Chart\nSlope charts are an excellent way of comparing the positional placements between 2 points on time. At the moment, there is no builtin function to construct this. Following code serves as a pointer about how you may approach this.\n\n# Prepare data\ndf &lt;- read_csv(\"data/top50ggplot2/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n\n\n5.3.3 Dumbbell Plot\nDumbbell charts are a great tool if you wish to: 1. Visualize relative positions (like growth and decline) between two points in time. 2. Compare distance between two categories.\nIn order to get the correct ordering of the dumbbells, the Y variable should be a factor and the levels of the factor variable should be in the same order as it should appear in the plot.\n\n# Prepare data\nhealth &lt;- read.csv(\"data/top50ggplot2/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#distribution",
    "href": "top50en.html#distribution",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "5.4 Distribution",
    "text": "5.4 Distribution\nWhen you have lots and lots of data points and want to study where and how the data points are distributed.\n\n5.4.1 Tufte Boxplot\nTufte box plot, provided by ggthemes package is inspired by the works of Edward Tufte. Tufte’s Box plot is just a box plot made minimal and visually appealing.\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n\n\n5.4.2 Population Pyramid\nPopulation pyramids offer a unique way of visualizing how much population or what percentage of population fall under a certain category. The below pyramid is an excellent example of how many users are retained at each stage of a email marketing campaign funnel.\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"data/top50ggplot2/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#composition",
    "href": "top50en.html#composition",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "5.5 Composition",
    "text": "5.5 Composition\n\n5.5.1 Waffle Chart\nWaffle charts is a nice way of showing the categorical composition of the total population. Though there is no direct function, it can be articulated by smartly maneuvering the ggplot2 using geom_tile() function. The below template should help you create your own waffle.\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n\n\n5.5.2 Treemap\nTreemap is a nice way of displaying hierarchical data by using nested rectangles. The treemapify package provides the necessary functions to convert the data in desired format (treemapify) as well as draw the actual plot (ggplotify).\nIn order to create a treemap, the data must be converted to desired format using treemapify(). The important requirement is, your data must have one variable each that describes the area of the tiles, variable for fill color, variable that has the tile’s label and finally the parent group.\nOnce the data formatting is done, just call ggplotify() on the treemapified data.\n\nproglangs &lt;- read.csv(\"data/top50ggplot2/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#groups",
    "href": "top50en.html#groups",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "5.6 Groups",
    "text": "5.6 Groups\n\n5.6.1 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n\n\n5.6.2 Clusters\nIt is possible to show the distinct clusters or groups using geom_encircle(). If the dataset has multiple weak features, you can compute the principal components and draw a scatterplot using PC1 and PC2 as X and Y axis.\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50zh.html",
    "href": "top50zh.html",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "",
    "text": "6.1 相关 Correlation\n下面的图形帮助解释两个变量之间的相关性。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#相关-correlation",
    "href": "top50zh.html#相关-correlation",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "",
    "text": "6.1.1 点图 Scatterplot\n最常使用的数据分析图无疑是散点图。每当您想了解两个变量之间的关系时，第一个选择就是散点图。\n\ntheme_set(theme_bw())\noptions(scipen = 999) # 关闭科学计数显示\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n\n\n6.1.2 有圈点图 Scatterplot With Encircling\n在展示结果时，有时会在图表中强调某些特殊点组成的区域，以引起人们对这些特殊情况的注意。使用 ggalt 软件包中的geom_encircle()可以很方便地做到这一点。\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n\n\n6.1.3 计数图 Counts Chart\n当数据点重叠时，散点图可能无法清楚地显示数据，因此可以使用计数图。在计数图中，数据点重叠越多的地方会显示一更大的圆。\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n\n\n6.1.4 气泡图 Bubble plot\n散点图可以比较两个连续变量之间的关系，而气泡图则可以很好地帮助理解一个分类变量（通过改变颜色）和另一个连续变量（通过改变点的大小）的基础组内关系。简单地说，如果您有四维数据，其中两个是 X 和 Y（连续变量），另两个是表示颜色（分类变量）和大小（连续变量）的变量，那么气泡图就比较适合。\n气泡图可以清楚地区分不同制造商之间的displ范围以及最佳拟合直线斜率的变化情况，从而更好地对各组数据进行直观比较。\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n\n\n6.1.5 边际直方图 Marginal Histogram / Boxplot\n如果想在同一张图表中显示关系和分布，可以使用边际直方图。它在散点图的边缘显示 X 和 Y 变量的直方图。\n可以使用 ggExtra 软件包中的 ggMarginal() 函数来实现。除了直方图，您还可以通过设置相应的类型选项来绘制边际盒状图或密度图。\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#偏差-deviation",
    "href": "top50zh.html#偏差-deviation",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "6.2 偏差 Deviation",
    "text": "6.2 偏差 Deviation\n比较少量项目（或类别）之间相对于固定参照物的数值变化。\n\n6.2.1 发散型条形图 Diverging bars\n发散条形图是一种可以处理负值和正值的条形图。可以通过对 geom_bar()进行巧妙的调整来实现。但是，“geom_bar()”的用法可能相当令人困惑。这是因为它既可以用来制作柱状图，也可以用来制作直方图。让我来解释一下。\n默认情况下，geom_bar() 的统计量为计数。这意味着，当你只提供一个连续的 X 变量（而没有 Y 变量）时，它会尝试将数据制成柱状图。为了让条形图创建条形而不是直方图，需要做两件事。\n在 “aes()”中设置 “stat=identity”，同时提供 x 和 y，其中 x 是字符或因子，y 是数字。为了确保得到的是发散条形图而不是单纯的条形图，请确保您的分类变量有两个类别，其值在连续变量的某个阈值时会发生变化。在下面的示例中，mtcars 数据集中的 mpg 通过计算 z 分数进行归一化。mpg高于零的车辆标记为绿色，低于零的标记为红色。\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n6.2.2 发散型棒棒糖图 Diverging Lollipop Chart\n棒棒糖图传达的信息与柱状图和发散柱状图相同。只不过它看起来更现代。我没有使用 geom_bar()，而是使用了 geom_point() 和 geom_segment() 来正确绘制棒棒糖图。让我们用上一个发散条形图示例中的相同数据来画一个棒棒糖图。\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n6.2.3 发散型点图 Diverging Dot Plot\n点图也能传递类似的信息。其原理与我们在发散条形图中看到的相同，只是只使用了点。下面的示例使用了发散条形图示例中的相同数据。\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#排序-ranking",
    "href": "top50zh.html#排序-ranking",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "6.3 排序 Ranking",
    "text": "6.3 排序 Ranking\n用于比较多个变量之间的的排位。在排序中，变量实际值的重要性会显得没有他们的排位重要。\n\n6.3.1 点图 Dot Plot\n点图与棒棒糖图非常相似，但没有线段，且翻转到水平位置。它更强调变量实际值的排序，以及不同变量与起始位置之间的距离。\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n6.3.2 坡度图 Slope Chart\n坡度图提供了比较两点在不同时间上的位置的极佳方法。目前，还没有内置函数来构建这种图表。下面的代码可作为您如何处理这一问题的指南。\n\n# Prepare data\ndf &lt;- read_csv(\"data/top50ggplot2/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n\n\n6.3.3 哑铃图 Dumbbell Plot\n哑铃图是一个针对以下问题的很好的数据可视化工具：\n\n直观显示两个时间点之间的相对位置（如增长和下降）。\n比较两个类别变量之间的距离。\n\n为了获得正确的哑铃图排序，Y 变量应该是一个因子类型的数据，因子变量的水平应该与它在图中出现的顺序相同。\n\n# Prepare data\nhealth &lt;- read.csv(\"data/top50ggplot2/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#分布-distribution",
    "href": "top50zh.html#分布-distribution",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "6.4 分布 Distribution",
    "text": "6.4 分布 Distribution\n当你有大量的数据点，并且想研究数据点在哪里以及如何分布时。\n\n6.4.1 Tufte Boxplot\n由 ggthemes 软件包提供的 Tufte 方框图灵感来自 Edward Tufte 的作品。Tufte 的盒状图只是一个盒状图，它的设计简约而具有视觉吸引力。\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n\n\n6.4.2 人口金字塔 Population Pyramid\n人口金字塔提供了一种独特的方式，可以直观地显示有多少人口或多大比例的人口属于某个类别。下面的金字塔就是一个很好的例子，说明在电子邮件营销活动中的每个阶段有多少用户被留住。\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"data/top50ggplot2/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#组成-composition",
    "href": "top50zh.html#组成-composition",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "6.5 组成 Composition",
    "text": "6.5 组成 Composition\n\n6.5.1 华夫图 Waffle Chart\n华夫图是显示总人口分类组成的一种好方法。虽然没有直接的函数，但可以通过使用 geom_tile() 函数巧妙地操纵 ggplot2 来实现。下面的模板可以帮助你创建自己的华夫图。\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n\n\n6.5.2 树形图 Treemap\n树形图是一种通过嵌套矩形显示分层数据的好方法。treemapify 软件包提供了将数据转换为所需格式（treemapify）以及绘制实际图形（ggplotify）的必要函数。\n要创建树形图，必须使用 treemapify() 将数据转换为所需格式。您的数据必须分别包含一个变量，用于描述瓦片的面积、填充颜色、瓦片标签以及父组。\n数据格式化完成后，只需在树状地图数据上调用 ggplotify()。\n\nproglangs &lt;- read.csv(\"data/top50ggplot2/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#分组-groups",
    "href": "top50zh.html#分组-groups",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "6.6 分组 Groups",
    "text": "6.6 分组 Groups\n\n6.6.1 分层树枝图 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n\n\n6.6.2 聚类 Clusters\n可以使用 geom_encircle()来显示不同的聚类或分组。如果数据集具有多个弱特征，可以计算主成分，并以 PC1 和 PC2 为 X 轴和 Y 轴绘制散点图。\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  }
]
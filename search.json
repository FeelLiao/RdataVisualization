[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R语言数据可视化学习笔记",
    "section": "",
    "text": "欢迎\n欢迎来到R语言数据可视化的学习笔记，本项目主要记录了我在学习使用R语言ggplot2包进行数据可视化时的一些思考和代码。\nggplot2 是 R 语言中一个用于创建高质量图形和图表的强大包。它是基于“图形语法”（Grammar of Graphics）理论构建的，提供了一种灵活且一致的方式来描述和构建各种复杂的图形。ggplot2 的核心思想是将图形分解为多个组成部分，包括数据 (data)、映射（aes）、几何对象（geom）、统计变换（stat）、刻度（scale）和主题（theme）等。通过组合这些组件，用户可以轻松地创建从简单的散点图和柱状图到复杂的分层图形和地图等多种类型的图表。目前，ggplot2已经形成强大的拓展生态系统，可以利用ggplot2的扩展，轻松创建更加复杂和个性化的图形。\n笔记不会不含基础ggplot2绘图的相关知识，如果是初学者，建议先学习ggplot2: Elegant Graphics for Data Analysis (3e)。在这里，主要主要包含ggplot2的一些高级用法，包括ggplot2内部如何工作，编写ggplot2扩展的原理和利用ggplot2进行高级绘图。\n本项目旨在记录自己学习R语言数据可视化的过程，如有错误，欢迎在issue中提出。",
    "crumbs": [
      "欢迎"
    ]
  },
  {
    "objectID": "ChangeLog.html",
    "href": "ChangeLog.html",
    "title": "更新日志",
    "section": "",
    "text": "ggplot2高级\n\nggplot2内部 翻译完成 2024-12-02 2  ggplot2工作原理\nggplot2扩展 翻译完成 2024-12-05 3  编写ggplot2扩展\nggplot2扩展学习案例 英文版 2024-12-05 4  学习示例\n\nTop 50 ggplot2 Visualizations: 简单介绍了一些常用的绘图原则，以及如何组合ggplot2本身自带的函数来绘制一些高级图形，部分图形会用到ggplot2的拓展包。\n\n目前是英文版 2024-10-31 5  Top 50 ggplot2 Visualizations\n中文版已更新 2024-11-12 6  Top 50 ggplot2 可视化\n\n基础统计绘图更新\n\n曼哈顿图 2024-11-05\n分裂小提琴图 2024-11-07\n阴影条带哑铃图 2024-11-07\n\n网络相关绘图更新\n\n相关性网络图 2024-11-07",
    "crumbs": [
      "更新日志"
    ]
  },
  {
    "objectID": "ggplot2intro.html",
    "href": "ggplot2intro.html",
    "title": "1  ggplot2简介",
    "section": "",
    "text": "图层 Layers: 数据 data, 映射 mapping (美学 aesthetic), 几何对象 geom, 统计变换 stat, 位置调整 position adjustment\n标度 Scales：位置标度 position scales, 颜色标度 color scales, 大小标度 size scales, 线条标度 line scales, 形状标度 shape scales\n坐标系 coordinate system\n分面 Faceting\n主题 Themes",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2简介</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html",
    "href": "ggplot2internal.html",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "2.1 The plot method\n当从用户转为ggplot2的开发人员时，遇到挫折是很常见的，因为在 ggplot2 中，用户的交互方式与其底层工作原理截然不同。随着 ggplot2 的扩展变得越来越常见，在理解如何将的功能整合在一起上也会遇到挫折。本章将介绍 ggplot2 如何在 “幕后”工作。我们将重点放在系统的设计上，而不是其实现的技术细节，目的是让读者从概念上理解各部分是如何组合在一起的。首先，我们将概述绘制 ggplot 对象时的过程，然后深入细节，描述数据如何在整个过程中流动，并最终成为绘图中的可视化元素。\n在了解 ggplot2 的底层机制时，重要的是要认识到与绘图相关的几乎所有内容都是在打印 ggplot 对象时发生的，而不是在构建对象时发生的。例如，下面的代码中，对象 p 是绘图数据的抽象表示，如图层等。它并没有构造图像本身：\nggplot2 被设计成允许用户向图中添加新元素，而无需重新计算任何内容。这种设计的一个含义是，如果你想了解 ggplot2 的机制，你必须跟踪你的绘图是如何进入 plot()1的。你可以通过在控制台中输入 ggplot2:::plot.ggplot 来检查 ggplot 对象的打印方法，但本章我们将使用一个简化的版本。剥离到最基本的形式，ggplot2 的绘图方法与以下 ggprint() 函数的结构相同：\nggprint &lt;- function(x) {\n  data &lt;- ggplot_build(x)\n  gtable &lt;- ggplot_gtable(data)\n  grid::grid.newpage()\n  grid::grid.draw(gtable)\n  return(invisible(x))\n}\n这个函数并不处理所有可能的情况，但它足以绘制上面指定的图表：\nggprint(p)\n在我们简化的打印方法的代码中，显示了四个不同的步骤：\n这个过程揭示了 ggplot2 本身并不进行底层绘图：当创建了 gtable 对象后，它的责任就结束了。 gtable 包（实现了 gtable 类）也不进行任何绘制。 所有绘图工作都由 grid 软件包和激活的图形设备共同完成。 这是非常重要的一点，因为这意味着 ggplot2 或 ggplot2 的任何扩展都不会关心可视化输出的细枝末节。 相反，它的工作是将用户数据转换为一个或多个图形基元，如多边形、线、点等，然后将责任移交给 grid 包。\n尽管严格来说并不正确，但我们将称这个过程为渲染过程。接下来的两个部分数据将沿着渲染过程向下推进，通过 build step（Section 2.2）和 gtable step（Section 2.3），最终将图形基元的集合传给 grid 。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-plot-method",
    "href": "ggplot2internal.html#sec-plot-method",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "首先，调用 ggplot_build()，这一步会准备每个图层的数据并整理成适合绘图的标准格式。\n其次，将准备好的数据传递给 ggplot_gtable()，并将其转化为存储在 gtable 中的图形元素（我们稍后再讨论 gtable 是什么）。\n第三，在 grid 软件包的帮助下，将 gtable 对象转换为图像。\n第四，将原始 ggplot 对象隐形返回给用户。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-ggplotbuild",
    "href": "ggplot2internal.html#sec-ggplotbuild",
    "title": "2  ggplot2工作原理",
    "section": "\n2.2 The build step",
    "text": "2.2 The build step\n正如上面讨论的，ggplot_build() 接受使用公共 API 构建的声明性表示，并通过准备数据以将其转换为图形基元来增强它。\n\n2.2.1 数据准备\n数据准备的第一步是获取每个图层的相关数据，并将其转换成可预测的格式。 图层数据可以通过以下三种方式提供：自己提供数据（由 geom 的 data 参数提供），继承 ggplot() 提供的全局数据，由一个函数提供，这个函数会在行使功能时返回一个data frame。 在所有三种情况下，图层数据都是一个data frame，它将传递给绘图布局，来协调坐标系和分面。 数据首先传递到绘图坐标系，坐标系可能会改变数据（但通常不会），然后传递到分面，分面会检查数据以确定绘图中应该有多少个面板以及如何组织这些面板。在这个过程中，每一个图层的数据都会增加一列名叫 “PANEL”的数据 。 这一列数据将（必须）在整个渲染过程中保留，用于将数据的每一行链接到最终绘图中的特定面板。\n数据准备的第二步是将图层数据转换为经过计算的美学（aesthetic）值。 这包括在图层数据上评估来自 aes() 的所有美学表达式。 此外，如果没有明确给出，group美学值会从所有非连续美学值的交互中计算出来。 group美学和PANEL一样，是必须在整个处理过程中保留的特殊列。 例如，前面创建的p图只包含geom_point()指定的一个图层，在数据准备过程结束时，与该图层相关的前 10 行数据是这样的：\n\n#&gt;      x  y colour PANEL group\n#&gt; 1  1.8 29      f     1     2\n#&gt; 2  1.8 29      f     1     2\n#&gt; 3  2.0 31      f     2     2\n#&gt; 4  2.0 30      f     2     2\n#&gt; 5  2.8 26      f     1     2\n#&gt; 6  2.8 26      f     1     2\n#&gt; 7  3.1 27      f     2     2\n#&gt; 8  1.8 26      4     1     1\n#&gt; 9  1.8 25      4     1     1\n#&gt; 10 2.0 28      4     2     1\n\n\n\n\n\n\n\n这一步会在图层数据中添加两列数据：group和PANEL。PANEL列指定了哪些数据在哪一个绘图面板上（比如指定了分面变量year，该变量包含2000，2001，2008三个离散值，那么PANEL列就会保存哪些数据属于哪一年），group列指定了哪些数据属于一个组（也就是在绘图中看到的分组，比如在p中，颜色被指定为drv变量，那么group就会记录哪些数据属于哪一类drv）。\n\n\n\n\n2.2.2 数据转换\n图层数据转换为可预测的格式后，还需要进行一系列转换，直到转换为绘图所需的格式。\n该过程的第一步是对数据中的列进行标度（scale）转换。 在这一阶段，任何标度中的 trans 参数都会产生影响，所有后续的渲染都将在这一转换后进行。 这就是在标度中设置位置变换（对x和y进行变换）与在坐标系中设置位置变换效果不同的原因。 如果在标度中指定变换，则变换会在任何其他计算之前应用，但如果在坐标系中指定变换，则变换会在这些计算之后应用。 例如，我们最初绘制的p图不涉及标度变换，因此图层数据在此阶段保持不变。 前三行如下所示：\n\n#&gt;     x  y colour PANEL group\n#&gt; 1 1.8 29      f     1     2\n#&gt; 2 1.8 29      f     1     2\n#&gt; 3 2.0 31      f     2     2\n\n相反，如果我们的绘图对象是 p + scale_x_log10()，并在处理过程中检查此时的图层数据，我们就会看到 x 变量已进行了适当的转换：\n\n#&gt;       x  y colour PANEL group\n#&gt; 1 0.255 29      f     1     2\n#&gt; 2 0.255 29      f     1     2\n#&gt; 3 0.301 31      f     2     2\n\n该过程的第二步是使用位置标度（position scales 即x和y）映射位置美学 (position aesthetic)，根据所涉及的位置标度类型（连续，离散，bins），映射过程会有所不同。 对于连续位置标度（例如我们示例中使用的标度），此时会应用 oob 参数中指定的出界函数，并删除图层数据中的 NA 值。 这对 p 没有什么影响，但如果我们绘制的是 p + xlim(2, 8)，则 oob 函数 – 本例中的 scales::censor() – 会用 NA 替换 2 以下的 x 值，如下图所示：\n\n#&gt; Warning: Removed 22 rows containing non-finite values (`stat_smooth()`).\n#&gt;    x  y colour PANEL group\n#&gt; 1 NA 29      f     1     2\n#&gt; 2 NA 29      f     1     2\n#&gt; 3  2 31      f     2     2\n\n对于离散位置标度，变化则更为复杂，原始数值会与用户提供的limits参数或 breaks参数相匹配，然后转换为整型数值。 最后，对于 bins 位置标度，首先使用 breaks 参数将连续数据切成 bins，然后将每个 bin 的位置设置为其范围的中点。 在这一阶段进行映射的原因是保持数据的一致性：无论使用哪种位置标度，在 stat 和 geom 计算中看起来都是连续的。 这一点非常重要，否则离散标度的闪避和抖动等计算都会失败。\n在该过程的第三步中，数据被移交给统计变换（stat），由统计变换进行统计转换。程序如下：首先，统计变换可以检查数据并修改其参数，然后对数据进行一次性处理。接下来，按 “PANEL”和 “group”对图层数据进行拆分，并在数据重新组合之前计算统计数据。 一旦数据以新的形式重新组合，就会经过另一个美学映射过程。在这个过程中，使用 stat()（或旧的 ...var...符号）延迟计算的任何美学数据都会被添加到数据中。请注意，这就是为什么stat()表达式（包括用于在示例图p的geom_smooth()层中指定回归模型的公式）不能引用原始数据。此时，原始数据根本不存在。\n举例来说，我们可以看一下图中的第二图层，它可以产生线性回归结果。在进行统计计算之前，该图层的数据只包含坐标以及所需的 “PANEL”和 “group”列。\n\n#&gt;     x  y colour PANEL group\n#&gt; 1 1.8 29      f     1     2\n#&gt; 2 1.8 29      f     1     2\n#&gt; 3 2.0 31      f     2     2\n\n在统计计算结束后，图层数据也会相应的改变：\n\n#&gt;      x    y ymin ymax    se flipped_aes colour PANEL group\n#&gt; 1 1.80 24.3 23.1 25.6 0.625       FALSE      4     1     1\n#&gt; 2 1.86 24.2 22.9 25.4 0.612       FALSE      4     1     1\n#&gt; 3 1.92 24.0 22.8 25.2 0.598       FALSE      4     1     1\n\n此时，geom 接管了 stat 的工作（几乎）。它要做的第一件事就是检查数据、更新参数，并可能对数据进行第一次修改（与 stat 的设置相同）。这可能会对某些列进行重新参数化，例如将 x+width 改为 xmin+xmax。之后，位置调整将被应用，例如，重叠的条形图将被堆叠等。对于我们的示例图 p 来说，这一步是在图的第一层应用抖动，并对 x 和 y 坐标进行扰动：\n\n#&gt;      x    y colour PANEL group\n#&gt; 1 1.84 28.7      f     1     2\n#&gt; 2 1.77 29.1      f     1     2\n#&gt; 3 2.03 31.3      f     2     2\n\n接下来，位置标度将全部重置、重新训练并应用于图层数据。仔细想想，这绝对是必要的，因为，例如，堆叠会极大地改变其中一个坐标轴的范围。在某些情况下（例如在上面的直方图示例中），其中一个位置美学可能甚至要到统计计算之后才能获得，如果不对刻度进行重新训练，它就永远不会得到训练。\n数据转换的最后一步是训练和映射所有非位置美学，即把映射的离散或连续输入转换成图形参数，如颜色、线型、大小等。此外，还将添加地形图中的任何默认美学，以便数据现在处于地形图的可预测状态。在最后一步，在构建步骤完成之前，stat 和 facet 都有最后一次机会使用它们的 “finish_data()”方法修改数据的最终映射形式。对于绘图对象 p 来说，图层数据最终状态的前几行是这样的：\n\n#&gt;    colour    x    y PANEL group shape size fill alpha stroke\n#&gt; 1 #00BA38 1.83 29.1     1     2    19  1.5   NA    NA    0.5\n#&gt; 2 #00BA38 1.79 29.2     1     2    19  1.5   NA    NA    0.5\n#&gt; 3 #00BA38 1.99 30.7     2     2    19  1.5   NA    NA    0.5\n\n\n2.2.3 输出\nggplot_build()的返回值是一个包含ggplot_built类的列表结构。它包含计算数据以及一个Layout 对象，该对象包含转换过的坐标系和分面信息。此外，它还包含一个原始绘图对象的副本，使用经过转换的标度。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-ggplotgtable",
    "href": "ggplot2internal.html#sec-ggplotgtable",
    "title": "2  ggplot2工作原理",
    "section": "\n2.3 The gtable step",
    "text": "2.3 The gtable step\nggplot_gtable()的目的是获取 build step 的输出，并在 gtable 软件包的帮助下将其转化为可以使用grid绘制的对象。此时，负责进一步计算的主要元素是几何对象、坐标系、分面和主题。统计变换和位置调整已经不再发挥作用。\n\n2.3.1 渲染面板\n首先数据会转换成他们的图形表示，分两步进行：首先，将每个图层转换为图形对象列表（grobs）。与统计变换一样，转换是通过数据分割进行的，首先按 “PANEL”分割，然后按 “group”分割，出于性能考虑，几何对象 可能会拦截这种分割。虽然很多数据准备工作已经完成，但在这一步中，几何对象 还会对数据进行一些额外的转换，这种情况并不少见。其中最关键的部分是位置数据的转换和归一化。这是由坐标系完成的，虽然这通常只意味着根据坐标系的限制对数据进行归一化，但也可能包含更为激进的转换，如将直角坐标转换为极坐标。这样做的结果是为每个图层生成一个gList对象列表，该列表与切面布局中的每个面板相对应。之后，分面开始组装不同的面板。它首先从图层中收集每个面板的信息，包括主题相关的设置和坐标轴信息，并将所有这些合并到每个面板独立的 gList 中。然后，它会根据计算出的面板布局将所有面板排列到一个 gtable 中。对于大多数绘图来说，这很简单，因为只有一个面板，但对于使用了 facet_wrap()的绘图来说，这可能会相当复杂。在这一阶段的处理过程结束后，我们的示例图 p 看起来是这样的：\n\n\n2.3.2 添加导图\nggplot2 中有两种类型的导图：坐标轴和图例。正如我们的图 p ，此时坐标轴已经完成了渲染，并与面板组装在一起，但图例仍然缺失。渲染图例是一个复杂的过程，首先要为每个标度渲染一个图例。然后，如果美学映射允许，各个标度的图例会在每个图层之间进行组合，合并成最终的图例。最后输出的是一个 gtable，其中包含根据主题和导图生成的样式。创建完成后，会根据 legend.position主题设置将导图 gtable 添加到主 gtable 中。至此，我们的绘图示例很多方面都已完成：唯一缺少的就是标题。\n\n\n2.3.3 添加修饰\n剩下的工作就是添加标题、副标题、标题和标签，以及添加背景和页边距，这样最终的gtable就完成了。\n\n2.3.4 输出\n至此，ggplot2 已准备好移交给 grid。我们的渲染过程大致相当于下面的代码，最终结果如上所述，是一个 gtable：\n\np_built &lt;- ggplot_build(p)\np_gtable &lt;- ggplot_gtable(p_built)\n\nclass(p_gtable)\n\n#&gt; [1] \"gtable\" \"gTree\"  \"grob\"   \"gDesc\"\n\n下面的代码显示了我们的绘图 p 的 gtable：\n\np_gtable\n\n#&gt; TableGrob (13 x 15) \"layout\": 22 grobs\n#&gt;     z         cells        name                                          grob\n#&gt; 1   0 ( 1-13, 1-15)  background               rect[plot.background..rect.741]\n#&gt; 2   1 ( 8- 8, 5- 5)   panel-1-1                      gTree[panel-1.gTree.612]\n#&gt; 3   1 ( 8- 8, 9- 9)   panel-2-1                      gTree[panel-2.gTree.627]\n#&gt; 4   3 ( 6- 6, 5- 5)  axis-t-1-1                                zeroGrob[NULL]\n#&gt; 5   3 ( 6- 6, 9- 9)  axis-t-2-1                                zeroGrob[NULL]\n#&gt; 6   3 ( 9- 9, 5- 5)  axis-b-1-1           absoluteGrob[GRID.absoluteGrob.631]\n#&gt; 7   3 ( 9- 9, 9- 9)  axis-b-2-1           absoluteGrob[GRID.absoluteGrob.631]\n#&gt; 8   3 ( 8- 8, 8- 8)  axis-l-1-2                                zeroGrob[NULL]\n#&gt; 9   3 ( 8- 8, 4- 4)  axis-l-1-1           absoluteGrob[GRID.absoluteGrob.639]\n#&gt; 10  3 ( 8- 8,10-10)  axis-r-1-2                                zeroGrob[NULL]\n#&gt; 11  3 ( 8- 8, 6- 6)  axis-r-1-1                                zeroGrob[NULL]\n#&gt; 12  2 ( 7- 7, 5- 5) strip-t-1-1                                 gtable[strip]\n#&gt; 13  2 ( 7- 7, 9- 9) strip-t-2-1                                 gtable[strip]\n#&gt; 14  4 ( 5- 5, 5- 9)      xlab-t                                zeroGrob[NULL]\n#&gt; 15  5 (10-10, 5- 9)      xlab-b titleGrob[axis.title.x.bottom..titleGrob.694]\n#&gt; 16  6 ( 8- 8, 3- 3)      ylab-l   titleGrob[axis.title.y.left..titleGrob.697]\n#&gt; 17  7 ( 8- 8,11-11)      ylab-r                                zeroGrob[NULL]\n#&gt; 18  8 ( 8- 8,13-13)   guide-box                             gtable[guide-box]\n#&gt; 19  9 ( 4- 4, 5- 9)    subtitle         zeroGrob[plot.subtitle..zeroGrob.737]\n#&gt; 20 10 ( 3- 3, 5- 9)       title          titleGrob[plot.title..titleGrob.736]\n#&gt; 21 11 (11-11, 5- 9)     caption          zeroGrob[plot.caption..zeroGrob.739]\n#&gt; 22 12 ( 2- 2, 2- 2)         tag              zeroGrob[plot.tag..zeroGrob.738]\n\n正如我们所希望的那样，最终的绘图看起来与之前的完全相同：\n\ngrid::grid.newpage()\ngrid::grid.draw(p_gtable)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#sec-ggproto",
    "href": "ggplot2internal.html#sec-ggproto",
    "title": "2  ggplot2工作原理",
    "section": "\n2.4 ggproto 简介",
    "text": "2.4 ggproto 简介\nSection 2.1 到 Section 2.3 的重点是如何按顺序构建 ggplot ，而有意对执行这项工作的编程对象含糊其辞。\n所有的ggplot2对象都是使用面向对象编程的ggproto系统构建的。这是一个历史性的意外：ggplot2 最初使用 proto 进行面向对象编程，但由于 proto 系统的局限性，需要一个正式的扩展机制，这就成了一个问题。我们试图将 ggplot2 转换到其他系统（如 R6），但这种尝试是困难的，而创建一个专门针对 ggplot2 需求的面向对象系统被证明是可行的解决方案。\n如果你想编写 ggplot2 的扩展程序，了解 ggproto 面向对象编程系统是非常重要的。我们将在 Chapter 3 和 Chapter 4 中遇到 ggplot2 使用的 ggproto 对象的情况。与更著名的 R6 系统一样，ggproto 使用引用语义，允许继承和访问父类方法。虽然 ggproto 并不强制执行这些设计原则，但它们对于理解如何在 ggplot2 中使用该系统至关重要。为了说明这些概念，本节将以简化的形式介绍 ggproto 的核心机制。\n\n2.4.1 ggproto 对象\n创建一个新的ggproto对象需要使用ggproto()函数，该函数的第一个参数是新类的名称，第二个参数是新类继承的另一个ggproto对象。例如，我们可以用下面的命令创建一个ggproto对象，尽管它没有任何有用的功能：\n\nNewObject &lt;- ggproto(\n  `_class` = NULL, \n  `_inherits` = NULL\n)\n\n按照惯例，ggproto 对象使用 “UpperCamelCase”命名，每个单词都以大写字母开头。省略`_class`和`_inherits`参数的名称也是惯例，因此该命令的常规形式如下：\n\nNewObject &lt;- ggproto(NULL, NULL)\n\n如果我们打印这个对象，就会发现它确实是一个 ggproto 对象，但没有显示其他信息。\n\nNewObject \n\n&lt;ggproto object: Class gg&gt;\n\n\n\n2.4.2 创建新类\n要创建一个新的 ggproto 类，唯一需要做的是提供一个类名作为 ggproto() 的第一个参数。定义一个新类的最简单命令是这样的\n\nNewClass &lt;- ggproto(\"NewClass\", NULL)\n\nNewClass变量仍然指向一个 ggproto 对象，我们可以通过打印它来验证它是否具有所需的类名：\n\nNewClass\n\n&lt;ggproto object: Class NewClass, gg&gt;\n\n\n然而，到目前为止，我们所做的唯一一件事就是创建一个指定类的对象。NewClass对象什么也不做。要创建一个有用的 ggproto 类，我们需要在定义类时提供一个变量和方法列表。在这里，“变量”用于存储与对象相关的数据，而 “方法”则是可以使用对象中存储的数据的函数。变量和方法的构造是一样的，从用户的角度来看，它们没有什么不同。\n为了说明这一点，我们将创建一个名为 Person 的新类，用来存储和操作一个人的信息。我们可以通过向 ggproto() 函数提供名称/值对来实现这一点：\n\nPerson &lt;- ggproto(\"Person\", NULL,\n  \n  # fields                  \n  given_name = NA,\n  family_name = NA,\n  birth_date = NA,\n  \n  # methods\n  full_name = function(self, family_last = TRUE) {\n    if(family_last == TRUE) {\n      return(paste(self$given_name, self$family_name))\n    }\n    return(paste(self$family_name, self$given_name))\n  },\n  age = function(self) {\n    days_old &lt;- Sys.Date() - self$birth_date\n    floor(as.integer(days_old) / 365.25)\n  },\n  description = function(self) {\n    paste(self$full_name(), \"is\", self$age(), \"years old\")\n  }\n)\n\n现在，Person类有三个变量，分别对应人的 given_name, family_name和birth_date。它还拥有三个方法：full_name()方法是一个构造人的全名函数，使用的惯例是将给名放在前面，姓氏放在后面；age()方法以年为单位计算人的年龄；description()方法打印出人的简短描述。\n打印对象会显示与其相关的变量和方法：\n\nPerson\n\n&lt;ggproto object: Class Person, gg&gt;\n    age: function\n    birth_date: NA\n    description: function\n    family_name: NA\n    full_name: function\n    given_name: NA\n\n\nPerson这个 ggproto 对象本质上是类的模板，我们可以用它来创建单个人的特定记录（在@sec-ggproto-instances 中讨论）。如果你熟悉其他面向对象编程系统，你可能会期待一些不同的东西：通常新类的定义有一个专门的构造函数。ggproto的一个怪癖是ggproto()不会这样做：相反，类的构造函数本身就是一个对象。\n定义方法时需要注意的另一点是使用 self 作为第一个参数。这是一个特殊参数，用于让方法访问与 ggproto 对象相关的变量和方法（示例参见 Section 2.4.4）。这个参数的特殊地位在打印 ggproto 方法时显而易见：\n\nPerson$full_name\n\n&lt;ggproto method&gt;\n  &lt;Wrapper function&gt;\n    function(...) !!call2(name, !!!args)\n\n  &lt;Inner function (f)&gt;\n    function(self, family_last = TRUE) {\n    if(family_last == TRUE) {\n      return(paste(self$given_name, self$family_name))\n    }\n    return(paste(self$family_name, self$given_name))\n  }\n\n\n这个输出结果似乎有点出人意料：当我们之前定义 full_name() 时，我们只提供了作为 “内部函数”的代码。现在的情况是，ggproto() 自动将我的函数封装在一个封装函数中，该封装函数调用我的代码作为内部函数，同时确保使用了适当的 self 定义。当打印该方法时，控制台会同时显示封装函数（通常没什么意义）和内部函数。这种格式的输出出现在 Chapter 3 和 Chapter 4 中。\n\n2.4.3 创建新的实例\n既然已经定义了 Person 类，我们就可以创建该类的实例了。方法是将一个 ggproto 对象作为第二个参数传递给 ggproto()，而不在第一个参数中指定一个新的类名。例如，我们可以如下创建新对象 Thomas 和 Danielle ，它们都是 Person 类的实例：\n\nThomas &lt;- ggproto(NULL, Person,\n  given_name = \"Thomas Lin\",\n  family_name = \"Pedersen\",\n  birth_date = as.Date(\"1985/10/12\")\n)\n\nDanielle &lt;- ggproto(NULL, Person,\n  given_name = \"Danielle Jasmine\",\n  family_name = \"Navarro\",\n  birth_date = as.Date(\"1977/09/12\")\n)\n\n将 NULL 指定为第一个参数，将指示 ggproto() 不定义一个新类，而是创建第二个参数中指定类的新实例。由于 Thomas 和 Danielle 都是 Person 类的实例，它们自动继承了 age(), full_name() 和 description() 方法：\n\nThomas$description()\n\n[1] \"Thomas Lin Pedersen is 39 years old\"\n\nDanielle$description()\n\n[1] \"Danielle Jasmine Navarro is 47 years old\"\n\n\n\n2.4.4 创建子类\n在前面的示例中，我们创建了一个全新的类 Person。在实践中，你几乎永远不需要这样做：相反，你可能会使用现有的 ggproto 对象创建一个子类。为此，您可以在调用 ggproto() 时指定子类的名称及其继承对象：\n\n# define the subclass\nNewSubClass &lt;- ggproto(\"NewSubClass\", Person)\n\n# verify that this works\nNewSubClass\n\n&lt;ggproto object: Class NewSubClass, Person, gg&gt;\n    age: function\n    birth_date: NA\n    description: function\n    family_name: NA\n    full_name: function\n    given_name: NA\n    super:  &lt;ggproto object: Class Person, gg&gt;\n\n\n上面的输出显示，NewSubClass现在提供了自己的类，它继承了我们之前创建的 Person对象的所有变量和方法。但是，这个新的子类并没有添加任何新功能。\n在创建子类时，我们经常要添加新的变量或方法，并覆盖一些已有的变量或方法。例如，假设我们要将 Royalty定义为Person的子类，并添加与相关皇室成员的 rank及其统治的territory相对应的变量。由于皇室成员通常以头衔和领地而不是姓氏和名字来称呼，因此我们还需要更改 full_name() 方法的定义方式：\n\nRoyalty &lt;- ggproto(\"Royalty\", Person,\n  rank = NA,\n  territory = NA,\n  full_name = function(self) {\n    paste(self$rank, self$given_name, \"of\", self$territory)\n  }\n)\n\nRoyalty 对象现在定义了一个 Person 类的子类，它从 Person 类继承了一些变量（given_name、family_name、birth_date），并提供其他变量（rank、territory）。它从 Person 类继承了 age() 和 description() 方法，但它重写了 full_name() 方法。\n我们可以使用 ggproto() 创建 Royalty 类的实例，如下所示：\n\nVictoria &lt;- ggproto(NULL, Royalty,\n  given_name = \"Victoria\",\n  family_name = \"Hanover\",\n  rank = \"Queen\",\n  territory = \"the United Kingdom\",\n  birth_date = as.Date(\"1819/05/24\")\n)\n\n因此，当我们调用 Victoria 的 full_name() 方法时，输出结果会使用 Royalty 类中指定的方法，而不是 Person 类中定义的方法：\n\nVictoria$full_name()\n\n[1] \"Queen Victoria of the United Kingdom\"\n\n\n值得注意的是，当我们调用 description() 方法时会发生什么。该方法继承自 Person，但该方法的定义调用了 self$full_name()。尽管 description() 是在 Person 中定义的，但在此处，self 仍然指的是 Victoria，她仍然是 Royalty。这意味着继承的 description() 方法的输出将使用为子类定义的 full_name() 方法：\n\nVictoria$description()\n\n[1] \"Queen Victoria of the United Kingdom is 205 years old\"\n\n\n创建子类有时需要访问父类及其方法，我们可以借助 ggproto_parent() 函数来实现。例如，我们可以定义一个 Police子类，该子类与 Royalty子类一样包含一个 rank变量，但只将该rank用作 description()方法的一部分：\n\nPolice &lt;- ggproto(\"Police\", Person,\n  rank = NA, \n  description = function(self) {\n    paste(\n      self$rank,\n      ggproto_parent(Person, self)$description()\n    )\n  }\n)\n\n在这个例子中，Police 子类的 description() 方法被定义成明确引用 Person 父类的 description() 方法。通过使用 ggproto_parent(Person, self) 的这种方式，我们能够引用父类内的方法，同时仍然保留 self 的适当定义。和之前一样，我们将创建一个特定的实例并验证这如预期般工作：\n\nJohn &lt;- ggproto(NULL, Police,\n  given_name = \"John\",\n  family_name = \"McClane\",\n  rank = \"Detective\",\n  birth_date = as.Date(\"1955/03/19\")\n)\n\nJohn$full_name() \n\n[1] \"John McClane\"\n\nJohn$description()\n\n[1] \"Detective John McClane is 69 years old\"\n\n\n由于我们将在下文讨论的原因，ggprot_parent() 的使用在 ggplot2 源代码中并不普遍。\n\n2.4.5 ggproto 代码风格\n由于 ggproto 是一个最小化的类系统，专门为 ggplot2 设计，不涉及其他任何内容，因此我们要认识到 ggproto 在 ggplot2 中的使用方式是特定的，它存在的目的是支持 ggplot2 的扩展系统，您不太可能在编写 ggplot2 扩展以外的任何环境中遇到 ggproto。考虑到这一点，了解 ggplot2 如何使用 ggproto 是有必要的：\n\nggproto 类被有选择地使用。在 ggplot2 中并不全面使用 ggproto ，只有部分功能是基于 ggproto 的，因此不建议在您的扩展中创建全新的 ggproto 类。作为扩展开发者，您永远不需要创建全新的 ggproto 对象，而是继承 ggplot2 提供的某些 ggproto 类。Chapter 3 和 Chapter 4 将详细介绍如何做到这一点。\nggproto 类是无状态的。除了用于渲染的少数内部类之外，ggplot2 中的 ggproto 类都被认为是”无状态的”。这意味着 ggplot2 的类在它们被构建之后，它们不会改变。这打破了基于引用的类（其中的方法通常可以安全地改变对象的状态）的常见用法。在 ggplot2 中改变类的状态是不安全的。如果您的代码违反了这个原则，并在渲染过程中改变了 Stat 或 Geom 的状态，那么绘制已保存的 ggplot 对象将会影响 所有 该 Stat 或 Geom 的实例（即使那些在其他图表中使用的实例），因为它们都指向同一个 ggproto 父对象。考虑到这一点，您应该只在两种情况下指定 ggplot2 中 ggproto 对象的状态。首先，您可以在创建对象时指定状态：这是可以接受的，因为此状态应该在任何实例之间共享。其次，您可以通过在别处管理的 params 对象来指定状态。正如您将在后面看到的（参见 Section 4.2 和 Section 4.3），大多数 ggproto 类都有一个 setup_params() 方法，在那里可以检查数据并计算和存储特定的属性。\nggproto 类有简单的继承。由于 ggproto 类实例是无状态的，调用定义在其他类内部的方法，而不是显式地从该类继承，是相对安全的。这就是为什么在 ggplot2 源代码中很少调用 ggproto_parent() 函数的原因。例如，GeomErrorbar 中的 setup_params() 方法被定义为：\n\n\n    #| eval: false\n    #| #| label: ggproto_style_1\n    GeomErrorbar &lt;- ggproto(\n      # ...\n      setup_params = function(data, params) {\n        GeomLinerange$setup_params(data, params)\n      }\n      # ...\n    )\n\n这种模式通常比使用 ggproto_parent() 更易读，而且因为 ggproto 对象是无状态的，所以也同样安全。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2internal.html#footnotes",
    "href": "ggplot2internal.html#footnotes",
    "title": "2  ggplot2工作原理",
    "section": "",
    "text": "你通常不会直接调用这个 plot() 方法，因为它是由打印方法调用的，因此每当打印 ggplot 对象时都会调用它。↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ggplot2工作原理</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html",
    "href": "ggplot2extend.html",
    "title": "3  编写ggplot2扩展",
    "section": "",
    "text": "4 扩展 ggplot2\nggplot2 包的设计使其能够相对容易的通过通用语法组件来构建新的绘图类型，以扩展其功能。ggplot2 允许拓展开发者将其拓展作为包进行分发，拓展的易制作性也使编写一次性拓展来解决特定的绘图问题成为可能。本章讨论了编写 ggplot2 拓展的不同方式，并强调了需要注意的特定问题。我们将在整章中提供小示例，但要从头到尾查看一个完整的示例，请参见 Chapter 4。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新主题-new-themes",
    "href": "ggplot2extend.html#新主题-new-themes",
    "title": "3  编写ggplot2扩展",
    "section": "\n4.1 新主题 New themes",
    "text": "4.1 新主题 New themes\n\n4.1.1 修改主题\n主题可能是最简单的拓展形式，它们只需要使用在 ggplot2 创建图表时会使用的代码。虽然可以从零开始构建新主题，但通常修改现有主题更简单且不易出错。ggplot2 源代码中通常采用这种方法。例如，这是 theme_minimal() 的源代码：\n\ntheme_minimal &lt;- function(base_size = 11, \n                          base_family = \"\", \n                          base_line_size = base_size/22, \n                          base_rect_size = base_size/22) {\n    theme_bw(\n      base_size = base_size, \n      base_family = base_family, \n      base_line_size = base_line_size, \n      base_rect_size = base_rect_size\n    ) %+replace% \n    theme(\n      axis.ticks = element_blank(), \n      legend.background = element_blank(), \n      legend.key = element_blank(), \n      panel.background = element_blank(), \n      panel.border = element_blank(), \n      strip.background = element_blank(), \n      plot.background = element_blank(), \n      complete = TRUE\n    )\n}\n\n如你所见，代码与在为图表添加样式时写的代码没有太大不同。theme_minimal() 函数使用 theme_bw() 作为基础主题，然后使用 %+replace% 运算符替换了其中某些参数的值。在创建新主题时，为用户提供一些参数来自定义主题是比较好的做法，比如文本、线条的粗细和主题辅助颜色等。例如，我们可以创建一个 theme_minimal() 的变体，允许用户指定图表的背景颜色：\ntheme_background &lt;- function(background = \"white\", ...) {\n  theme_minimal(...) %+replace%\n    theme(\n      plot.background = element_rect(\n        fill = background,\n        colour = background\n      ),\n      complete = TRUE\n    )\n}\n\nbase &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()\nbase + theme_minimal(base_size = 14)\nbase + theme_background(base_size = 14)\nbase + theme_background(base_size = 14, background = \"grey70\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.1.2 完整的主题\n需要注意的是， theme_minimal() 和 theme_background() 的代码中 complete = TRUE 的使用。在创建自己的 ggplot2 主题时，complete = TRUE将确保你的主题的行为与默认主题相同，因此不太可能让用户很惊讶。为了理解为什么这是必要的，比较这两个主题：\n\n# good \ntheme_predictable &lt;- function(...) {\n  theme_classic(...) %+replace% \n    theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\"),\n      complete = TRUE\n    )\n}\n\n# bad\ntheme_surprising &lt;- function(...) {\n  theme_classic(...) %+replace% \n    theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\")\n    )\n}\n\n两个主题都打算做同一件事：更改默认的 theme_classic()主题，以便 x 轴用蓝色线条绘制，y 轴用橙色线条绘制。乍一看，两个版本似乎都符合用户期望：\nbase + theme_classic()\nbase + theme_predictable()\nbase + theme_surprising()\n\n\n\n\n\n\n\n\n\n\n\n\n\n然而，假设你的主题用户想要移除轴线条：\nbase + theme_classic() + theme(axis.line = element_blank())\nbase + theme_predictable() + theme(axis.line = element_blank())\nbase + theme_surprising() + theme(axis.line = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\ntheme_predictable() 的行为与 theme_classic() 相同，轴线条被移除，但对于 theme_surprising() 则不是这样。原因是 ggplot2 将完整主题视为可以重写特定值：当用户向完整主题添加 theme(axis.line = element_blank()) 时，就会重写 axis.line.x 或 axis.line.y 的值，因为他们的值是从用户命令中的 axis.line 继承的。这对用户来说是好事，因为它允许用户使用像 theme_predictable() + theme(axis.line = ...) 这样的命令覆盖所有从 axis.line 继承的内容。相比之下，theme_surprising() 没有指定一个完整主题。当用户调用 theme_surprising() 时，ggplot2 将设置 axis.line.x 和 axis.line.y 的 theme() 命令完全视为用户输入的命令。因此，图表规范等效于此：\n\nbase + \n  theme_classic() +\n  theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\"),\n      axis.line = element_blank()\n  )\n\n\n\n\n\n\n\n在这段代码中，特定优先继承规则适用，因此设置 axis.line 不会覆盖更具体的 axis.line.x。\n\n4.1.3 定义主题元素\nggplot2 主题的结构由元素树定义。元素树指定了每个主题元素的类型以及它从哪里继承其值（你可以使用 get_element_tree() 函数将此树作为列表返回）。ggplot2 的扩展系统允许你通过使用 register_theme_elements() 函数将新主题元素注册为元素树的一部分来定义新主题元素。假设你正在编写一个名为 “ggxyz” 的新包，它包括为坐标系统一部分的面板注释，你希望这个面板注释成为一个主题元素：\n\nregister_theme_elements(\n  ggxyz.panel.annotation = element_text(\n    color = \"blue\", \n    hjust = 0.95, \n    vjust = 0.05\n  ),\n  element_tree = list(\n    ggxyz.panel.annotation = el_def(\n      class = \"element_text\", \n      inherit = \"text\"\n    )\n  )\n)\n\n在包中定义新主题元素时要注意两点：\n\n从包的 .onLoad() 函数中调用 register_theme_elements()，以便新主题元素对使用包中函数的任何人都可用，无论包是否已附加。\n在任何新主题元素前包含你的包的名称作为前缀。这样，如果有人写了另一个面板注释包 ggabc，就不会有主题元素 ggxyz.panel.annotation 和 ggabc.panel.annotation 之间的潜在冲突。\n\n元素树更新后，就可以定义一个使用新主题元素的新坐标系统。一个简单的方法是定义一个新的 CoordCartesian ggproto 对象函数。我们将在 Section 4.4 中更多地讨论这一点，但现在只需知道这段代码有效：\n\ncoord_annotate &lt;- function(label = \"panel annotation\") {\n  ggproto(NULL, CoordCartesian,\n          limits = list(x = NULL, y = NULL),\n          expand = TRUE,\n          default = FALSE,\n          clip = \"on\",\n          render_fg = function(panel_params, theme) {\n            element_render(\n              theme = theme, \n              element = \"ggxyz.panel.annotation\", \n              label = label\n            )\n          }\n  )\n}\n\n接着可以有如下代码：\nbase + coord_annotate(\"annotation in blue\")\nbase + coord_annotate(\"annotation in blue\") + theme_dark()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n修改了元素树后，可以使用 reset_theme_settings() 函数来恢复默认元素树，丢弃所有新元素定义，并将当前激活的主题重置为默认。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-stats",
    "href": "ggplot2extend.html#sec-new-stats",
    "title": "3  编写ggplot2扩展",
    "section": "\n4.2 新统计变换",
    "text": "4.2 新统计变换\n创建新统计变换是扩展 ggplot2 功能最有用的方式之一。当用户向图表添加新图层时，他们通常使用 geom 函数，因此作为开发人员，你可能会认为你的 ggplot2 扩展应该封装为一个新的 geom。这在一定程度上是正确的，因为你的用户可能会想要使用 geom 函数，但实际上不同 geoms 之间的多样性主要是由不同的统计变换决定的。使用统计变换的好处之一是它们纯粹是关于数据的转换。大多数 R 用户和开发人员对数据转换非常熟悉，这使得定义新统计变得很容易。只要所需的功能可以封装在一个统计中，就无需对任何 grid 调用进行调整。\n\n4.2.1 创建统计变换\n就像在 Chapter 2 中讨论的一样，统计变换的核心是对三个函数 compute_layer()、compute_panel() 和 compute_group()的调用，这三个函数都是 ggproto 对象定义的统计变换方法。默认情况下，前两个函数不执行太多操作，它们只是将数据按照下面的方式进行传递：\n\n\ncompute_layer() 按 PANEL 列拆分数据，随后调用 compute_panel()，并重新组装结果。\n\ncompute_panel() 将传递的数据按 group 列拆分，随后调用 compute_group()，并重新组装结果。\n\n作为开发人员，你通常只需要指定 compute_group() 函数，其作用是获取单个组的数据并按要求进行转换。这就足以创建一个能够正常工作的统计变换，尽管在性能上可能有所欠缺。有时将一些统计变换工作转移到 compute_panel() 上来是有价值的：这样做可以加速计算过程，避免费时的拆分-组合步骤（我们将在 Section 4.2 中看到一个这样的例子）。然而，通常情况下，最好先仅使用compute_group()函数，看看性能是否足够。\n为了说明这一点，我们创建了一个计算一组点的凸包统计变换，使用 grDevices 包中的 chull() 函数。正如你看到的，大部分工作是由我们创建的新 ggproto 对象完成的：\n\nStatChull &lt;- ggproto(\"StatChull\", Stat,\n  compute_group = function(data, scales) {\n    data[chull(data$x, data$y), , drop = FALSE]\n  },\n  required_aes = c(\"x\", \"y\")\n)\n\n正如在 Section 2.4 中所述，ggproto() 的前两个参数用于指定新对象的名称和父类（这里新对象命名为 \"StatChull\"），它从 Stat 对象继承属性和方法，我们只需要重写 Stat 类中提供的属性和方法，即 compute_group() 和 required_aes。我们的 compute_group() 函数接受两个输入，data 和 scales（这是 ggplot2 规定的），但实际计算仅依赖于 data。请注意，由于计算过程必须同时存在两个位置美学（x和y），我们还指定了 required_aes 属性，以确保 ggplot2 知道这些美学是必需的。\n创建这个 ggproto 对象，我们就有一个可以工作的统计变换了，但我们还没有给用户提供访问它的方式。为了解决这个问题，我们编写了一个图层函数 stat_chull()。所有图层函数都有相同的形式：在函数参数中指定默认值，然后调用 layer()，将 ... 传递到 params 参数中。... 中的参数将是 geom，stat 或 aes 的参数。\n\nstat_chull &lt;- function(mapping = NULL, data = NULL, \n                       geom = \"polygon\", position = \"identity\", \n                       na.rm = FALSE, show.legend = NA, \n                       inherit.aes = TRUE, ...) {\n  layer(\n    stat = StatChull, \n    data = data, \n    mapping = mapping, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n现在我们的统计变换就可以在图表中使用：\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  stat_chull(fill = NA, colour = \"black\")\n\nggplot(mpg, aes(displ, hwy, colour = drv)) + \n  geom_point() + \n  stat_chull(fill = NA)\n\n\n\n\n\n\n\n\n\n\n创建新统计变换时，提供相应的 geom_*() 构造函数以及 stat_*() 构造函数是一个好习惯，因为大多数用户习惯于使用 geoms 而不是统计变换来添加图层。我们将在 Section 4.3 中展示一个 geom_chull() 函数是什么样子的。\n请注意，并不总是能够以有意义的方式定义 geom_*() 构造函数。当没有明显的默认 geom 用于新的统计变换，或者统计变换旨在轻微修改现有的 geom/stat 时，这种情况就会发生。在这种情况下，明智的做法是只提供 stat_*() 构造函数。\n\n4.2.2 修改参数和数据\n在定义新统计变换时，通常需要重写 setup_params() 和/或 setup_data() 函数。这些函数在 compute_*() 函数之前被调用，它们允许在统计变换之前根据其他参数对数据进行调整（特别是数据）：\n\nsetup_params() 函数首先被调用。它接受两个参数，分别对应图层的 data 和在统计变换中指定的参数列表（params），并返回会在后续计算中使用的经过修改的参数列表。这里的参数会被 compute_*() 函数使用，因此修改后的参数列表应与 compute_*() 函数中的参数对应以便可用。\nsetup_data() 函数其次被调用。它也接受 data 和 params 作为输入（尽管它接收的参数是 setup_params() 返回的修改后的参数），并返回修改后的图层数据。重要的是，无论在 setup_data() 中发生什么修改，PANEL 和 group 列都必须保持不变。\n\n以下示例展示了如何使用 setup_params() 方法定义新的统计变换。修改 setup_data() 方法的示例稍后会包含在 Section 4.3.2 中。\n假设我们想要创建一个统计变换 StatDensityCommon，它将数据分组后计算变量的密度估计，并估计所有组的默认宽度。这可以通过许多不同的方式完成，为了简单起见，我们假设我们有一个 common_bandwidth() 函数，它使用 bw.nrd0() 函数为每个组分别估计宽度，然后返回平均值：\n\ncommon_bandwidth &lt;- function(data) {\n  split_data &lt;- split(data$x, data$group)\n  bandwidth &lt;- mean(vapply(split_data, bw.nrd0, numeric(1)))\n  return(bandwidth)\n}\n\n我们希望 StatDensityCommon 使用 common_bandwith() 函数，在数据被分组并传递给 compute_group() 函数之前设置一个共同的宽度。这就是 setup_params() 函数的用途：\n\nStatDensityCommon &lt;- ggproto(\"StatDensityCommon\", Stat,\n  required_aes = \"x\",\n  \n  setup_params = function(data, params) {\n    if(is.null(params$bandwith)) {\n      params$bandwidth &lt;- common_bandwidth(data)\n      message(\"Picking bandwidth of \", signif(params$bandwidth, 3))\n    }\n    return(params)\n  },\n    \n  compute_group = function(data, scales, bandwidth = 1) {\n    d &lt;- density(data$x, bw = bandwidth)\n    return(data.frame(x = d$x, y = d$y))\n  }  \n)\n\n然后我们用一般的方式定义 stat_*() 函数：\n\nstat_density_common &lt;- function(mapping = NULL, data = NULL, \n                                geom = \"line\", position = \"identity\", \n                                na.rm = FALSE, show.legend = NA, \n                                inherit.aes = TRUE, bandwidth = NULL, ...) {\n  layer(\n    stat = StatDensityCommon, \n    data = data, \n    mapping = mapping, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      bandwidth = bandwidth, \n      na.rm = na.rm,\n      ...\n    )\n  )\n}\n\n现在我们可以应用我们的新统计变换：\n\nggplot(mpg, aes(displ, colour = drv)) + \n  stat_density_common()\n#&gt; Picking bandwidth of 0.345",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-geoms",
    "href": "ggplot2extend.html#sec-new-geoms",
    "title": "3  编写ggplot2扩展",
    "section": "\n4.3 新 geoms",
    "text": "4.3 新 geoms\n虽然通过创建新的统计变换可以实现许多事情，但在某些情况下创建新的 geom 是必要的。这些情况包括：\n\n从统计变换返回的数据对当前任何 geoms 可以接受的数据形式都是没有意义的。\n图层需要组合多个 geoms 的输出。\ngeom 需要返回的 grobs 是现有 geoms 所没有的。\n\n创建新的 geoms 可能比创建新的统计变换看起来有些令人生畏，因为最终结果是一个 grobs 集合而不是一个修改后的数据框，这对许多开发人员来说不是一个熟悉的领域。尽管如此，除了上述最后一点，你还是可以尝试仅使用统计变换。\n\n4.3.1 修改 geom 默认值\n在许多情况下，你的新 geom 可能只是期望一个稍微不同的输入或具有不同默认参数值的现有 geom。前一节中的 stat_chull() 示例是一个很好的例子。注意，在使用 stat_chull() 创建图表时，我们必须手动指定 fill 和 colour 参数，如果它们没有映射到美学上，则不符合我们凸包 geom 的默认值。为了容易的实现这一点，我们可以创建一个 GeomPolygon 的子类，修改默认值，以便它可以产生一个空心多边形。我们可以通过覆盖 default_aes 值直接实现这一点：\n\nGeomPolygonHollow &lt;- ggproto(\"GeomPolygonHollow\", GeomPolygon,\n  default_aes = aes(\n    colour = \"black\", \n    fill = NA, \n    linewidth = 0.5,\n    linetype = 1,\n    alpha = NA\n  )\n)\n\n现在可以使用 GeomPolygonHollow 类作为默认 geom 来定义我们的 geom_chull() 构造函数：\n\ngeom_chull &lt;- function(mapping = NULL, data = NULL, stat = \"chull\",\n                       position = \"identity\", na.rm = FALSE, \n                       show.legend = NA, inherit.aes = TRUE, ...) {\n  layer(\n    geom = GeomPolygonHollow, \n    data = data, \n    mapping = mapping, \n    stat = stat, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes,\n    params = list(na.rm = na.rm, ...)\n  )\n} \n\n为了一致性，我们还可以定义 stat_chull() ，并使用这个类作为默认值。无论如何，我们现在有一个新的 geom_chull() 函数，它工作得很好，不需要用户设置参数：\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_chull() +\n  geom_point()\n\n\n\n\n\n\n\n\n4.3.2 修改 geom 数据\n在其他情况下，你可能想要定义一个 geom，它等同于现有的 geom，但接受不同格式的数据。ggplot2 源代码中的一个示例是 geom_spoke()，这是 geom_segment() 的一个变体，它接受极坐标数据。为了使这工作，GeomSpoke ggproto 类从 GeomSegment 继承，并使用 setup_data() 函数来获取用户的极坐标数据，然后将其转换为 GeomSegment 期望的格式。为了说明这一点，我们将创建 geom_spike()，一个 geom，它重新实现了 geom_spoke() 的功能。这需要我们重写 required_aes 属性以及 setup_data() 函数：\n\nGeomSpike &lt;- ggproto(\"GeomSpike\", GeomSegment,\n  \n  # 指定所需的美学                   \n  required_aes = c(\"x\", \"y\", \"angle\", \"radius\"),\n  \n  # 在任何绘图发生之前转换数据\n  setup_data = function(data, params) {\n    transform(data,\n      xend = x + cos(angle) * radius,\n      yend = y + sin(angle) * radius\n    )\n  }\n)\n\n我们现在编写面向用户的 geom_spike() 函数：\n\ngeom_spike &lt;- function(mapping = NULL, data = NULL, \n                       stat = \"identity\", position = \"identity\", \n                       ..., na.rm = FALSE, show.legend = NA, \n                       inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    geom = GeomSpike, \n    stat = stat, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n我们现在可以在图表中使用 geom_spike() ：\n\ndf &lt;- data.frame(\n  x = 1:10,\n  y = 0,\n  angle = seq(from = 0, to = 2 * pi, length.out = 10),\n  radius = seq(from = 0, to = 2, length.out = 10)\n)\nggplot(df, aes(x, y)) +\n  geom_spike(aes(angle = angle, radius = radius)) + \n  coord_equal()\n\n\n\n\n\n\n\n如统计变换一样，geoms 也有 setup_params() 函数以及 setup_data() 函数，可以用来在绘图之前修改参数（见 Section 4.2.2 示例）。然而，在 geom 中，有一点需要注意，setup_data() 在任何位置调整（对x和y的修改）之前被调用。\n\n4.3.3 组合多个 geoms\n定义新 geom 的一个作用是组合不同 geom 的功能。例如，geom_smooth() 函数用于绘制非参数的回归线，它使用 geom_line() 的功能来绘制回归线，并使用 geom_ribbon() 来绘制阴影误差带。要在新 geom 中实现这一点，通常需要考虑绘图过程来完成。就像统计变换通过调用 compute_layer() 、 compute_panel() 和 compute_group() 来构建一样，geom 通过调用 draw_layer()、draw_panel() 和 draw_group() 来构建。\n如果你想组合多个 geom 的功能，可以用 draw_*() 函数来准备每个 geom 的数据并将其发送到对应的 geom 来实现，当有很多 grob 时使用 grid::gList() 来收集，如果是带有子项的单个 grob ，则使用 grid::gTree()来收集。作为一个相对简单的例子，考虑 GeomBarbell ggproto 类，它创建一个由两组点连成线的 geom：\n\nGeomBarbell &lt;- ggproto(\"GeomBarbell\", Geom,\n  \n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  \n  default_aes = aes(\n    colour = \"black\",\n    linewidth = .5,\n    size = 2,\n    linetype = 1,\n    shape = 19,\n    fill = NA,\n    alpha = NA,\n    stroke = 1\n  ),\n  \n  draw_panel = function(data, panel_params, coord, ...) {\n    \n    # 点的转换数据\n    point1 &lt;- transform(data) \n    point2 &lt;- transform(data, x = xend, y = yend)    \n    \n    # 返回所有三个组件\n    grid::gList(\n      GeomSegment$draw_panel(data, panel_params, coord, ...),\n      GeomPoint$draw_panel(point1, panel_params, coord, ...),\n      GeomPoint$draw_panel(point2, panel_params, coord, ...)\n    )\n  }\n) \n\n在这个例子中，draw_panel() 方法返回一个列表，包含三个 grobs ，一个来自 GeomSegment，两个来自 GeomPoint。像往常一样，如果我们希望 geom 对用户可见，我们添加一个构造函数：\n\ngeom_barbell &lt;- function(mapping = NULL, data = NULL, \n                         stat = \"identity\", position = \"identity\", \n                         ..., na.rm = FALSE, show.legend = NA, \n                         inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomBarbell, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\n现在我们可以使用这个组合的 geom：\ndf &lt;- data.frame(x = 1:10, xend = 0:9, y = 0, yend = 1:10)\nbase &lt;- ggplot(df, aes(x, y, xend = xend, yend = yend))\n\nbase + geom_barbell()\nbase + geom_barbell(shape = 4, linetype = \"dashed\")  \n\n\n\n\n\n\n\n\n\n\n如果你不能利用现有的任何 geom 实现来创建 grobs，那么你将不得不从头开始实现完整的 draw_*() 函数，这需要对 grid 包有一点了解。有关 grid 的更多信息以及使用它来从基于网格的语法构建 geom ，请参见 Chapter 4。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-coords",
    "href": "ggplot2extend.html#sec-new-coords",
    "title": "3  编写ggplot2扩展",
    "section": "\n4.4 新坐标系",
    "text": "4.4 新坐标系\n坐标系的主要作用是将位置美学（x和y）重新缩放到 [0, 1] 的范围。定义新坐标系相对罕见：在 ggplot2中默认的坐标系适用于大多数非制图案例，并且随着 coord_sf() 的引入，ggplot2 也能够开箱即用地绘制地图\n开发人员需要了解坐标系内部的最常见情况是定义新的 geom。draw_*() 函数调用坐标系的 transform() 函数并不少见。例如，CoordCartesian 的 transform() 方法用于重新缩放位置数据，但不会以其他方式转换它，geom 可能需要应用此重新缩放以正确绘制 grob。一个示例出现在 Chapter 4 中。\n除了转换位置数据外，坐标系还负责渲染轴、轴标签、面板前景和面板背景。此外，坐标系可以截获并修改图层数据和分面布局。如果有必要，这些功能大部分都可供开发人员使用（一个示例在 Section 4.1.3 中），但在大多数情况下，最好保留这些功能不变。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#sec-new-scales",
    "href": "ggplot2extend.html#sec-new-scales",
    "title": "3  编写ggplot2扩展",
    "section": "\n4.5 新标度",
    "text": "4.5 新标度\n想通过新标度扩展 ggplot2 的情况大致有三种。最简单的情况是，你想要创建新的调色板，用于颜色或填充美学。作为一个简单的例子，假设你想使用这样的调色板函数来填充小提琴图或箱形图：\n\nrandom_colours &lt;- function(n) {\n  sample(colours(distinct = TRUE), n, replace = TRUE)\n} \n\n编写一个 scale_fill_random() 构造函数，将调色板传递给 discrete_scale()，然后在图表中使用它：\n\nscale_fill_random &lt;- function(..., aesthetics = \"fill\") {\n  discrete_scale(\n    aesthetics = aesthetics, \n    scale_name = \"random\", \n    palette = random_colours\n  )\n}\n\nggplot(mpg, aes(hwy, class, fill = class)) + \n  geom_violin(show.legend = FALSE) +\n  scale_fill_random()\n\n\n\n\n\n\n\n另一个相对简单的情况是，你提供了一个 geom，它采用新的美学类型，需要进行设置。假设你创建了一个新的绘制线条的 geom，并且你决定使用 width 美学而不是 size 美学。为了使用 width美学，就像你使用 size 那样，你必须为它提供一个默认的标度。默认标度是根据其名称和提供给美学的数据类型来识别的。如果你的 width 美学是连续值，ggplot2 将寻找 scale_width_continuous() 函数，并使用它。如果找不到这样的函数（并且没有明确添加width标度），美学将不会起作用。\n还有一个值得提及的情况，但超出了这本书的范围，那就是创建一个新的标度类型。历史上，ggplot2 有两种主要的标度类型，连续和离散标度。最近，bin 标度加入其中，它允许将连续数据按组分为离散的数据。开发人员可以编写其他标度类型，方法是子类化 Scale 或默认的标度类型，并重写 train() 和 map() 函数。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新位置调整",
    "href": "ggplot2extend.html#新位置调整",
    "title": "3  编写ggplot2扩展",
    "section": "\n4.6 新位置调整",
    "text": "4.6 新位置调整\nPosition ggproto 类比其他 ggproto 类要简单一些，反映了 position_*() 函数狭窄的作用范围。位置调整的作用是在数据传递给任何绘图函数之前接收和修改数据。严格来说，位置调整可以以任何方式修改数据，但它只修改位置美学。位置调整具有 compute_layer() 和 compute_panel() 两个方法，这些方法类似于统计变换的等效方法，但它没有 compute_group() 方法。它还包含 setup_params() 和 setup_data() 方法，这些方法类似于其他 ggproto 类的 setup_*() 方法，有一个地方值得注意：setup_params() 方法只接收数据作为输入，而不是参数列表。原因是 position_*() 函数从不在 ggplot2 中单独使用：相反，它们总是在指定图层的主 geom_*() 或 stat_*() 命令中调用，主命令中的参数不会传递给 position_*() 函数调用。\n为了提供一个简单的例子，我们将实现一个简化版的 position_jitternormal() 函数，它来自 ggforce 包，其行为与 position_jitter() 相同，只不过扰动是从正态分布而不是均匀分布中采样的。为了保持论述简单，我们假设我们有以下函数定义：\n\nnormal_transformer &lt;- function(x, sd) {\n  function(x) {x + rnorm(length(x), sd = sd)}\n}\n\n当这个函数被调用时，normal_transformer() 返回一个函数，这个函数通过添加均值为零、标准差为 sd 的随机噪声来扰动输入向量。创建这个新位置调整的第一步是创建一个 Position 类的子类：\n\nPositionJitterNormal &lt;- ggproto('PositionJitterNormal', Position,\n           \n  # 我们需要一个 x 和 y 位置美学                              \n  required_aes = c('x', 'y'),\n  \n  # 通过使用 \"self\" 参数，我们可以访问用户传递给位置的参数，并将它们添加为图层参数\n  setup_params = function(self, data) {\n    list(\n      sd_x = self$sd_x, \n      sd_y = self$sd_y\n    )\n  },\n\n  # 当计算图层时，我们可以从参数列表中读取标准差参数，并使用它们来转换位置美学\n  compute_layer = function(data, params, panel) {\n    \n    # 为 x 和 y 位置尺度构建变换器 \n    x_transformer &lt;- normal_transformer(x, params$sd_x)\n    y_transformer &lt;- normal_transformer(y, params$sd_y)\n    \n    # 返回转换后的数据\n    transform_position(\n      df = data,\n      trans_x = x_transformer,  \n      trans_y = y_transformer\n    )\n  }\n)\n\ncompute_layer() 函数使用了 transform_position()，这是 ggplot2 提供的一个便利函数，其作用是将开发者定义的函数应用于所有与位置标度相关的美学值（例如，不仅仅是 x 和 y，还有 xend 和 yend）。\n在实际的开发环境中，position_jitternormal() 构造函数将进行一些输入验证，以确保用户没有指定负的标准差，简单的示例如下：\n\nposition_jitternormal &lt;- function(sd_x = .15, sd_y = .15) {\n  ggproto(NULL, PositionJitterNormal, sd_x = sd_x, sd_y = sd_y)\n}\n\n我们现在可以在创建图表时使用我们的新位置调整函数。要查看 position_jitter() 和我们刚刚定义的 position_jitternormal() 函数之间的区别，请比较以下图表：\ndf &lt;- data.frame(\n  x = sample(1:3, 1500, TRUE),\n  y = sample(1:3, 1500, TRUE)\n)\n\nggplot(df, aes(x, y)) + geom_point(position = position_jitter())\nggplot(df, aes(x, y)) + geom_point(position = position_jitternormal())\n\n\n\n\n\n\n\n\n\n\n在设计新位置调整时需要考虑的一个实际问题是，用户很少直接调用位置调整的构造函数。用户用来指定图层的命令更可能是像 position = \"dodge\" 而不是 position = position_dodge()，更不用说覆盖默认值了，就像用户指定 position = position_dodge(width = 0.9) 那样。因此，如果可能的话，要仔细思考并使默认值适用于大多数情况。这可能非常棘手：位置调整对图层数据的形状和格式几乎没有控制权，但用户将期望它们在所有情况下都可用。一个例子是 dodging，用户可能想要箱形图和点图 dodging，并期望点图出现在箱形图的相同区域。在用户层面上，这是一个完全合理的期望，但对开发人员来说可能很棘手。箱形图有一个明确的宽度，可以用来控制 dodging，而点图则不是这样，但用户期望它们以相同的方式移动。这种考虑通常意味着位置调整的最终实现比简单的解决方案要复杂得多，以照顾到更为广泛的情况。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2extend.html#新分面",
    "href": "ggplot2extend.html#新分面",
    "title": "3  编写ggplot2扩展",
    "section": "\n4.7 新分面",
    "text": "4.7 新分面\n分面是 ggplot2 中最强大的概念之一，扩展分面是修改 ggplot2 操作方式的最强大方式之一。这种力量是有代价的：分面负责接收所有面板，将轴和条带附加到它们上，然后以预期的方式排列它们。从头开始创建一个全新的分面系统需要深入了解 grid 和 gtable，可能是一个令人生畏的挑战。幸运的是，你并不总是需要从头开始创建分面。例如，如果你的新分面将产生位于网格的面板，你通常可以子类化 FacetWrap 或 FacetGrid 并修改一两个方法。特别是，你可能想要定义新的 compute_layout() 和/或 map_data() 方法：\n\ncompute_layout() 方法接收原始数据集，并创建布局规范，这是一个数据框，每行代表面板在网格上的位置，以及哪些轴限制应该是自由的，哪些应该是固定的。\nmap_data() 方法接收这个布局规范和原始数据作为输入，并将 PANEL 列 附加到它上面，用于将数据框中的每一行分配给布局中的一个面板。\n\n为了说明如何通过子类化现有分面来创建新分面，我们将创建一个相对简单的分面系统，该系统将 “分散” 面板，将它们随机放置在网格上。为此，我们将创建一个名为 FacetScatter 的新 ggproto 对象，它是 FacetWrap 的子类，并编写一个新的 compute_layout() 方法，将每个面板放置在面板网格中随机选择的位置中：\n\nFacetScatter &lt;- ggproto(\"FacetScatter\", FacetWrap,\n  \n  # 这并不重要的例子：我们所做的一切是\n  # 强制所有面板使用固定尺度，以便\n  # 其余的例子可以保持简单\n  setup_params = function(data, params) {\n    params &lt;- FacetWrap$setup_params(data, params)\n    params$free &lt;- list(x = FALSE, y = FALSE)\n    return(params)\n  },                      \n  \n  # compute_layout() 方法做工作\n  compute_layout = function(data, params) {\n                  \n    # 创建一个数据框，每个分面变量一列，\n    # 每一行代表一个可能的值组合\n    # （即，每一行一个面板）\n    panels &lt;- combine_vars(\n      data = data,\n      env = params$plot_env, \n      vars = params$facets, \n      drop = FALSE\n    )\n    \n    # 创建一个数据框，ROW 和 COL 列，\n    # 每一行代表面板网格中可能的单元格\n    locations &lt;- expand.grid(ROW = 1:params$nrow, COL = 1:params$ncol)\n    \n    # 随机抽样位置的子集\n    shuffle &lt;- sample(nrow(locations), nrow(panels))\n    \n    # 为每个面板分配一个位置                      \n    layout &lt;- data.frame(\n      PANEL = 1:nrow(panels),       # 面板标识符\n      ROW = locations$ROW[shuffle], # 面板的行号\n      COL = locations$COL[shuffle], # 面板的列号\n      SCALE_X = 1L,                 # 所有 x 轴尺度都是固定的\n      SCALE_Y = 1L                  # 所有 y 轴尺度都是固定的\n    )\n    \n    # 将布局信息与面板标识符绑定\n    # 并返回得到的规范\n    return(cbind(layout, panels))\n  }                      \n)\n\n这是在构建本节末尾显示的图表时创建的布局规范：\n\n#&gt;    PANEL ROW COL SCALE_X SCALE_Y manufacturer\n#&gt; 1      1   4   1       1       1         audi\n#&gt; 2      2   5   5       1       1    chevrolet\n#&gt; 3      3   5   1       1       1        dodge\n#&gt; 4      4   5   3       1       1         ford\n#&gt; 5      5   1   5       1       1        honda\n#&gt; 6      6   4   4       1       1      hyundai\n#&gt; 7      7   3   5       1       1         jeep\n#&gt; 8      8   2   2       1       1   land rover\n#&gt; 9      9   5   2       1       1      lincoln\n#&gt; 10    10   4   5       1       1      mercury\n#&gt; 11    11   2   4       1       1       nissan\n#&gt; 12    12   5   4       1       1      pontiac\n#&gt; 13    13   3   2       1       1       subaru\n#&gt; 14    14   5   6       1       1       toyota\n#&gt; 15    15   4   6       1       1   volkswagen\n\n接下来，我们将编写 facet_scatter() 构造函数，以将此功能暴露给用户。对于分面来说，这就像创建一个新 ggproto 对象（在这种情况下是 FacetScatter）的实例一样简单，它将用户指定的参数传递给分面：\n关于这个构造函数有几个注意事项。首先，为了保持示例简单，facet_scatter() 包含的参数比 facet_wrap() 少，我们将 nrow 和 ncol 作为必需参数：用户需要指定面板的网格的大小。其次，facet_scatter() 函数要求你使用 vars() 指定分面。如果用户尝试提供公式，它将不起作用。相关地，请注意使用 rlang::quos_auto_name()：vars() 函数返回一个未命名的表达式列表（技术上，quosures），但下游代码需要一个命名列表。如果你期望用户使用 vars()，那这就是你需要做的，但如果你想支持其他输入格式，你就还需要其他工作（你可以通过查看 ggplot2 源代码来看如何做到这一点）。\n无论如何，我们现在有一个可以工作的分面：\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  facet_scatter(vars(manufacturer), nrow = 5, ncol = 6)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>编写ggplot2扩展</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html",
    "href": "ggplot2_spring.html",
    "title": "4  学习示例",
    "section": "",
    "text": "4.1 What is a spring?\nChapter 4 provided a high-level overview of creating ggplot2 extensions, building on the discussion of ggplot2 internals in Chapter 2. In this chapter we’ll take that knowledge a step further, providing a deeper dive into the process of developing full-featured extensions. To do this, we’ll take a single example — building a new geom that looks like a spring — and follow it all the way through the development process.\nThis is a carefully crafted example. You’re unlikely to actually want to use springs to visualise your data, so ggplot2 doesn’t already provide a spring geom. However, springs are just complicated enough to illustrate the most important parts of the process. This makes them ideal for our purposes!\nWe’ll develop the extension in five phases:\nOnce you’ve worked your way through this chapter, we highly recommend browsing the ggplot2 source code to look at how other stats and geoms are implemented. They will often be more complicated than what you need, but they’ll give you a sense of the things you can do.\nDeveloping an extension usually starts with an idea of what you want to draw. In this case, we want to draw a spring between two points, so we need some code that will draw a plausible-looking spring! There are probably many ways to do this, but one simple approach is to draw a circle while moving the “pen” in one direction. Here’s a data set that defines a circle using 100 points:\ncircle &lt;- tibble(\n  radians = seq(0, 2 * pi, length.out = 100),\n  x = cos(radians),\n  y = sin(radians),\n  index = 1:100,\n  type = \"circle\"\n)\n\nggplot(circle, aes(x = x, y = y, alpha = -index)) + \n  geom_path(show.legend = FALSE) + \n  coord_equal()\nTo transform this circle into a spring that stretches along the x axis using dplyr, we might do something like this:\nspring &lt;- circle %&gt;% \n  mutate(\n    motion = seq(0, 1, length.out = 100),\n    x = x + motion,\n    type = \"spring\"\n  )\n\nggplot(spring, aes(x = x, y = y, alpha = -index)) + \n  geom_path(show.legend = FALSE) + \n  coord_equal()\nIn this case our “spring” has only looped around once – and doesn’t look much like an actual spring – but if we were to continue tracing the circle while moving along the x axis we’d end up with a spring with multiple loops. The faster we move the “pen”, the more we will stretch the spring. This gives us some insight into the two parameters that characterise our springs:\nAlthough this is probably not a physically correct parameterisation of springs in the real world, it’s good enough for our purposes.\nNow that we have a method for drawing springs, it’s worth spending a little time thinking about what a geom based on this method will require. The code we’ve written up to this point is perfectly fine for a single plot, but there are new questions to consider when creating an extension:\nWe’ll consider these questions as we work through the chapter.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html#sec-intuitive-spring",
    "href": "ggplot2_spring.html#sec-intuitive-spring",
    "title": "4  学习示例",
    "section": "",
    "text": "The diameter of the spring, defined by the size of the circle.\nThe tension of the spring, defined by how fast we move along x.\n\n\n\n\nHow will we specify the diameter of a spring?\nHow do we keep the circles circular even as we change the aspect ratio of the plot?\nCan we map diameter and tension to variables in the data?\nShould diameter and tension be parameters that must be the same for all springs in a layer or should they be scaled aesthetics that can vary from spring to spring?\nIf we plan to distribute our spring geom to other R users, do we want to depend on the dplyr package?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html#sec-spring-stat",
    "href": "ggplot2_spring.html#sec-spring-stat",
    "title": "4  学习示例",
    "section": "\n4.2 Part 1: A stat",
    "text": "4.2 Part 1: A stat\nLet’s start turning this idea into a ggplot2 extension. Because we’re creating an extension that draws a new ggplot2 layer, we need to decide whether the ggproto object we create should be a Stat or a Geom. Perhaps surprisingly, this decision isn’t guided by whether we want to end up with geom_spring() or stat_spring(): there are a lot of Stat extensions that are used via a geom_*() constructor. A better way to think about this decision is to consider if we can use an existing geom with transformed data. In that case we can use a Stat which is usually simpler to code than a Geom.\nThe code we wrote in the last section fits this description nicely. All we’re doing is drawing a path, but we’re circling around instead of going in a straight line. That suggests we can use a Stat that transforms the data and then uses GeomPath to take care of the actual drawing.\n\n4.2.1 Building functionality\nWhenever you are developing a new Stat a sensible strategy is to begin by writing the data transformation function, and then once it’s working incorporating it into a ggproto Stat. In this case, we’re going to need a create_spring() function that takes a start point, an end point, a diameter, and a tension. More precisely:\n\nOur start point will be defined by arguments x and y.\nOur end point will be defined by arguments xend and yend.\nThe diameter argument will be used to scale the size of our circle.\nDefining tension is slightly trickier. The quantity we actually want to express is “how far the spring moves relative to the size of the circles”. So we’ll define tension to refer to the total distance moved from the start point to the end point, divided by the size of the circles.1\n\nWe’ll also have a parameter n to give the number of points used per revolution, defining the visual fidelity of the spring.\n\nWe can now write code for our create_spring() function:\n\ncreate_spring &lt;- function(x, \n                          y, \n                          xend, \n                          yend, \n                          diameter = 1, \n                          tension = 0.75, \n                          n = 50) {\n  \n  # Validate the input arguments\n  if (tension &lt;= 0) {\n    rlang::abort(\"`tension` must be larger than zero.\")\n  }\n  if (diameter == 0) {\n    rlang::abort(\"`diameter` can not be zero.\")\n  }\n  if (n == 0) {\n    rlang::abort(\"`n` must be greater than zero.\")\n  }\n  \n  # Calculate the direct length of the spring path\n  length &lt;- sqrt((x - xend)^2 + (y - yend)^2)\n  \n  # Calculate the number of revolutions and points we need\n  n_revolutions &lt;- length / (diameter * tension)\n  n_points &lt;- n * n_revolutions\n  \n  # Calculate the sequence of radians and the x and y offset values\n  radians &lt;- seq(0, n_revolutions * 2 * pi, length.out = n_points)\n  x &lt;- seq(x, xend, length.out = n_points)\n  y &lt;- seq(y, yend, length.out = n_points)\n  \n  # Create and return the transformed data frame\n  data.frame(\n    x = cos(radians) * diameter/2 + x,\n    y = sin(radians) * diameter/2 + y\n  )\n}\n\nThis function preserves the logic of the spring code we wrote in Section 4.1, but it does a few new things that matter a lot when writing extensions:\n\nIt is precise in specifying the parameters that define the spring.\nIt explicitly checks the input, and uses rlang::abort() to throw an error if the user passes an invalid value to the function.\nIt uses base R functions to do the work: there is no dplyr code in this function because we don’t want our Stat to depend on dplyr.2\n\n\nOne nice thing about writing create_spring() as a function is that we can test it out3 to convince ourselves that the logic works:\n\nspring &lt;- create_spring(\n  x = 4, y = 2, xend = 10, yend = 6,\n  diameter = 2, tension = 0.6, n = 50\n)\n\nggplot(spring) + \n  geom_path(aes(x = x, y = y)) + \n  coord_equal()\n\n\n\n\n\n\n\n\n4.2.2 Creating the stat\nNow that we have our transformation function, our next task is to encapsulate it into a Stat. To do this, we’ll take what we learned about creating Stat objects in Section 4.2 and extend it a little. Our first step is to write some code that creates a subclass of Stat that we’ll call StatSpring:\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat)\n\nThis creates a new Stat subclass named StatSpring. This class doesn’t do anything interesting at this point: the only thing this code does so far is give the class a name.4 To make this useful, we’ll need to specify the methods that will build in the functionality we desire. In Section 4.2 we created a Stat by overriding the default method compute_group() and the default field for required_aes,5 but Stat objects have many properties you can modify . If we print the Stat object, we can see a list of those properties :\n\nStat\n#&gt; &lt;ggproto object: Class Stat, gg&gt;\n#&gt;     aesthetics: function\n#&gt;     compute_group: function\n#&gt;     compute_layer: function\n#&gt;     compute_panel: function\n#&gt;     default_aes: uneval\n#&gt;     dropped_aes: \n#&gt;     extra_params: na.rm\n#&gt;     finish_layer: function\n#&gt;     non_missing_aes: \n#&gt;     optional_aes: \n#&gt;     parameters: function\n#&gt;     required_aes: \n#&gt;     retransform: TRUE\n#&gt;     setup_data: function\n#&gt;     setup_params: function\n\nYou can modify almost any of these: the only ones that you shouldn’t touch are aesthetics and parameters, which are intended for internal use only.\nFor our StatSpring example, the three methods/fields that we’ll need to specify are setup_data(), compute_panel(), and required_aes. We’ll go through this in more detail in the next section, but to help you see what we’re aiming for, here’s the complete code for our stat:\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat, \n  \n  # Edit the input data to ensure the group identifiers are unique\n  setup_data = function(data, params) {\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  # Construct data for this panel by calling create_spring()\n  compute_panel = function(data, \n                           scales, \n                           diameter = 1, \n                           tension = 0.75, \n                           n = 50) {\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(\n      seq_len(nrow(data)), \n      function(i) {\n        spring_path &lt;- create_spring(\n          data$x[i], \n          data$y[i], \n          data$xend[i], \n          data$yend[i], \n          diameter = diameter, \n          tension = tension, \n          n = n\n        )\n        cbind(spring_path, unclass(data[i, cols_to_keep]))\n      }\n    )\n    do.call(rbind, springs)\n  },\n  \n  # Specify which aesthetics are required input\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\")\n)\n\nWe can print any of these methods with a command such as StatSpring$compute_panel or StatSpring$setup_data.\n\n4.2.3 Methods\nLet’s take a closer look at the methods defined for our StatSpring. As discussed in Section 4.2 the most important methods for a stat are the three compute_* methods. One of these must always be defined, usually compute_group() or compute_panel(). As a rule of thumb, if the stat operates on multiple rows we start by implementing a compute_group() method, and if the stat operates on single rows we implement a compute_panel() method. Our spring stat is the latter kind: each spring is defined by a single row of the original data, so we’ll use the compute_panel() method which receives all the data for a single panel.\nAs you can see by looking at source code for our compute_panel() method, we’re doing a bit more than simply calling our create_spring() function:\n\nfunction(data, scales, diameter = 1, tension = 0.75, n = 50) {\n  cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n  springs &lt;- lapply(\n    seq_len(nrow(data)), \n    function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        diameter = diameter, \n        tension = tension, \n        n = n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    }\n  )\n  do.call(rbind, springs)\n}\n\nWe use lapply() to loop over each row of the data and create the points required to draw the corresponding spring. For each such spring, we use cbind() to combine the spring data with all the non-position columns of the input row. This is very important, since otherwise the aesthetic mappings to e.g. color and size would be lost. Finally, because the output of lapply() is a list of data frames (one per spring), we use rbind() to combine these into a single data frame that gets returned.\nWhen defining a new stat, it is very common to specify one or both of the setup_data() and setup_params() methods. These methods are called at the very beginning of the plot building process, so you can use them to do early checks and modifications of the parameters and data.\nFor our StatSpring example, we use the setup_data() method to ensure that each input row has a unique group aesthetic. This is important because we’re going to draw our springs with GeomPath, and we need to make sure that the data frame output by the stat has a unique identifier for each spring. Doing so ensures that the geom draws each spring as a distinct path, and won’t draw any connecting lines between different springs. Again, there are some subtle details to call attention to in the implementation:\n\nfunction(data, params) {\n  if (anyDuplicated(data$group)) {\n    data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n  }\n  data\n}\n\nNotice that this implementation preserves the original value of data$group, appending a unique id if needed. This is important because the group aesthetic is sometimes used to carry metadata, and we don’t want to lose that information.\nThe final part of our new class is the required_aes field. This is a character vector that gives the names of aesthetics that the user must provide to the stat. In this case, we need to make sure the user specifies four position aesthetics: x and y define where the spring starts, while xend and yend define where it ends. The required_aes field, along with default_aes and non_missing_aes, also defines the aesthetics that this stat understands. Any aesthetics that don’t appear in these fields (or in the fields of the corresponding geom) will generate a warning and the mapping will be ignored.\n\n4.2.4 Constructors\nNow that we have our StatSpring ggproto object, it’s time to write constructor functions that the user will interact with. Strictly speaking we don’t need to do this, because geom_path(stat = \"spring\") will already work, but it’s good practice to write constructor functions for the convenience of your users. In addition, the constructor function provides a good place to document the new functionality.\nPerhaps surprisingly, stat objects are almost always paired with a geom_*() constructor because most ggplot2 users are accustomed to adding geoms, not stats, when building up a plot. The constructor itself is mostly boilerplate code that wraps a call to layer(); just take care to match the argument order and naming used in the ggplot2’s constructors so you don’t surprise your users.\n\ngeom_spring &lt;- function(mapping = NULL,\n                        data = NULL, \n                        stat = \"spring\",\n                        position = \"identity\", \n                        ..., \n                        diameter = 1, \n                        tension = 0.75,\n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\",\n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE\n                        ) {\n  layer(\n    data = data,\n    mapping = mapping,\n    stat = stat,\n    geom = GeomPath,\n    position = position,\n    show.legend = show.legend,\n    inherit.aes = inherit.aes,\n    params = list(\n      diameter = diameter,\n      tension = tension,\n      n = n,\n      arrow = arrow,\n      lineend = lineend,\n      linejoin = linejoin,\n      na.rm = na.rm,\n      ...\n    )\n  )\n}\n\nFor the sake of completeness you should also create a stat_*() constructor function. There are no surprises here: stat_spring() is very similar to geom_spring() except that it provides a default geom instead of a default stat.\n\nstat_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        geom = \"path\", \n                        position = \"identity\", \n                        ..., \n                        diameter = 1, \n                        tension = 0.75, \n                        n = 50, \n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = StatSpring, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      diameter = diameter, \n      tension = tension, \n      n = n, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\n\n4.2.5 Testing the stat\nNow that everything is in place, we can test out our new layer:\n\ndf &lt;- tibble(\n  x = runif(5, max = 10),\n  y = runif(5, max = 10),\n  xend = runif(5, max = 10),\n  yend = runif(5, max = 10),\n  class = sample(letters[1:2], 5, replace = TRUE)\n)\n\nggplot(df) + \n  geom_spring(aes(x = x, y = y, xend = xend, yend = yend)) +\n  coord_equal()\n\n\n\n\n\n\n\nThis looks pretty good. Users can call our geom_spring() constructor function and get sensible results. Better yet, because we’ve written a new stat, we get a number of features for free, like scaling and faceting:\n\nggplot(df) + \n  geom_spring(\n    aes(x, y, xend = xend, yend = yend, colour = class),\n    linewidth = 1\n  ) +\n  coord_equal() + \n  facet_wrap(~ class)\n\n\n\n\n\n\n\nUsers also have the option of calling the stat_spring() constructor, which can be helpful if for some reason they want to draw the springs with points rather than paths:\n\nggplot(df) + \n  stat_spring(\n    aes(x, y, xend = xend, yend = yend, colour = class),\n    geom = \"point\", \n    n = 15\n  ) +\n  coord_equal() + \n  facet_wrap(~ class)\n\n\n\n\n\n\n\n\n4.2.6 Post-mortem\nWe have now successfully created our first extension. It works, but it has some limitations that we now need to think about.\nOne shortcoming of our implementation is that diameter and tension are constants that can only be set for the full layer. These settings feel more like aesthetics and it would be nice if their values could be mapped to a variable in the data. We’ll discuss solutions to this problem in Section 4.3 and Section 4.4.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html#sec-spring2",
    "href": "ggplot2_spring.html#sec-spring2",
    "title": "4  学习示例",
    "section": "\n4.3 Part 2: Adding aesthetics",
    "text": "4.3 Part 2: Adding aesthetics\nThe stat we created in the last section treats the diameter and tension as constant arguments: they’re not aesthetics and the user can’t map them onto a variable in the data. We can fix this by making a few small changes to the StatSpring code:\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat,\n                      \n  setup_data = function(data, params) {\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  compute_panel = function(data, scales, n = 50) {\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(seq_len(nrow(data)), function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        data$diameter[i],\n        data$tension[i], \n        n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    })\n    do.call(rbind, springs)\n  },\n  \n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  optional_aes = c(\"diameter\", \"tension\")\n)\n\nThe main difference with our previous attempt is that the diameter and tension arguments to compute_panel() have gone away, and they’re now taken from the data (just like x, y, etc). This has a downside that we’ll fix in Section 4.4: we can no longer set fixed aesthetics. Because of this, we’ll need to remove those arguments from the constructor function:\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"spring\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        na.rm = FALSE,\n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomPath, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\nThe stat_spring() constructor would require the same kind of change.\nAll that is left is to test our new implementation out:\n\ndf &lt;- tibble(\n  x = runif(5, max = 10),\n  y = runif(5, max = 10),\n  xend = runif(5, max = 10),\n  yend = runif(5, max = 10),\n  class = sample(letters[1:2], 5, replace = TRUE),\n  tension = runif(5),\n  diameter = runif(5, 0.5, 1.5)\n)\n\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(aes(tension = tension, diameter = diameter))\n\n\n\n\n\n\n\nIt appears to work. However, as we expected, it’s no longer possible to set diameter and tension as parameters:\n\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(diameter = 0.5)\n#&gt; Warning in geom_spring(diameter = 0.5): Ignoring unknown parameters: `diameter`\n#&gt; Warning: Computation failed in `stat_spring()`\n#&gt; Caused by error in `if (tension &lt;= 0) ...`:\n#&gt; ! argument is of length zero\n\n\n\n\n\n\n\n\n4.3.1 Post-mortem\nIn this section we further developed our spring stat so that diameter and tension can be used as aesthetics, varying across springs. Unfortunately, there’s a major downside: these features no longer can be set globally. We’re still also missing a way to control the scaling of the two aesthetics. Fixing both these problems requires the same next step: move our implementation away from Stat and towards a proper Geom.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html#sec-spring3",
    "href": "ggplot2_spring.html#sec-spring3",
    "title": "4  学习示例",
    "section": "\n4.4 Part 3: A geom",
    "text": "4.4 Part 3: A geom\nIn many cases a Stat-centred approach is sufficient, for example, many of the graphic primitives provided by the ggforce package are Stats. But we need to go further with the spring geom because the tension and diameter aesthetics need to be specified in units that are unrelated to the coordinate system. Consequently, we’ll rewrite our geom to be a proper Geom extension.\n\n4.4.1 Geom extensions\nAs discussed in Chapter 4, there are many similarities between Stat and Geom extensions. The biggest difference is that Stat extensions return a modified version of the input data, whereas Geom extensions return graphical objects. In some cases creating a new geom requires you to use the grid package (we’ll cover this in Section 4.6), but often you don’t have to.\nMuch like stat objects, geom objects in ggproto have several methods and fields you can modify. You can see the list by printing the object:\n\nGeom\n#&gt; &lt;ggproto object: Class Geom, gg&gt;\n#&gt;     aesthetics: function\n#&gt;     default_aes: uneval\n#&gt;     draw_group: function\n#&gt;     draw_key: function\n#&gt;     draw_layer: function\n#&gt;     draw_panel: function\n#&gt;     extra_params: na.rm\n#&gt;     handle_na: function\n#&gt;     non_missing_aes: \n#&gt;     optional_aes: \n#&gt;     parameters: function\n#&gt;     rename_size: FALSE\n#&gt;     required_aes: \n#&gt;     setup_data: function\n#&gt;     setup_params: function\n#&gt;     use_defaults: function\n\n\n4.4.2 Creating the geom\nIn much the same way that a stat uses the compute_layer(), compute_panel(), and compute_group() methods to transform the data, a geom uses draw_layer(), draw_panel(), and draw_group() to create graphical representations of the data. In the same way that we created StatSpring by writing a compute_panel() method to do the heavy lifting, we’ll create GeomSpring by writing a draw_panel() method:\n\nGeomSpring &lt;- ggproto(\"GeomSpring\", Geom,\n  \n  # Ensure that each row has a unique group id\n  setup_data = function(data, params) {\n    if (is.null(data$group)) {\n      data$group &lt;- seq_len(nrow(data))\n    }\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  # Transform the data inside the draw_panel() method\n  draw_panel = function(data, \n                        panel_params, \n                        coord, \n                        n = 50, \n                        arrow = NULL,\n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        linemitre = 10,\n                        na.rm = FALSE) {\n    \n    # Transform the input data to specify the spring paths\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(seq_len(nrow(data)), function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        data$diameter[i],\n        data$tension[i], \n        n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    })\n    springs &lt;- do.call(rbind, springs)\n    \n    # Use the draw_panel() method from GeomPath to do the drawing\n    GeomPath$draw_panel(\n      data = springs, \n      panel_params = panel_params, \n      coord = coord, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      linemitre = linemitre, \n      na.rm = na.rm\n    )\n  },\n  \n  # Specify the default and required aesthetics\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  default_aes = aes(\n    colour = \"black\", \n    linewidth = 0.5, \n    linetype = 1L, \n    alpha = NA, \n    diameter = 1, \n    tension = 0.75\n  )\n)\n\nDespite the length of this code, most of it is familiar:\n\nThe setup_data() methods are essentially the same: in both cases they ensure that every row in the input data has a unique group identifier.\nThe draw_panel() method for our GeomSpring object is very similar to the compute_panel() method. The main difference is that our draw_panel() method has an extra step: it passes the computed spring coordinates to GeomPath$draw_panel(). Because springs are just fancy paths, the GeomPath$draw_panel() method works perfectly well here.\nUnlike the StatSpring code that we wrote earlier, the GeomSpring code uses the default_aes field to provide default values for any aesthetic that the user does not specify.\n\nOne aspect to this code may surprise developers who are used to object-oriented design from other languages. Calling the method of a kindred object directly, as we do when invoking GeomPath$draw_panel() from within GeomSpring$draw_panel(), is not considered good practice in other object-oriented systems. However, because ggproto objects are stateless (Section 2.4.5), this is exactly as safe as subclassing GeomPath and calling the parent method. You can see this approach all over the place in the ggplot2 source code.\n\n4.4.3 A constructor\nAs with our earlier attempts the final step is to write a constructor function geom_spring(). The code is not much different to earlier versions: we use GeomSpring instead of GeomPath, and we use the identity stat instead of StatSpring.\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"identity\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        na.rm = FALSE,\n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomSpring, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\n\n4.4.4 Testing the geom\nWe now have a proper geom with working default aesthetics and the ability to setting aesthetics as parameters:\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(aes(tension = tension, diameter = diameter))\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(diameter = 0.5)\n\n\n\n\n\n\n\n\n\n\nIt does have some limitations still, because the units for diameter and tension are expressed relative to the scale of the raw data. The actual diameter of a spring with diameter = 0.5 will be different depending on the axis limits, and if the x and y axes are not on the same scale the shape of the spring will be distorted. You can see this in the example below:\n\nggplot() + \n  geom_spring(aes(x = 0, y = 0, xend = 3, yend = 20))\n\n\n\n\n\n\n\nThe same underlying problem means that the diameter of the spring is expressed in coordinate space. This makes it difficult to define a meaningful default because the absolute size of the spring diameter changes when the scale of the data changes:\n\nggplot() + \n  geom_spring(aes(x = 0, y = 0, xend = 100, yend = 80))\n\n\n\n\n\n\n\nWe’ll address this issue in Section 4.6.\n\n4.4.5 Post-mortem\nIn this section we finally created our own Geom extension. This is often the natural conclusion to the development of new layer, but not always. Sometimes you’ll find that the Stat approach works perfectly well for your purposes, and it has the advantage that you can use the stat with multiple geoms. The final choice is up to you as the developer, and should be guided by how you expect people to use the layer.\nPerhaps surprisingly, we haven’t talked about what goes on inside the draw_*() methods yet. Our GeomSpring object relies on the draw_panel() method from GeomPath to do the work of creating the graphical output. This is quite common. For example, even the relatively complex GeomBoxplot just uses the draw methods from GeomPoint(), GeomSegment and GeomCrossbar.\nIf you need to go deeper, you’ll need to learn a little about grid. Creating grid grobs is an advanced technique, needed by relatively few geoms. But creating a grid grob gives you the power to use absolute units for diameter (e.g. 1cm) and to adjust the display of the geom based on the size of the output device. We’ll turn to that next.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html#an-introduction-to-grid",
    "href": "ggplot2_spring.html#an-introduction-to-grid",
    "title": "4  学习示例",
    "section": "\n4.5 An introduction to grid",
    "text": "4.5 An introduction to grid\nThe grid package provides the underlying graphics system upon which ggplot2 is built. It’s one of two quite different drawing systems that are included in base R: base graphics and grid. Base graphics has an imperative “pen-on-paper” model: every function immediately draws something on the graphics device. Much like ggplot2 itself, grid takes a more declarative approach where you build up a description of the graphic as an object, which is later rendered. This declarative approach allows us to create objects that exists independently of the graphic device and can be passed around, analysed, and modified. Importantly, parts of a graphical object can refer to other parts, which allows you to do things like define this rectangle to have width equal to the length of that string of text, and so on.\nAs a ggplot2 developer you will find that you can achieve a lot without ever needing to interact with grid directly, but there are situations where it is impossible to achieve what you want without going down to the grid level. The two most common situations are:\n\nYou need to create graphical objects that are positioned correctly on the coordinate system, but where some part of their appearance has a fixed absolute size. In our case this would be the spring correctly going between two points in the plot, but the diameter being defined in cm instead of relative to the coordinate system.\nYou need graphical objects that are updated during resizing. This could e.g. be the position of labels such as in the ggrepel package or the geom_mark_*() geoms in ggforce.\n\nA comprehensive introduction to grid is far more than we can cover in this book, but to help you get started we’ll give you the absolute minimum vocabulary to understand how ggplot2 uses grid. We’ll introduce core concepts like grobs, viewports, graphical parameters, and units but please read R Graphics by @murrell:2018 to get the full details.\n\n4.5.1 Grobs\nTo understand how grid works, the first thing we need to talk about are grobs. Grobs (graphic objects) are the atomic representations of graphical elements in grid, and include types like points, lines, circles, rectangles, and text. The grid package provides functions like pointsGrob(), linesGrob(), circleGrob(), rectGrob(), and textGrob() that create graphical objects without drawing anything to the graphics device. These functions are vectorised, allowing a single point grob to represent multiple points, for instance:\n\nlibrary(grid)\ncircles &lt;- circleGrob(\n  x = c(0.1, 0.4, 0.7), \n  y = c(0.5, 0.3, 0.6),\n  r = c(0.1, 0.2, 0.3)\n)\ncircles\n#&gt; circle[GRID.circle.606]\n\nNote that this code doesn’t draw anything: it’s just a description of a set of circles. To draw it, we first call grid.newpage() to clear the current graphics device then grid.draw():\n\ngrid.newpage()\ngrid.draw(circles)\n\n\n\n\n\n\n\ngrid also provides grobTree(), which construct composite objects from multiple atomic grobs. Here’s an illustration:\n\nlabels &lt;- textGrob(\n  label = c(\"small\", \"medium\", \"large\"),\n  x = c(0.1, 0.4, 0.7), \n  y = c(0.5, 0.3, 0.6),\n)\n\ncomposite &lt;- grobTree(circles, labels)\ngrid.newpage()\ngrid.draw(composite)\n\n\n\n\n\n\n\nIt is also possible to define your own grobs. You can define a new primitive grob class using grob() or a new composite class using gTree(), then specify special behaviour for your new class. We’ll see an example of this in a moment.\n\n4.5.2 Viewports\nThe second key concept in grid is the idea of a viewport. A viewport is a rectangular plotting region that supplies its own coordinate system for grobs that are drawn within it, and can also provide a tabular grid in which other viewports an be nested. An individual grob can have its own viewport or, if none is provided, it will inherit one. While we won’t need to consider viewports when building the grob for our springs, they’re an important concept that powers much of the high-level layout of ggplot2 graphics so we’ll very briefly introduce them here. In the example below we use viewport() to define two different viewports, one with default parameters, and second one that is rotated around the midpoint by 15 degrees:\n\nvp_default &lt;- viewport()\nvp_rotated &lt;- viewport(angle = 15)\n\nThis time around, when we create our composite grobs, we’ll explicitly assign them to specific viewports by setting the vp argument:\n\ncomposite_default &lt;- grobTree(circles, labels, vp = vp_default)\ncomposite_rotated &lt;- grobTree(circles, labels, vp = vp_rotated)\n\nWhen we plot these two grobs, we can see the effect of the viewport: although composite_default and composite_rotated are comprised of the same two primitive grobs (i.e., circles and labels), they belong to different viewports so they look different when the plot is drawn:\n\ngrid.newpage()\ngrid.draw(composite_default)\ngrid.draw(composite_rotated)\n\n\n\n\n\n\n\nggplot2 automatically generates most of the viewports that you’ll need for plotting, but it’s important to understand the basic idea.\n\n4.5.3 Graphical parameters\nThe next concept we need to understand is the idea of graphical parameters. When we defined the circles and labels grobs, we only specified some of their properties. For example, we said nothing about colour or transparency, so these properties are all set to their default values. The gpar() function in grid allows you to specify graphical parameters as distinct objects:\n\ngp_blue &lt;- gpar(col = \"blue\", fill = NA)\ngp_orange &lt;- gpar(col = \"orange\", fill = NA)\n\nThe gp_blue and gp_orange objects provide lists of graphical settings that can now be applied to any grob we like using the gp argument:\n\ngrob1 &lt;- grobTree(circles, labels, vp = vp_default, gp = gp_blue)\ngrob2 &lt;- grobTree(circles, labels, vp = vp_rotated, gp = gp_orange)\n\nWhen we plot these two grobs, they inherit the settings provided by the graphical parameters as well as the viewports to which they are assigned:\n\ngrid.newpage()\ngrid.draw(grob1)\ngrid.draw(grob2)\n\n\n\n\n\n\n\n\n4.5.4 Units\nThe last core concept that we need to discuss is the unit system. The grid package allows you to specify the positions (e.g. x and y) and dimensions (e.g. length and width) of grobs and viewports using a flexible specification. In the grid unit system there are three qualitatively different styles of unit:\n\nAbsolute units, e.g. centimeters, inches, and points, refer to physical sizes.\nRelative units e.g. npc which represents a proportion of the current viewport size.\nUnits defined by strings or other grobs, e.g. strwidth, grobwidth.\n\nThe unit() function is the main function we use when specifying units: unit(1, \"cm\") is 1 centimeter, whereas unit(0.5, \"npc\") is half the size of the relevant viewport. The unit system supports arithmetic operations that are only resolved at draw time, which makes it possible to combine different types of units: unit(0.5, \"npc\") + unit(1, \"cm\") defines a point one centimeter to the right of the center of the current viewport.\n\n4.5.5 Building grob classes\nNow that we have a basic understanding of grid, let’s attempt to create our own “surprise” grob class: objects that are circles if they are smaller than 3cm, but transform into squares whenever they are larger than 3cm. This is not the most useful kind of graphical object, but it’s useful for illustrating the flexibility of the grid system. The first step is to write our own constructor function using grob() or gTree(), depending on whether we are creating a primitive or composite object. We begin by creating a “thin” constructor function:\n\nsurpriseGrob &lt;- function(x, \n                         y, \n                         size, \n                         default.units = \"npc\", \n                         name = NULL, \n                         gp = gpar(), \n                         vp = NULL) {\n  \n  # Ensure that input arguments are units\n  if (!is.unit(x)) x &lt;- unit(x, default.units)\n  if (!is.unit(y)) y &lt;- unit(y, default.units)\n  if (!is.unit(size)) size &lt;- unit(size, default.units)\n  \n  # Construct the surprise grob subclass as a gTree\n  gTree(\n    x = x, \n    y = y, \n    size = size, \n    name = name, \n    gp = gp, \n    vp = vp, \n    cl = \"surprise\"\n  )\n}\n\nThis function doesn’t do very much. All it does is ensure that the x, y, and size arguments are grid units, and sets the class name to be “surprise”. To define the behaviour of our grob, we need to specify methods for one or both of the generic functions makeContext() and makeContent():\n\nmakeContext() is called when the parent grob is rendered and allows you to control the viewport of the grob. We won’t need to use that for our surprise grob.\nmakeContent() is called every time the drawing region is resized and allows you to customise the look of the grob based on the size or other aspect.\n\nBecause these generic functions use the S3 object oriented programming system, we can define our method simply by appending the class name to the end of the function name. That is, the makeContent() method for our surprise grob is defined by creating a function called makeContent.surprise() that takes a grob as input and returns a modified grob as output:\n\nmakeContent.surprise &lt;- function(x) {\n  x_pos &lt;- x$x\n  y_pos &lt;- x$y\n  size &lt;- convertWidth(x$size, unitTo = \"cm\", valueOnly = TRUE)\n  \n  # Figure out if the given sizes are bigger or smaller than 3 cm\n  circles &lt;- size &lt; 3\n  \n  # Create a circle grob for the small ones\n  if (any(circles)) {\n    circle_grob &lt;- circleGrob(\n      x = x_pos[circles], \n      y = y_pos[circles], \n      r = unit(size[circles] / 2, \"cm\")\n    )\n  } else {\n    circle_grob &lt;- NULL\n  }\n  \n  # Create a rect grob for the large ones\n  if (any(!circles)) {\n    square_grob &lt;- rectGrob(\n      x = x_pos[!circles], \n      y = y_pos[!circles], \n      width = unit(size[!circles], \"cm\"),\n      height = unit(size[!circles], \"cm\")\n    )\n  } else {\n    square_grob &lt;- NULL\n  }\n  \n  # Add the circle and rect grob as children of our input grob\n  setChildren(x, gList(circle_grob, square_grob))\n}\n\nSome of the functions we’ve called here are new, but they all reuse the core concepts that we discussed earlier. Specifically:\n\n\nconvertWidth() is used to convert grid units from one type to another.\n\ngList() creates a list of grobs.\n\nsetChildren() specifies the grobs that belong to a gTree composite grob.\n\nThe effect of this function is to ensure that every time the grob is rendered the absolute size of each shape is recalculated. All shapes smaller than 3cm become circles, and all shapes larger than 3cm become squares. To see how this plays out, lets call our new function:\n\nsurprises &lt;- surpriseGrob(\n  x = c(0.25, 0.45, 0.75), \n  y = c(0.5, 0.5, 0.5), \n  size = c(0.05, 0.15, 0.25)\n)\n\nThe surprises grob contains three shapes whose locations and sizes have been specified relative to the size of the viewport. At this point in time we have no idea which of these shapes will be circles and which will be squares: that depends on the size of the viewport in which the surprises grob is to be drawn. We can now draw the grob in the usual way:\n\ngrid.newpage()\ngrid.draw(surprises)\n\n\n\n\n\n\n\nIf you run this code interactively and resize the plotting window you’ll see that the three objects change shape based on the size of the plotting window. This is not the most useful way to employ grid, of course, but hopefully you can see how this technique can be used to do real work.\n\n4.5.6 Tabular grid\nThe last aspect to grid we’ll discuss here is the layout engine provided by the gtable package. It’s not necessary to know about gtable in order to build our spring grob, but there are other kinds of ggplot2 extensions that do require this knowledge, so we’ll give a brief overview here.\nAs discussed in Section 2.3, when ggplot2 passes the plot to grid for rendering it does so by creating a gtable object with ggplot_gtable(). We can extract this object using the ggplotGrob() function:\n\np &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()\ngrob_table &lt;- ggplotGrob(p)\ngrob_table\n#&gt; TableGrob (12 x 9) \"layout\": 18 grobs\n#&gt;     z         cells       name                                          grob\n#&gt; 1   0 ( 1-12, 1- 9) background               rect[plot.background..rect.654]\n#&gt; 2   5 ( 6- 6, 4- 4)     spacer                                zeroGrob[NULL]\n#&gt; 3   7 ( 7- 7, 4- 4)     axis-l           absoluteGrob[GRID.absoluteGrob.642]\n#&gt; 4   3 ( 8- 8, 4- 4)     spacer                                zeroGrob[NULL]\n#&gt; 5   6 ( 6- 6, 5- 5)     axis-t                                zeroGrob[NULL]\n#&gt; 6   1 ( 7- 7, 5- 5)      panel                      gTree[panel-1.gTree.634]\n#&gt; 7   9 ( 8- 8, 5- 5)     axis-b           absoluteGrob[GRID.absoluteGrob.638]\n#&gt; 8   4 ( 6- 6, 6- 6)     spacer                                zeroGrob[NULL]\n#&gt; 9   8 ( 7- 7, 6- 6)     axis-r                                zeroGrob[NULL]\n#&gt; 10  2 ( 8- 8, 6- 6)     spacer                                zeroGrob[NULL]\n#&gt; 11 10 ( 5- 5, 5- 5)     xlab-t                                zeroGrob[NULL]\n#&gt; 12 11 ( 9- 9, 5- 5)     xlab-b titleGrob[axis.title.x.bottom..titleGrob.645]\n#&gt; 13 12 ( 7- 7, 3- 3)     ylab-l   titleGrob[axis.title.y.left..titleGrob.648]\n#&gt; 14 13 ( 7- 7, 7- 7)     ylab-r                                zeroGrob[NULL]\n#&gt; 15 14 ( 4- 4, 5- 5)   subtitle         zeroGrob[plot.subtitle..zeroGrob.650]\n#&gt; 16 15 ( 3- 3, 5- 5)      title            zeroGrob[plot.title..zeroGrob.649]\n#&gt; 17 16 (10-10, 5- 5)    caption          zeroGrob[plot.caption..zeroGrob.652]\n#&gt; 18 17 ( 2- 2, 2- 2)        tag              zeroGrob[plot.tag..zeroGrob.651]\n\nThe output illustrates how the ggplot2 layout is structured. The plot is comprised of 18 distinct grobs that are arranged in a TableGrob that specifies a 12 x 9 grid, which in turn supplies a collection of viewports within which individual grobs can be drawn. This TableGrob is itself a grobtree, and can be rendered with grid in by calling grid.draw():\n\ngrid.newpage()\ngrid.draw(grob_table)\n\n\n\n\n\n\n\nTo illustrate how a TableGrob works, we’ll create a simplified version of this output without using ggplot2. Our first step is to define the constituent grobs that make up our plot:\n\nxtick &lt;- 0:8\nytick &lt;- seq(0, 50, 10)\n\npoints &lt;- pointsGrob(\n  x = mpg$displ / xtick[length(xtick)],\n  y = mpg$hwy / ytick[length(ytick)],\n  default.units = 'npc',\n  size = unit(6, 'pt')\n)\n\nxaxis &lt;- xaxisGrob(\n  at = seq(0, 1, length.out = length(xtick)), \n  label = xtick\n)\n\nyaxis &lt;- yaxisGrob(\n  at = seq(0, 1, length.out = length(ytick)), \n  label = ytick\n)\n\nThe points grob contains the data to be plotted, while xaxis and yaxis are grobs that draw labelled axes. When we draw the points grob, we get the core of a scatter plot:\n\ngrid.newpage()\ngrid.draw(points)\n\n\n\n\n\n\n\nHowever, if we want to add axes to this plot, we need a set of viewports laid out in a tabular format so that we can place xaxis immediately below points, and yaxis to the left of points. In ggplot2, this is handled by the gtable layout engine. First, we use gtable() to define the structure:\n\nlibrary(gtable)\n\nplot_layout &lt;- gtable(\n  widths = unit(c(1.5, 0, 1, 0.5), c('cm', 'cm', 'null', 'cm')),\n  heights = unit(c(0.5, 1, 0, 1.5), c('cm', 'null', 'cm', 'cm'))\n)\n\nThe plot_layout object is a 4 x 4 TableGrob that defines viewports with sizes that match the row heights and column widths that we passed to gtable(). The gtable_show_layout() function provides a convenient way to visualise this layout:\n\ngtable_show_layout(plot_layout)\n\n\n\n\n\n\n\nNotice that this layout has one row with height zero, and one column with width zero. We’ll place the xaxis and yaxis grobs into these rows, and allow them to “spill over” into the adjacent rows and columns that specify the margins for the plot.\nTo place the grobs into the table, we use the gtable_add_grob() function. A TableGrob layout allows an individual grob to span multiple cells using the arguments t, l, b, and r to specify cell indices for the topmost, leftmost, bottom, and rightmost cells spanned by the grob. However, the default is to assume that each grob belongs to exactly one cell, in which case only the t and l arguments need to be specified:\n\nplot_layout &lt;- gtable_add_grob(\n  plot_layout,\n  grobs = list(points, xaxis, yaxis),\n  t = c(2, 3, 2), # the row defining the top extent of each grob\n  l = c(3, 3, 2), # the column defining the left extent of each grob\n  clip = 'off'\n)\n\nIf we inspect our plot_layout object, we see something that has the same structure as the TableGrob produced by the ggplot2 code above:\n\nplot_layout\n#&gt; TableGrob (4 x 4) \"layout\": 3 grobs\n#&gt;   z     cells   name                    grob\n#&gt; 1 1 (2-2,3-3) layout points[GRID.points.655]\n#&gt; 2 2 (3-3,3-3) layout   xaxis[GRID.xaxis.656]\n#&gt; 3 3 (2-2,2-2) layout   yaxis[GRID.yaxis.657]\n\nWe can now draw our plot using grid.draw():\n\ngrid.newpage()\ngrid.draw(plot_layout)\n\n\n\n\n\n\n\nClearly, we’re still missing a lot of important details that would be necessary in a real plot, but hopefully it is now clear how ggplot2 arranges a collection of grobs within a structured plot layout.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html#sec-spring4",
    "href": "ggplot2_spring.html#sec-spring4",
    "title": "4  学习示例",
    "section": "\n4.6 Part 4: A grid grob",
    "text": "4.6 Part 4: A grid grob\nLet’s return to the problem at hand. Armed with our new knowledge of the grid system, we can construct a spring grob that specifies the diameter in absolute units.\n\n4.6.1 The springGrob\nLet’s start by defining the springGrob() function. Our key insight is that we can write the grob code in a way that pushes the spring drawing action down to the level of the makeContent() function. By doing this, we can ensure that the diameter is computed at draw time using absolute units instead of defining the diameter relative to the plot coordinates.\nWe’ll start by creating our constructor function. The arguments to this function are based on the segmentsGrob() since we are, in essence, drawing modified segments:\n\nspringGrob &lt;- function(x0 = unit(0, \"npc\"), \n                       y0 = unit(0, \"npc\"), \n                       x1 = unit(1, \"npc\"), \n                       y1 = unit(1, \"npc\"), \n                       diameter = unit(0.1, \"npc\"), \n                       tension = 0.75,\n                       n = 50, \n                       default.units = \"npc\", \n                       name = NULL, \n                       gp = gpar(), \n                       vp = NULL) {\n  \n  # Use the default unit if the user does not specify one\n  if (!is.unit(x0)) x0 &lt;- unit(x0, default.units)\n  if (!is.unit(x1)) x1 &lt;- unit(x1, default.units)\n  if (!is.unit(y0)) y0 &lt;- unit(y0, default.units)\n  if (!is.unit(y1)) y1 &lt;- unit(y1, default.units)\n  if (!is.unit(diameter)) diameter &lt;- unit(diameter, default.units)\n  \n  # Return a gTree of class \"spring\"\n  gTree(\n    x0 = x0, \n    y0 = y0, \n    x1 = x1, \n    y1 = y1, \n    diameter = diameter, \n    tension = tension, \n    n = n, \n    name = name, \n    gp = gp, \n    vp = vp, \n    cl = \"spring\"\n  )\n}\n\nWe see that once again our constructor is a very thin wrapper around gTree(). It doesn’t introduce any new concepts: all it does is ensure that arguments are converted to units if necessary, and then returns a composite grob with class “spring”. The work of drawing our spring occurs in the makeContent() method:\n\nmakeContent.spring &lt;- function(x) {\n  \n  # Convert position and diameter values absolute units\n  x0 &lt;- convertX(x$x0, \"mm\", valueOnly = TRUE)\n  x1 &lt;- convertX(x$x1, \"mm\", valueOnly = TRUE)\n  y0 &lt;- convertY(x$y0, \"mm\", valueOnly = TRUE)\n  y1 &lt;- convertY(x$y1, \"mm\", valueOnly = TRUE)\n  diameter &lt;- convertWidth(x$diameter, \"mm\", valueOnly = TRUE)\n  \n  # Leave tension and n untouched\n  tension &lt;- x$tension\n  n &lt;- x$n\n  \n  # Transform the input data to a data frame containing spring paths\n  springs &lt;- lapply(seq_along(x0), function(i) {\n    cbind(\n      create_spring(\n        x = x0[i], \n        y = y0[i], \n        xend = x1[i], \n        yend = y1[i], \n        diameter = diameter[i], \n        tension = tension[i], \n        n = n\n      ),\n      id = i\n    )\n  })\n  springs &lt;- do.call(rbind, springs)\n  \n  # Construct the grob\n  spring_paths &lt;- polylineGrob(\n    x = springs$x, \n    y = springs$y, \n    id = springs$id, \n    default.units = \"mm\", \n    gp = x$gp\n  )\n  setChildren(x, gList(spring_paths))\n}\n\nAgain there are a couple of new grid functions here, but hopefully it’s not too hard to work out what they do. In truth there is nothing fancy happening here. Whenever the plot is resized, we grab the coordinates and the diameter settings from the spring grob, and convert them all to millimeters. Only after converting the important quantities to absolute units do we construct the spring paths using the create_spring() function we wrote at the beginning: by pushing the call to create_spring() to this level, we can ensure that the path is defined using absolute units, and then return the result as a polyline grob.\nWe now have a spring grob suitable for use in ggplot2. In the next section we’ll build a geom around it, but before we do that let’s check that our code behaves as expected:\n\nsprings &lt;- springGrob(\n  x0 = c(0, 0),\n  y0 = c(0, 0.5),\n  x1 = c(1, 1),\n  y1 = c(1, 0.5),\n  diameter = unit(c(1, 3), \"cm\"),\n  tension = c(0.2, 0.7)\n)\ngrid.newpage()\ngrid.draw(springs)\n\n\n\n\n\n\n\nThis looks good, so we can now design our new (and final) geom.\n\n4.6.2 The last GeomSpring\nNow that we have a custom grob that draws springs, we can create a GeomSpring ggproto object that uses it. Here’s the complete code for that geom:\n\nGeomSpring &lt;- ggproto(\"GeomSpring\", Geom,\n  \n  # Check that the user has specified sensible parameters                    \n  setup_params = function(data, params) {\n    if (is.null(params$n)) {\n      params$n &lt;- 50\n    } else if (params$n &lt;= 0) {\n      rlang::abort(\"Springs must be defined with `n` greater than 0\")\n    }\n    params\n  },\n  \n  # Check input data and return grobs\n  draw_panel = function(data, \n                        panel_params, \n                        coord, \n                        n = 50, \n                        lineend = \"butt\", \n                        na.rm = FALSE) {\n    \n    # Remove missing data, returning early if all are missing\n    data &lt;- remove_missing(\n      df = data, \n      na.rm = na.rm,\n      vars = c(\"x\", \"y\", \"xend\", \"yend\", \"linetype\", \"linewidth\"),\n      name = \"geom_spring\"\n    )\n    if (is.null(data) || nrow(data) == 0) return(zeroGrob())\n    \n    # Supply the coordinate system for the plot\n    if (!coord$is_linear()) {\n      rlang::warn(\n        \"spring geom only works correctly on linear coordinate systems\"\n      )\n    }\n    coord &lt;- coord$transform(data, panel_params)\n    \n    # Construct the grob\n    springGrob(\n      coord$x, \n      coord$y, \n      coord$xend, \n      coord$yend,\n      default.units = \"native\", \n      diameter = unit(coord$diameter, \"cm\"),\n      tension = coord$tension, \n      n = n,\n      gp = gpar(\n        col = alpha(coord$colour, coord$alpha),\n        lwd = coord$linewidth * .pt,\n        lty = coord$linetype,\n        lineend = lineend\n      )\n    )\n  },\n  \n  # Specify the default and required aesthetics\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  default_aes = aes(\n    colour = \"black\", \n    linewidth = 0.5, \n    linetype = 1L, \n    alpha = NA, \n    diameter = 0.35, \n    tension = 0.75\n  )\n)\n\nThere are a few things to note here. As you might expect, the main changes from the last version are in the draw_panel() method (see below). But there are a couple of other changes.\n\nPrevious versions of GeomSpring – and StatSpring before it – included a setup_data() method that modified the group column in the input data. That’s gone now: we no longer need to worry about this because this new version of the geom doesn’t call create_spring() directly. As far as the geom is concerned, each spring is defined by one (and only one) row in the input data. All the work of “expanding” this to a spring-like path is handled by the grob.\nThis version of GeomSpring has a setup_params() method. Its only job is to check the number of points used to define the spring.\nThe default_aes field is slightly different. The important change is that we can now set a meaningful default value for diameter.\n\nLet’s now take a closer look at the new draw_panel() method. Because we are no longer relying on GeomPath$draw_panel() to do the work, we have a few new tasks to take care of:\n\nIt checks to see if the coordinate system is non-linear (e.g. coord_polar()), and if so it emits a warning because our spring grob is not designed to work in that context.\nIt uses the coordinate system to rescale the positional aesthetics by calling the transform() method for the coord object. This remaps all positional aesthetics to lie between 0 and 1, with 0 being the lowest value visible in our viewport (scale expansions included) and 1 being the highest. With this remapping the coordinates are ready to be passed to the grob.\nWe pass a set of graphical parameters to the grob using the grid gpar() function. Not all grobs care about all entries in gpar() and since we are constructing a line we only care about the graphical parameters that polylineGrob() understands, namely: col (stroke colour), lwd (line width), lty (line type), lineend (the terminator shape of the line).\n\nNow that GeomSpring is defined, all that remains is to create a constructor function that the user can call:\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"identity\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        lineend = \"butt\", \n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomSpring, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      lineend = lineend, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\nAt long last we can put our new geom_spring() function to good use:\n\nggplot(df) + \n  geom_spring(aes(\n    x = x * 100, \n    y = y, \n    xend = xend, \n    yend = yend, \n    diameter = diameter, \n    tension = tension\n  ))\n\n\n\n\n\n\n\nAs you can see from the output above, we now have springs that behave sensibly when the aspect ratio of the plot changes or when the x and y axes are on different scales. Resizing the plot will trigger a recalculation of the correct path, so it will continue to look as it should.\n\n4.6.3 Post-mortem\nWe have finally arrived at the spring geom we set out to make. The diameter aesthetic for our spring has similar behaviour to the linewidth aesthetic, in that it remains fixed when resizing and/or changing the aspect ratio of the plot. There are still improvements we could (and perhaps, should) make. Most notably our create_spring() function remains un-vectorised and needs to be called for each spring separately. Correctly vectorising this function will allow for considerable speed-up when rendering many springs (if that was ever a need). We will leave this as an exercise for the reader.\nWhile the geom is now done, we still have a little work to do. We need to create a diameter scale and provide legend keys that can correctly communicate diameter and tension. This will be the topic of the final section.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html#sec-spring5",
    "href": "ggplot2_spring.html#sec-spring5",
    "title": "4  学习示例",
    "section": "\n4.7 Part 5: Scales",
    "text": "4.7 Part 5: Scales\nThe last step in our process is to define new scales. We want to do this because we have defined two new aesthetics (diameter and tension), and we’d like users to be able to scale them. There’s nothing wrong with defining new aesthetics without providing a scale — which means that the mapped values are passed through unchanged — but if we want users to have some control as well as the possibility of a legend we will need to provide scales for the aesthetics. This is the goal of this final section.\n\n4.7.1 Scaling\nThankfully, compared to the work we’ve done so far, creating new scales is not a huge undertaking. We discussed the basic ideas in Section 4.5, and we can apply those concepts here without too much pain. Our main task is to create a function with the appropriate name that outputs a Scale object. Most scale functions are simple wrappers around one of the three fundamental scale constructor functions, continuous_scale(), discrete_scale(), and binned_scale(). Here’s how we do that for the tension aesthetic:\n\nscale_tension_continuous &lt;- function(..., range = c(0.1, 1)) {\n  continuous_scale(\n    aesthetics = \"tension\", \n    scale_name = \"tension_c\", \n    palette = scales::rescale_pal(range), \n    ...\n  )\n}\n\nThis scale_tension_continuous() function indicates which aesthetics it applies to, provides an explicit scale_name, and provides a palette function that transforms the input domain to the output range. All the other arguments that you’d typically expect to see in a scale function, such as name, breaks, limits, get passed down to continuous_scale() with the dots ....\nFor the tension aesthetic, we expect that users will apply it to continuous scales only, so it’s convenient to define scale_tension() as an alias for scale_tension_continuous():\n\nscale_tension &lt;- scale_tension_continuous\n\nFinally, because we don’t want people trying to map the tension aesthetic to discrete data, we’ll also define a scale_tension_discrete() function that always throws an error:\n\nscale_tension_discrete &lt;- function(...) {\n  rlang::abort(\"Tension cannot be used with discrete data\")\n}\n\nThe reason this works is that ggplot2 assigns the default scale for aesthetics by searching for a function called scale_&lt;aesthetic-name&gt;_&lt;data-type&gt;, so any time the user maps the tension aesthetic to a discrete variable ggplot2 will find the scale_tension_discrete() function and throw the error. This is also the reason why it is important to include scale_tension_continuous() even when we expect most users will use the scale_tension() alias.\nThe scale functions for the diameter aesthetic are only slightly more complicated:\n\nscale_diameter_continuous &lt;- function(..., \n                                      range = c(0.25, 0.7), \n                                      unit = \"cm\") {\n  range &lt;- grid::convertWidth(\n    unit(range, unit), \n    \"cm\", \n    valueOnly = TRUE\n  )\n  continuous_scale(\n    aesthetics = \"diameter\", \n    scale_name = \"diameter_c\", \n    palette = scales::rescale_pal(range), \n    ...\n  )\n}\nscale_diameter &lt;- scale_diameter_continuous\nscale_tension_discrete &lt;- function(...) {\n  rlang::abort(\"Diameter cannot be used with discrete data\")\n}\n\nThe only change we made from the tension scales is that we allow the user to define which unit the diameter range should be measured in. Since the geom expects centimeters we will convert the range to that before passing it into the scale constructor. In that way the user is free to use whatever absolute unit feels natural to them.\nWith our scales defined let us have a look:\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5)) \n\n\n\n\n\n\n\nFrom this output we can see that default scales work (i.e., we didn’t add an explicit scale for diameter but the plot renders correctly), as do the custom scales (i.e., we called scale_tension() explicitly).\nThe output also tells us that our job is not quite done, because the legend isn’t very helpful. The reason for this is that our geom is using the default legend key constructor, draw_key_point(). This function doesn’t understand our new aesthetics, so it ignores them completely. We can fix this by defining a custom legend key function, draw_key_spring().\n\n4.7.2 draw_key_spring\nLet’s take a look at how a key constructor is written, by inspecting the source code for draw_key_point(). Thankfully, these are pretty simple functions that take a data frame of aesthetic values, and return an appropriate grob that supplies the depictions shown in the legend key:\n\ndraw_key_point\n#&gt; function(data, params, size) {\n#&gt;   if (is.null(data$shape)) {\n#&gt;     data$shape &lt;- 19\n#&gt;   } else if (is.character(data$shape)) {\n#&gt;     data$shape &lt;- translate_shape_string(data$shape)\n#&gt;   }\n#&gt; \n#&gt;   # NULL means the default stroke size, and NA means no stroke.\n#&gt;   stroke_size &lt;- data$stroke %||% 0.5\n#&gt;   stroke_size[is.na(stroke_size)] &lt;- 0\n#&gt; \n#&gt;   pointsGrob(0.5, 0.5,\n#&gt;     pch = data$shape,\n#&gt;     gp = gpar(\n#&gt;       col = alpha(data$colour %||% \"black\", data$alpha),\n#&gt;       fill = alpha(data$fill %||% \"black\", data$alpha),\n#&gt;       fontsize = (data$size %||% 1.5) * .pt + stroke_size * .stroke / 2,\n#&gt;       lwd = stroke_size * .stroke / 2\n#&gt;     )\n#&gt;   )\n#&gt; }\n#&gt; &lt;bytecode: 0x563a748584e8&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\nIn this code, data is a data frame with a single row giving the aesthetic values to use for the key, params are the geom parameters for the layer, and size is the size of the key area in centimeters. The %||% operator, which you often see in tidyverse source code, is used to supply default values whenever a variable has a null value:\n\n`%||%` &lt;- function(x, y) {\n  if (is.null(x)) y else x\n}\n\nTo define our draw_key_spring() function, we need to create an analogous function that uses springGrob() to draw the key:\n\ndraw_key_spring &lt;- function(data, params, size) {\n  springGrob(\n    x0 = 0, \n    y0 = 0, \n    x1 = 1, \n    y1 = 1,\n    diameter = unit(data$diameter, \"cm\"), \n    tension = data$tension,\n    gp = gpar(\n      col = alpha(data$colour %||% \"black\", data$alpha),\n      lwd = (data$size %||% 0.5) * .pt,\n      lty = data$linetype %||% 1\n    ),\n    vp = viewport(clip = \"on\")\n  )\n} \n\nThe only part of this code that might be unfamiliar is the little flourish — not strictly necessary — that defines a clipping viewport for our grob using the vp argument. The reason we add this is to ensure the springs drawn in the legend keys will be strictly contained within their boxes and not spill over into the neighboring key areas.\nNow that we have this function, all we need to do is tell GeomSpring to use it when drawing the legend key. That’s pretty straightforward: all we have to do is change the draw_key() method of our existing Geom:\n\nGeomSpring$draw_key &lt;- draw_key_spring\n\nWith that final change our legend is beginning to make sense:\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5))\n\n\n\n\n\n\n\nThe default key size is a bit cramped for our key, but that’s something that the user will need to do: ggplot2 doesn’t know about the diameter aesthetic and cannot scale the key size as cleverly as it does with the size aesthetic.\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5)) +\n  theme(legend.key.size = unit(1, \"cm\"))\n\n\n\n\n\n\n\nConveniently, our new legend key will be used for all scaled aesthetics, not just diameter and tension, thus ensuring that the style of the key will always match the style of the layer:\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    colour = class\n  )) + \n  theme(legend.key.size = unit(1, \"cm\"))\n\n\n\n\n\n\n\n\n4.7.3 Post-mortem\nThis concludes our detailed case study on creating a spring geom. Hopefully it has become clear that there are many different ways to achieve the same geom extension and where you end up is largely guided by your needs and how much energy you want to put into it. The case study focused on layers and (to a lesser extent) scales, but hopefully you can use the simpler examples from Chapter 4 to guide you if you want to explore other types of ggplot2 extensions. You can also study the source code of the facet and coord classes in ggplot2 and the extensions available in ggforce and other packages.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "ggplot2_spring.html#footnotes",
    "href": "ggplot2_spring.html#footnotes",
    "title": "4  学习示例",
    "section": "",
    "text": "If you have a background in statistics, you’ll recognise this as roughly analogous to how a z-statistic is calculated.↩︎\nIf you have experience developing packages you might wonder about the choice to use rlang::abort() rather than using the base stop() function. We could certainly have chosen to use the base R function here, but since ggplot2 itself uses the rlang package it makes very little difference in this case.↩︎\nIf we were planning to bundle this code as an R package, we could expand on this and write formal unit tests for create_spring() using the testthat package.↩︎\nBy convention ggproto classes always use CamelCase for naming, and the new class is always saved into a variable with the same name.↩︎\nAs we mentioned earlier, ggproto doesn’t make a strong distinction between methods and fields. Stat objects expect compute_group() to be a function, so we refer to compute_group() as a method because that is the standard terminology in object oriented programming. In contrast, Stat expects required_aes to be a variable, so we call it a field.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>学习示例</span>"
    ]
  },
  {
    "objectID": "top50en.html",
    "href": "top50en.html",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "5.1 Correlation\n查看简体中文版本: Top 50 ggplot2 可视化 (Chapter 6)\nAn effective chart is one that:\nThe list below sorts the visualizations based on its primary purpose. Primarily, there are 8 types of objectives you may construct plots. So, before you actually make the plot, try and figure what findings and relationships you would like to convey or examine through the visualization. Chances are it will fall under one (or sometimes more) of these 8 categories.\nThese packages are used in this article:\nThe following plots help to examine how well correlated two variables are.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#correlation",
    "href": "top50en.html#correlation",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "",
    "text": "5.1.1 Scatterplot\nThe most frequently used plot for data analysis is undoubtedly the scatterplot. Whenever you want to understand the nature of relationship between two variables, invariably the first choice is the scatterplot.\n\ntheme_set(theme_bw())\noptions(scipen = 999)\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n5.1.2 Scatterplot With Encircling\nWhen presenting the results, sometimes I would encirlce certain special group of points or region in the chart so as to draw the attention to those peculiar cases. This can be conveniently done using the geom_encircle() in ggalt package.\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n5.1.3 Counts Chart\nThe second option to overcome the problem of data points overlap is to use what is called a counts chart. Whereever there is more points overlap, the size of the circle gets bigger.\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n5.1.4 Bubble plot\nWhile scatterplot lets you compare the relationship between 2 continuous variables, bubble chart serves well if you want to understand relationship within the underlying groups based on:\nA Categorical variable (by changing the color) and Another continuous variable (by changing the size of points). In simpler words, bubble charts are more suitable if you have 4-Dimensional data where two of them are numeric (X and Y) and one other categorical (color) and another numeric variable (size).\nThe bubble chart clearly distinguishes the range of displ between the manufacturers and how the slope of lines-of-best-fit varies, providing a better visual comparison between the groups.\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n5.1.5 Marginal Histogram / Boxplot\nIf you want to show the relationship as well as the distribution in the same chart, use the marginal histogram. It has a histogram of the X and Y variables at the margins of the scatterplot.\nThis can be implemented using the ggMarginal() function from the ggExtra package. Apart from a histogram, you could choose to draw a marginal boxplot or density plot by setting the respective type option.\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#deviation",
    "href": "top50en.html#deviation",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.2 Deviation",
    "text": "5.2 Deviation\nCompare variation in values between small number of items (or categories) with respect to a fixed reference.\n\n5.2.1 Diverging bars\nDiverging Bars is a bar chart that can handle both negative and positive values. This can be implemented by a smart tweak with geom_bar(). But the usage of geom_bar() can be quite confusing. Thats because, it can be used to make a bar chart as well as a histogram. Let me explain.\nBy default, geom_bar() has the stat set to count. That means, when you provide just a continuous X variable (and no Y variable), it tries to make a histogram out of the data.\nIn order to make a bar chart create bars instead of histogram, you need to do two things.\nSet stat=identity provide both x and y inside aes() where, x is either character or factor and y is numeric. In order to make sure you get diverging bars instead of just bars, make sure, your categorical variable has 2 categories that changes values at a certain threshold of the continuous variable. In below example, the mpg from mtcars dataset is normalised by computing the z score. Those vehicles with mpg above zero are marked green and those below are marked red.\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n5.2.2 Diverging Lollipop Chart\nLollipop chart conveys the same information as bar chart and diverging bar. Except that it looks more modern. Instead of geom_bar(), I use geom_point() and geom_segment() to get the lollipops right. Let’s draw a lollipop using the same data I prepared in the previous example of diverging bars.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n5.2.3 Diverging Dot Plot\nDot plot conveys similar information. The principles are same as what we saw in Diverging bars, except that only point are used. Below example uses the same data prepared in the diverging bars example.\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#ranking",
    "href": "top50en.html#ranking",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.3 Ranking",
    "text": "5.3 Ranking\nUsed to compare the position or performance of multiple items with respect to each other. Actual values matters somewhat less than the ranking.\n\n5.3.1 Dot Plot\nDot plots are very similar to lollipops, but without the line and is flipped to horizontal position. It emphasizes more on the rank ordering of items with respect to actual values and how far apart are the entities with respect to each other.\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n5.3.2 Slope Chart\nSlope charts are an excellent way of comparing the positional placements between 2 points on time. At the moment, there is no builtin function to construct this. Following code serves as a pointer about how you may approach this.\n\n# Prepare data\ndf &lt;- read_csv(\"data/top50ggplot2/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n5.3.3 Dumbbell Plot\nDumbbell charts are a great tool if you wish to: 1. Visualize relative positions (like growth and decline) between two points in time. 2. Compare distance between two categories.\nIn order to get the correct ordering of the dumbbells, the Y variable should be a factor and the levels of the factor variable should be in the same order as it should appear in the plot.\n\n# Prepare data\nhealth &lt;- read.csv(\"data/top50ggplot2/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#distribution",
    "href": "top50en.html#distribution",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.4 Distribution",
    "text": "5.4 Distribution\nWhen you have lots and lots of data points and want to study where and how the data points are distributed.\n\n5.4.1 Tufte Boxplot\nTufte box plot, provided by ggthemes package is inspired by the works of Edward Tufte. Tufte’s Box plot is just a box plot made minimal and visually appealing.\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n5.4.2 Population Pyramid\nPopulation pyramids offer a unique way of visualizing how much population or what percentage of population fall under a certain category. The below pyramid is an excellent example of how many users are retained at each stage of a email marketing campaign funnel.\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"data/top50ggplot2/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#composition",
    "href": "top50en.html#composition",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.5 Composition",
    "text": "5.5 Composition\n\n5.5.1 Waffle Chart\nWaffle charts is a nice way of showing the categorical composition of the total population. Though there is no direct function, it can be articulated by smartly maneuvering the ggplot2 using geom_tile() function. The below template should help you create your own waffle.\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n5.5.2 Treemap\nTreemap is a nice way of displaying hierarchical data by using nested rectangles. The treemapify package provides the necessary functions to convert the data in desired format (treemapify) as well as draw the actual plot (ggplotify).\nIn order to create a treemap, the data must be converted to desired format using treemapify(). The important requirement is, your data must have one variable each that describes the area of the tiles, variable for fill color, variable that has the tile’s label and finally the parent group.\nOnce the data formatting is done, just call ggplotify() on the treemapified data.\n\nproglangs &lt;- read.csv(\"data/top50ggplot2/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50en.html#groups",
    "href": "top50en.html#groups",
    "title": "5  Top 50 ggplot2 Visualizations",
    "section": "\n5.6 Groups",
    "text": "5.6 Groups\n\n5.6.1 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n5.6.2 Clusters\nIt is possible to show the distinct clusters or groups using geom_encircle(). If the dataset has multiple weak features, you can compute the principal components and draw a scatterplot using PC1 and PC2 as X and Y axis.\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Top 50 ggplot2 Visualizations</span>"
    ]
  },
  {
    "objectID": "top50zh.html",
    "href": "top50zh.html",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "",
    "text": "6.1 相关 Correlation\n英文原版 For original version in English: Top 50 ggplot2 Visualizations (Chapter 5)\n一个好的图形包含以下要素:\n下面的示例可以根据可视化的目标分为8类图表。在实际绘制之前，你应该弄清楚你想通过数据可视化来传达或研究哪些发现和关系，它很有可能属于这8个类别中的一个或多个。\n文章中用到的R包:\n下面的图形帮助解释两个变量之间的相关性。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#相关-correlation",
    "href": "top50zh.html#相关-correlation",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "",
    "text": "6.1.1 点图 Scatterplot\n最常使用的数据分析图无疑是散点图。每当您想了解两个变量之间的关系时，第一个选择就是散点图。\n\ntheme_set(theme_bw())\noptions(scipen = 999) # 关闭科学计数显示\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(color = state, size = popdensity)) +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) +\n  labs(\n    x = \"Area\",\n    y = \"Population\",\n    title = \"Scatterplot\",\n    subtitle = \"Area vs Population\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n6.1.2 有圈点图 Scatterplot With Encircling\n在展示结果时，有时会在图表中强调某些特殊点组成的区域，以引起人们对这些特殊情况的注意。使用 ggalt 软件包中的geom_encircle()可以很方便地做到这一点。\n\nmidwest_select &lt;- midwest[\n  midwest$poptotal &gt; 350000 &\n    midwest$poptotal &lt;= 500000 &\n    midwest$area &gt; 0.01 &\n    midwest$area &lt; 0.1,\n]\n\n# Plot\nggplot(midwest, aes(x = area, y = poptotal)) +\n  geom_point(aes(col = state, size = popdensity)) + # draw points\n  geom_smooth(method = \"loess\", se = F) +\n  xlim(c(0, 0.1)) +\n  ylim(c(0, 500000)) + # draw smoothing line\n  geom_encircle(aes(x = area, y = poptotal),\n    data = midwest_select,\n    color = \"red\",\n    size = 2,\n    expand = 0.08\n  ) + # encircle\n  labs(\n    subtitle = \"Area Vs Population\",\n    y = \"Population\",\n    x = \"Area\",\n    title = \"Scatterplot + Encircle\",\n    caption = \"Source: midwest\"\n  )\n\n\n\n\n\n\n\n\n6.1.3 计数图 Counts Chart\n当数据点重叠时，散点图可能无法清楚地显示数据，因此可以使用计数图。在计数图中，数据点重叠越多的地方会显示一更大的圆。\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_count(aes(colour = \"tomato3\"), show.legend = FALSE) +\n  labs(\n    subtitle = \"mpg: city vs highway mileage\",\n    y = \"hwy\",\n    x = \"cty\",\n    title = \"Counts Plot\"\n  )\n\n\n\n\n\n\n\n\n6.1.4 气泡图 Bubble plot\n散点图可以比较两个连续变量之间的关系，而气泡图则可以很好地帮助理解一个分类变量（通过改变颜色）和另一个连续变量（通过改变点的大小）的基础组内关系。简单地说，如果您有四维数据，其中两个是 X 和 Y（连续变量），另两个是表示颜色（分类变量）和大小（连续变量）的变量，那么气泡图就比较适合。\n气泡图可以清楚地区分不同制造商之间的displ范围以及最佳拟合直线斜率的变化情况，从而更好地对各组数据进行直观比较。\n\nmpg_select &lt;- mpg[mpg$manufacturer %in% c(\"audi\", \"ford\", \"honda\", \"hyundai\"), ]\nggplot(mpg_select, aes(displ, cty)) +\n  geom_jitter(aes(col = manufacturer, size = hwy)) +\n  geom_smooth(aes(col = manufacturer), method = \"lm\", se = FALSE) +\n  labs(\n    subtitle = \"mpg: Displacement vs City Mileage\",\n    title = \"Bubble chart\"\n  )\n\n\n\n\n\n\n\n\n6.1.5 边际直方图 Marginal Histogram / Boxplot\n如果想在同一张图表中显示关系和分布，可以使用边际直方图。它在散点图的边缘显示 X 和 Y 变量的直方图。\n可以使用 ggExtra 软件包中的 ggMarginal() 函数来实现。除了直方图，您还可以通过设置相应的类型选项来绘制边际盒状图或密度图。\n\n# mpg_select &lt;- mpg[mpg$hwy &gt;= 35 & mpg$cty &gt; 27, ]\ng &lt;- ggplot(mpg, aes(cty, hwy)) +\n  geom_count() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\nggMarginal(g, type = \"histogram\", fill = \"transparent\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#偏差-deviation",
    "href": "top50zh.html#偏差-deviation",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.2 偏差 Deviation",
    "text": "6.2 偏差 Deviation\n比较少量项目（或类别）之间相对于固定参照物的数值变化。\n\n6.2.1 发散型条形图 Diverging bars\n发散条形图是一种可以处理负值和正值的条形图。可以通过对 geom_bar()进行巧妙的调整来实现。但是，“geom_bar()”的用法可能相当令人困惑。这是因为它既可以用来制作柱状图，也可以用来制作直方图。让我来解释一下。\n默认情况下，geom_bar() 的统计量为计数。这意味着，当你只提供一个连续的 X 变量（而没有 Y 变量）时，它会尝试将数据制成柱状图。为了让条形图创建条形而不是直方图，需要做两件事。\n在 “aes()”中设置 “stat=identity”，同时提供 x 和 y，其中 x 是字符或因子，y 是数字。为了确保得到的是发散条形图而不是单纯的条形图，请确保您的分类变量有两个类别，其值在连续变量的某个阈值时会发生变化。在下面的示例中，mtcars 数据集中的 mpg 通过计算 z 分数进行归一化。mpg高于零的车辆标记为绿色，低于零的标记为红色。\n\nmtcars_new &lt;- mtcars |&gt;\n  mutate(\n    car_name = factor(rownames(mtcars)),\n    mpg_z = round((mpg - mean(mpg)) / sd(mpg), 2), # compute normalized mpg\n    mpg_type = ifelse(mpg_z &lt; 0, \"below\", \"above\")\n  ) |&gt; # above / below avg flag\n  arrange(mpg_z) |&gt;\n  as_tibble()\n# Diverging Barcharts\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_bar(stat = \"identity\", aes(fill = mpg_type), width = 0.5) +\n  scale_fill_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  labs(\n    subtitle = \"Normalised mileage from 'mtcars'\",\n    title = \"Diverging Bars\"\n  ) +\n  # using sorted car_name to adjust the rank of the x labels\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n6.2.2 发散型棒棒糖图 Diverging Lollipop Chart\n棒棒糖图传达的信息与柱状图和发散柱状图相同。只不过它看起来更现代。我没有使用 geom_bar()，而是使用了 geom_point() 和 geom_segment() 来正确绘制棒棒糖图。让我们用上一个发散条形图示例中的相同数据来画一个棒棒糖图。\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", fill = \"black\", size = 6) +\n  # geom_segment draw a line between\n  # (x,y) and (xend,yend)\n  geom_segment(aes(\n    y = 0, x = car_name,\n    yend = mpg_z, xend = car_name\n  ), color = \"black\") +\n  # label mpg_z -&gt; geom_text\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Lollipop Chart\",\n    subtitle = \"Normalized mileage from 'mtcars': Lollipop\"\n  ) +\n  ylim(-2.5, 2.5) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()\n\n\n\n\n\n\n\n\n6.2.3 发散型点图 Diverging Dot Plot\n点图也能传递类似的信息。其原理与我们在发散条形图中看到的相同，只是只使用了点。下面的示例使用了发散条形图示例中的相同数据。\n\nggplot(mtcars_new, aes(x = car_name, y = mpg_z, label = mpg_z)) +\n  geom_point(stat = \"identity\", aes(color = mpg_type), size = 6) +\n  scale_color_manual(\n    name = \"Mileage\",\n    labels = c(\"Above Average\", \"Below Average\"),\n    values = c(\"above\" = \"#00ba38\", \"below\" = \"#f8766d\")\n  ) +\n  geom_text(color = \"white\", size = 2) +\n  labs(\n    title = \"Diverging Dot Plot\",\n    subtitle = \"Normalized mileage from 'mtcars': Dot plot\"\n  ) +\n  scale_x_discrete(limits = mtcars_new$car_name) +\n  coord_flip()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#排序-ranking",
    "href": "top50zh.html#排序-ranking",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.3 排序 Ranking",
    "text": "6.3 排序 Ranking\n用于比较多个变量之间的的排位。在排序中，变量实际值的重要性会显得没有他们的排位重要。\n\n6.3.1 点图 Dot Plot\n点图与棒棒糖图非常相似，但没有线段，且翻转到水平位置。它更强调变量实际值的排序，以及不同变量与起始位置之间的距离。\n\n# Prepare data: group mean city mileage by manufacturer.\ncty_mpg &lt;- mpg |&gt;\n  group_by(manufacturer) |&gt;\n  summarise(mileage = mean(cty, na.rm = TRUE)) |&gt;\n  rename(make = manufacturer) |&gt;\n  mutate(make = factor(make, levels = make)) |&gt;\n  arrange(mileage)\n\nggplot(cty_mpg, aes(x = make, y = mileage)) +\n  geom_point(color = \"tomato2\", size = 3) +\n  geom_segment(\n    aes(\n      x = make, y = min(mileage),\n      xend = make, yend = max(mileage)\n    ),\n    linetype = \"dashed\", linewidth = 0.1\n  ) +\n  labs(\n    title = \"Dot Plot\",\n    subtitle = \"Make Vs Avg. Mileage\",\n    caption = \"source: mpg\"\n  ) +\n  scale_x_discrete(limits = cty_mpg$make) +\n  coord_flip()\n\n\n\n\n\n\n\n\n6.3.2 坡度图 Slope Chart\n坡度图提供了比较两点在不同时间上的位置的极佳方法。目前，还没有内置函数来构建这种图表。下面的代码可作为您如何处理这一问题的指南。\n\n# Prepare data\ndf &lt;- read_csv(\"data/top50ggplot2/gdppercap.csv\")\n\nleft_label &lt;- paste(df$continent, round(df$`1952`), sep = \",\")\nright_label &lt;- paste(df$continent, round(df$`1957`), sep = \",\")\ndf$class &lt;- ifelse(df$`1957` - df$`1952` &lt; 0, \"red\", \"green\")\n\n# Plot\nggplot(df) +\n  geom_segment(aes(x = 1, y = `1952`, xend = 2, yend = `1957`, color = class),\n    linewidth = 0.75, show.legend = FALSE\n  ) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", linewidth = 0.1) +\n  geom_vline(xintercept = 2, linetype = \"dashed\", linewidth = 0.1) +\n  scale_color_manual(\n    labels = c(\"Up\", \"Down\"),\n    values = c(\"green\" = \"#00ba38\", \"red\" = \"#f8766d\")\n  ) +\n  labs(x = \"\", y = \"Mean GdpPerCap\") +\n  xlim(0.5, 2.5) +\n  ylim(0, (1.1 * max(df$`1957`, df$`1952`))) +\n  geom_text(\n    label = left_label, y = df$`1952`,\n    x = rep(1, nrow(df)), hjust = 1.1, size = 3.5\n  ) +\n  geom_text(\n    label = right_label, y = df$`1957`,\n    x = rep(2, nrow(df)), hjust = -0.1, size = 3.5\n  ) +\n  geom_text(\n    label = \"Time 1\", x = 1,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = 1.2, size = 5\n  ) +\n  geom_text(\n    label = \"Time 2\", x = 2,\n    y = 1.1 * max(df$`1957`, df$`1952`),\n    hjust = -0.2, size = 5\n  ) +\n  theme_classic() +\n  theme(\n    panel.background = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.x = element_blank(),\n    panel.border = element_blank(),\n    plot.margin = unit(c(1, 2, 1, 2), \"cm\")\n  )\n\n\n\n\n\n\n\n\n6.3.3 哑铃图 Dumbbell Plot\n哑铃图是一个针对以下问题的很好的数据可视化工具：\n\n直观显示两个时间点之间的相对位置（如增长和下降）。\n比较两个类别变量之间的距离。\n\n为了获得正确的哑铃图排序，Y 变量应该是一个因子类型的数据，因子变量的水平应该与它在图中出现的顺序相同。\n\n# Prepare data\nhealth &lt;- read.csv(\"data/top50ggplot2/health.csv\")\n\nhealth$Area &lt;- factor(health$Area,\n  levels = as.character(health$Area)\n)\n\n# Plot\nggplot(health, aes(x = pct_2013, xend = pct_2014, y = Area, group = Area)) +\n  geom_dumbbell(\n    color = \"#a3c4dc\", size = 0.75,\n    colour_x = \"#0e668b\"\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Dumbbell Chart\",\n    subtitle = \"Pct Change: 2013 vs 2014\",\n    caption = \"Source: https://github.com/hrbrmstr/ggalt\"\n  ) +\n  theme_classic() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    plot.background = element_rect(fill = \"#f7f7f7\"),\n    panel.background = element_rect(fill = \"#f7f7f7\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey50\"),\n    axis.ticks = element_blank(),\n    legend.position = \"top\",\n    panel.border = element_blank()\n  )",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#分布-distribution",
    "href": "top50zh.html#分布-distribution",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.4 分布 Distribution",
    "text": "6.4 分布 Distribution\n当你有大量的数据点，并且想研究数据点在哪里以及如何分布时。\n\n6.4.1 Tufte Boxplot\n由 ggthemes 软件包提供的 Tufte 方框图灵感来自 Edward Tufte 的作品。Tufte 的盒状图只是一个盒状图，它的设计简约而具有视觉吸引力。\n\nggplot(mpg, aes(manufacturer, cty)) +\n  geom_tufteboxplot() +\n  theme_tufte() + # from ggthemes\n  theme(axis.text.x = element_text(angle = 65, vjust = 0.6)) +\n  labs(\n    title = \"Tufte Styled Boxplot\",\n    subtitle = \"City Mileage grouped by Class of vehicle\",\n    caption = \"Source: mpg\",\n    x = \"Class of Vehicle\",\n    y = \"City Mileage\"\n  )\n\n\n\n\n\n\n\n\n6.4.2 人口金字塔 Population Pyramid\n人口金字塔提供了一种独特的方式，可以直观地显示有多少人口或多大比例的人口属于某个类别。下面的金字塔就是一个很好的例子，说明在电子邮件营销活动中的每个阶段有多少用户被留住。\n\noptions(scipen = 999)\n\nemail_campaign_funnel &lt;- read.csv(\"data/top50ggplot2/email_campaign_funnel.csv\")\n\n# X Axis Breaks and Labels\nbrks &lt;- seq(-15000000, 15000000, 5000000)\nlbls &lt;- paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), \"m\")\n\nggplot(\n  email_campaign_funnel,\n  aes(x = Stage, y = Users, fill = Gender)\n) + # Fill column\n  geom_bar(stat = \"identity\", width = 0.6) + # draw the bars\n  scale_y_continuous(\n    breaks = brks, # Breaks\n    labels = lbls\n  ) + # Labels\n  coord_flip() + # Flip axes\n  labs(title = \"Email Campaign Funnel\") +\n  theme_tufte() + # Tufte theme from ggfortify\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    axis.ticks = element_blank()\n  ) + # Centre plot title\n  scale_fill_brewer(palette = \"Dark2\") # Color palette",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#组成-composition",
    "href": "top50zh.html#组成-composition",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.5 组成 Composition",
    "text": "6.5 组成 Composition\n\n6.5.1 华夫图 Waffle Chart\n华夫图是显示总人口分类组成的一种好方法。虽然没有直接的函数，但可以通过使用 geom_tile() 函数巧妙地操纵 ggplot2 来实现。下面的模板可以帮助你创建自己的华夫图。\n\nvar &lt;- mpg$class\ndf &lt;- expand.grid(y = 1:10, x = 1:10)\ncateg_table &lt;- round(table(var) * ((10 * 10) / (length(var))))\ndf$category &lt;- factor(rep(names(categ_table), categ_table))\n\nggplot(df, aes(x = x, y = y, fill = category)) +\n  geom_tile(color = \"black\", linewidth = 0.5) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0), trans = \"reverse\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(\n    title = \"Waffle Chart\", subtitle = \"'Class' of vehicles\",\n    caption = \"Source: mpg\"\n  ) +\n  theme(\n    plot.title = element_text(size = rel(1.2)),\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n6.5.2 树形图 Treemap\n树形图是一种通过嵌套矩形显示分层数据的好方法。treemapify 软件包提供了将数据转换为所需格式（treemapify）以及绘制实际图形（ggplotify）的必要函数。\n要创建树形图，必须使用 treemapify() 将数据转换为所需格式。您的数据必须分别包含一个变量，用于描述瓦片的面积、填充颜色、瓦片标签以及父组。\n数据格式化完成后，只需在树状地图数据上调用 ggplotify()。\n\nproglangs &lt;- read.csv(\"data/top50ggplot2/proglanguages.csv\")\n\nggplot(proglangs, aes(\n  area = value,\n  fill = parent, group = parent, label = id\n)) +\n  geom_treemap() +\n  geom_treemap_text(\n    fontface = \"italic\", colour = \"white\", place = \"centre\",\n    grow = TRUE\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  },
  {
    "objectID": "top50zh.html#分组-groups",
    "href": "top50zh.html#分组-groups",
    "title": "6  Top 50 ggplot2 可视化",
    "section": "\n6.6 分组 Groups",
    "text": "6.6 分组 Groups\n\n6.6.1 分层树枝图 Hierarchical Dendrogram\n\ntheme_set(theme_bw())\n\nhc &lt;- hclust(dist(USArrests), \"ave\")  # hierarchical clustering\n\n# plot\nggdendrogram(hc, rotate = TRUE, size = 2)\n\n\n\n\n\n\n\n\n6.6.2 聚类 Clusters\n可以使用 geom_encircle()来显示不同的聚类或分组。如果数据集具有多个弱特征，可以计算主成分，并以 PC1 和 PC2 为 X 轴和 Y 轴绘制散点图。\n\ntheme_set(theme_classic())\n\n# Compute data with principal components ------------------\ndf &lt;- iris[c(1, 2, 3, 4)]\npca_mod &lt;- prcomp(df) # compute principal components\n\n# Data frame of principal components ----------------------\ndf_pc &lt;- data.frame(pca_mod$x,\n  Species = iris$Species\n) # dataframe of principal components\ndf_pc_vir &lt;- df_pc[df_pc$Species == \"virginica\", ] # df for 'virginica'\ndf_pc_set &lt;- df_pc[df_pc$Species == \"setosa\", ] # df for 'setosa'\ndf_pc_ver &lt;- df_pc[df_pc$Species == \"versicolor\", ] # df for 'versicolor'\n\n# Plot ----------------------------------------------------\nggplot(df_pc, aes(PC1, PC2, col = Species)) +\n  geom_point(aes(shape = Species), size = 2) + # draw points\n  labs(\n    title = \"Iris Clustering\",\n    subtitle = \"With principal components PC1 and PC2 as X and Y axis\",\n    caption = \"Source: Iris\"\n  ) +\n  coord_cartesian(\n    xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)),\n    ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))\n  ) + # change axis limits\n  geom_encircle(data = df_pc_vir, aes(x = PC1, y = PC2)) + # draw circles\n  geom_encircle(data = df_pc_set, aes(x = PC1, y = PC2)) +\n  geom_encircle(data = df_pc_ver, aes(x = PC1, y = PC2))",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Top 50 ggplot2 可视化</span>"
    ]
  }
]